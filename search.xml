<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2019/06/23/Flutter%E6%89%93%E5%8C%85/"/>
      <url>/2019/06/23/Flutter%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter-打包"><a href="#Flutter-打包" class="headerlink" title="Flutter 打包"></a>Flutter 打包</h1><h3 id="app-图标替换"><a href="#app-图标替换" class="headerlink" title="app 图标替换"></a>app 图标替换</h3><h4 id="Android-图标更换"><a href="#Android-图标更换" class="headerlink" title="Android 图标更换"></a>Android 图标更换</h4><ul><li>替换图中路径的图片资源即可，</li><li>注意图片名字需要是 ic_launcher</li><li>每个尺寸对应不同的文件大小<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4bgpxs583j30ko1000wv.jpg" alt></li></ul><ul><li>如果要修改启动图片名称需要先在主配置文件中修改</li></ul><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4bgwlvax4j31li0o4aik.jpg" alt></p><h4 id="iOS-图标更换"><a href="#iOS-图标更换" class="headerlink" title="iOS 图标更换"></a>iOS 图标更换</h4><h4 id="修改app图标名称"><a href="#修改app图标名称" class="headerlink" title="修改app图标名称"></a>修改app图标名称</h4><ul><li>找到 Android 主配置文件</li><li>修改 android:label=”app_flutter” 中名称<br><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4bgrcevo1j31kt0u0asy.jpg" alt></li></ul><h4 id="修改app-的名称"><a href="#修改app-的名称" class="headerlink" title="修改app 的名称"></a>修改app 的名称</h4><h3 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h3><h4 id="生成key"><a href="#生成key" class="headerlink" title="生成key"></a>生成key</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/23/Flutter%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/23/Flutter%E4%B8%AD%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E8%B5%84%E6%BA%90%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter中本地图片资源使用"><a href="#Flutter中本地图片资源使用" class="headerlink" title="Flutter中本地图片资源使用"></a>Flutter中本地图片资源使用</h1><h2 id="新建图片文件目录"><a href="#新建图片文件目录" class="headerlink" title="新建图片文件目录"></a>新建图片文件目录</h2><p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4bgdobfvvj30k80wy43y.jpg" alt></p><h2 id="添加图片到项目"><a href="#添加图片到项目" class="headerlink" title="添加图片到项目"></a>添加图片到项目</h2><p>手动投入图片到新建的文件目录</p><h2 id="声明图片资源"><a href="#声明图片资源" class="headerlink" title="声明图片资源"></a>声明图片资源</h2><p>找到项目中 pubspec.yaml 文件，找到 assets: 选项 按照注释代码格式声明图片路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assets:</span><br><span class="line">  - lib/assets/ideaOne.png</span><br></pre></td></tr></table></figure><h2 id="使用图片资源"><a href="#使用图片资源" class="headerlink" title="使用图片资源"></a>使用图片资源</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Image.asset(&apos;lib/assets/ideaOne.png&apos;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/20/Flutter%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/"/>
      <url>/2019/06/20/Flutter%E9%A1%B5%E9%9D%A2%E5%AF%BC%E8%88%AA/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter页面导航"><a href="#Flutter页面导航" class="headerlink" title="Flutter页面导航"></a>Flutter页面导航</h1><h2 id="导航栏的使用"><a href="#导航栏的使用" class="headerlink" title="导航栏的使用"></a>导航栏的使用</h2><p>程序主入口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line"></span><br><span class="line">  // 声明参数</span><br><span class="line">  final List&lt;String&gt; items;</span><br><span class="line"></span><br><span class="line">  // 构造函数</span><br><span class="line">  MyApp(&#123;Key key, @required this.items&#125;):super(key: key); // 调用父类的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  // 重写</span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    // 返回一窗口</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title:&apos;Flutter --&apos;,</span><br><span class="line">      // 基础组件学习</span><br><span class="line">      // home: MyLearningFlutterHome(),</span><br><span class="line"></span><br><span class="line">      home: FirstScreen(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="导航栏页面跳转参数传递"><a href="#导航栏页面跳转参数传递" class="headerlink" title="导航栏页面跳转参数传递"></a>导航栏页面跳转参数传递</h3><p>商品类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">  final String title; // 定义商品标题</span><br><span class="line">  final String description;</span><br><span class="line">  // 定义构造方法</span><br><span class="line">  Product(this.title, this.description);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第一级页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class FirstScreen extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: new Text(&apos;第一个页面&apos;),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: new Text(&apos;点击跳转详情页&apos;),</span><br><span class="line">          onPressed: ()&#123;</span><br><span class="line">            Navigator.push(context, new MaterialPageRoute(</span><br><span class="line">              builder: (context) =&gt; (new SecondScreen())</span><br><span class="line">              // builder: (context)&#123;</span><br><span class="line">              //   new SecondScreen();</span><br><span class="line">              // &#125;</span><br><span class="line">            ));</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>详情页面<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class SecondScreen extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&apos;详情页面&apos;)</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      body: Center(</span><br><span class="line">        child: RaisedButton(</span><br><span class="line">          child: Text(&apos;返回上一级页面&apos;),</span><br><span class="line"></span><br><span class="line">          onPressed: () =&gt; (Navigator.pop(context)),</span><br><span class="line">          </span><br><span class="line">          // onPressed: ()&#123;</span><br><span class="line">          //   Navigator.pop(context);</span><br><span class="line">          // &#125;,</span><br><span class="line">        ), </span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="导航栏页面返回反向参数传递"><a href="#导航栏页面返回反向参数传递" class="headerlink" title="导航栏页面返回反向参数传递"></a>导航栏页面返回反向参数传递</h3><p>使用异步请求和等待</p><p>商品列表页面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class ProductListView extends StatelessWidget &#123;</span><br><span class="line">  // 定义变量，里面是一个对象</span><br><span class="line">  final List&lt;Product&gt; products;</span><br><span class="line">  </span><br><span class="line">  // 使用构造方法 函数的方式接受参数</span><br><span class="line">  ProductListView(&#123;Key key, @required this.products&#125;):super(key:key); // 设置必参，调用父类方法</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&apos;商品列表&apos;),</span><br><span class="line">      ),</span><br><span class="line"></span><br><span class="line">      // 使用 ListView.builder 动态构建</span><br><span class="line">      body: ListView.builder(</span><br><span class="line">        itemCount: products.length,</span><br><span class="line">        itemBuilder: (context, index) &#123;</span><br><span class="line">          return ListTile(</span><br><span class="line">            title: Text(products[index].title),</span><br><span class="line">            onLongPress: ()&#123;</span><br><span class="line">              print(&quot;长按事件响应&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            // 点击时传入参数</span><br><span class="line">            onTap: ()&#123;</span><br><span class="line">              print(&apos;点击事件&apos;);</span><br><span class="line">              Navigator.push(</span><br><span class="line">                context, </span><br><span class="line">                MaterialPageRoute(</span><br><span class="line">                  builder: (context) =&gt; ProducterDetailView(product:products[index])</span><br><span class="line">                )</span><br><span class="line">              );</span><br><span class="line">            &#125;,</span><br><span class="line">          );</span><br><span class="line">        &#125;,</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>商品详情页面点击按钮返回上一级页面，并带有参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class ProducterDetailView extends StatelessWidget &#123;</span><br><span class="line">  final Product product;</span><br><span class="line"></span><br><span class="line">  ProducterDetailView(&#123;Key key, @required this.product&#125;):super(key:key);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(&apos;Product $&#123;product.title&#125; 详情页面&apos;)</span><br><span class="line">      ),</span><br><span class="line">      </span><br><span class="line">      body: Center(</span><br><span class="line">        // 有多控件</span><br><span class="line">        child: Column(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(&apos;Product $&#123;product.title&#125; desc $&#123;product.description&#125;&apos;),</span><br><span class="line">            RaisedButton(</span><br><span class="line">              child: Text(&apos;back Product List&apos;),</span><br><span class="line">              color: Colors.blue,</span><br><span class="line">              onPressed: ()&#123;</span><br><span class="line">                Navigator.pop(context, &apos;selected Id = $&#123;product.title&#125;&apos;);</span><br><span class="line">              &#125;,</span><br><span class="line">            )</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/19/Flutter%E4%B8%AD%E5%B8%83%E5%B1%80/"/>
      <url>/2019/06/19/Flutter%E4%B8%AD%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Flutter中布局"><a href="#Flutter中布局" class="headerlink" title="Flutter中布局"></a>Flutter中布局</h1><h2 id="线性布局"><a href="#线性布局" class="headerlink" title="线性布局"></a>线性布局</h2><h3 id="主轴、副轴"><a href="#主轴、副轴" class="headerlink" title="主轴、副轴"></a>主轴、副轴</h3><ul><li><p>main轴：如果用column组件，垂直就是主轴，如果用Row组件，那水平就是主轴</p></li><li><p>cross轴：幅轴，是和主轴垂直的方向。用Row组件，那垂直就是幅轴，Column组件，水平方向就是副轴</p></li></ul><h3 id="Row-水平方向布局组件"><a href="#Row-水平方向布局组件" class="headerlink" title="Row 水平方向布局组件"></a>Row 水平方向布局组件</h3><ul><li>非自适应布局：根据元素本身大小来布局</li><li>自适应布局：使用 Expanded 布局</li></ul><p>非自适应布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class MyRowNoChangeLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Container(</span><br><span class="line">         child: Row(</span><br><span class="line">           children: &lt;Widget&gt;[</span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 红色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.red,</span><br><span class="line">               child: new Text(&apos;按钮一红色&apos;),</span><br><span class="line">               </span><br><span class="line">             ),</span><br><span class="line"></span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 黄色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.yellow,</span><br><span class="line">               child: new Text(&apos;按钮一黄色&apos;),</span><br><span class="line">               </span><br><span class="line">             ),</span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 绿色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.green,</span><br><span class="line">               child: new Text(&apos;按钮一绿色&apos;),</span><br><span class="line">               </span><br><span class="line">             )</span><br><span class="line">           ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自适应布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class MyRowAutoLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Container(</span><br><span class="line">         child: Row(</span><br><span class="line">           children: &lt;Widget&gt;[</span><br><span class="line">             Expanded(</span><br><span class="line">               child: new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 红色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.red,</span><br><span class="line">               child: new Text(&apos;按钮一红色&apos;),</span><br><span class="line">              ),</span><br><span class="line">             ),</span><br><span class="line"></span><br><span class="line">             Expanded(</span><br><span class="line">               child: new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 黄色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.yellow,</span><br><span class="line">               child: new Text(&apos;按钮一黄色&apos;),</span><br><span class="line">               </span><br><span class="line">             )</span><br><span class="line">             ),</span><br><span class="line">             </span><br><span class="line">             Expanded(</span><br><span class="line">               child: new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 绿色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.green,</span><br><span class="line">               child: new Text(&apos;按钮一绿色&apos;),</span><br><span class="line">               </span><br><span class="line">              )</span><br><span class="line">             )</span><br><span class="line">           ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非自动布局和自动布局混合使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MyRowLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Container(</span><br><span class="line">         child: Row(</span><br><span class="line">           children: &lt;Widget&gt;[</span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 红色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.red,</span><br><span class="line">               child: new Text(&apos;按钮一红色&apos;),</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">             Expanded(</span><br><span class="line">               child: new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 黄色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.yellow,</span><br><span class="line">               child: new Text(&apos;按钮一黄色&apos;),</span><br><span class="line">               </span><br><span class="line">             )</span><br><span class="line">             ),</span><br><span class="line">             </span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 绿色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.green,</span><br><span class="line">               child: new Text(&apos;按钮一绿色&apos;),</span><br><span class="line">               </span><br><span class="line">              )</span><br><span class="line">           ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Column-垂直方向布局组件"><a href="#Column-垂直方向布局组件" class="headerlink" title="Column 垂直方向布局组件"></a>Column 垂直方向布局组件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class MyColunmLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Container(</span><br><span class="line">        color: Colors.cyan,</span><br><span class="line">         child: Column(</span><br><span class="line">           crossAxisAlignment: CrossAxisAlignment.stretch,</span><br><span class="line">           mainAxisSize: MainAxisSize.max,</span><br><span class="line">           // 设置主轴的对齐方式</span><br><span class="line">           mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">           // 设置横轴的对齐方式</span><br><span class="line">           crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">           children: &lt;Widget&gt;[</span><br><span class="line">             new RaisedButton (</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 红色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line"></span><br><span class="line">               color: Colors.red,</span><br><span class="line">               child: new Text(&apos;按钮一红色&apos;),</span><br><span class="line">              ),</span><br><span class="line">             </span><br><span class="line">             new RaisedButton(</span><br><span class="line">               onPressed: ()&#123;</span><br><span class="line">                 print(&apos;点击了---- 绿色&apos;);</span><br><span class="line">               &#125;,</span><br><span class="line">               color: Colors.green,</span><br><span class="line">               child: new Text(&apos;按钮一绿色&apos;),</span><br><span class="line">              ),</span><br><span class="line"></span><br><span class="line">              new Text(&apos;文字内容&apos;,</span><br><span class="line">                textAlign: TextAlign.center,</span><br><span class="line">              ),</span><br><span class="line">              new Text(&apos;测试文字&apos;,</span><br><span class="line">                textAlign: TextAlign.right,</span><br><span class="line">              )</span><br><span class="line">           ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="层叠布局"><a href="#层叠布局" class="headerlink" title="层叠布局"></a>层叠布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">// stack层叠布局</span><br><span class="line"></span><br><span class="line">class MyStackLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // 返回一个 Stack 布局</span><br><span class="line">    return new Stack(</span><br><span class="line">      // 设置位置</span><br><span class="line">      alignment: const FractionalOffset(0.5, .9),</span><br><span class="line">     // 圆角组件</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        new CircleAvatar(</span><br><span class="line">          backgroundImage: new NetworkImage(&apos;https://p.ampmake.com/mall/product/26153760-b964-45d5-b811-7f2bf5844102.jpg&apos;),</span><br><span class="line">          // backgroundImage: new Image.network(&apos;https://p.ampmake.com/mall/product/26153760-b964-45d5-b811-7f2bf5844102.jpg&apos;),</span><br><span class="line">          radius: 100.0,</span><br><span class="line">        ),</span><br><span class="line">        </span><br><span class="line">        // 容器组件</span><br><span class="line">        new Container(</span><br><span class="line">        // 设置容器掩饰</span><br><span class="line">          decoration: BoxDecoration(</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">            // border </span><br><span class="line">            border: Border.all(</span><br><span class="line">              color: Colors.red,</span><br><span class="line">              width: 3,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">          </span><br><span class="line">          padding: const EdgeInsets.all(10.0),</span><br><span class="line">          </span><br><span class="line">          child: new Text(&apos;stack 布局&apos;,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            maxLines: 1,</span><br><span class="line">            // 文字样式</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              color: Colors.yellow,</span><br><span class="line">              textBaseline: TextBaseline.ideographic,</span><br><span class="line">              // 下划线</span><br><span class="line">              decoration: TextDecoration.underline,</span><br><span class="line">              // 下划线颜色</span><br><span class="line">              decorationColor: Colors.orange,</span><br><span class="line">              // 下划线样式</span><br><span class="line">              decorationStyle: TextDecorationStyle.double,</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">      </span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Positioned组件"><a href="#Positioned组件" class="headerlink" title="Positioned组件"></a>Positioned组件</h3><ul><li>bottom: 距离层叠组件下边的距离</li><li>left：距离层叠组件左边的距离</li><li>top：距离层叠组件上边的距离</li><li>right：距离层叠组件右边的距离</li><li>width: 层叠定位组件的宽度</li><li>height: 层叠定位组件的高度</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">class MyMoreStackLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Stack(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        new CircleAvatar(</span><br><span class="line">          backgroundImage: NetworkImage(&apos;https://p.ampmake.com/mall/product/26153760-b964-45d5-b811-7f2bf5844102.jpg&apos;),</span><br><span class="line">          radius: 100.0,</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        new Positioned(</span><br><span class="line">          top: 5,</span><br><span class="line">          left: 50,</span><br><span class="line">          // right: 5,</span><br><span class="line">          width: 100,</span><br><span class="line">          child: new RaisedButton(</span><br><span class="line">            onPressed: ()&#123;</span><br><span class="line">              print(&quot;多个组件层叠布局&quot;);</span><br><span class="line">            &#125;,</span><br><span class="line">            </span><br><span class="line">            color: Colors.deepOrange,</span><br><span class="line">            child: Text(&apos;测试按钮&apos;),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        </span><br><span class="line">        new Positioned(</span><br><span class="line">          bottom: 10,</span><br><span class="line">          right: 10,</span><br><span class="line">          left: 10,</span><br><span class="line">          child: new Text(&apos;flutter 多个试图 stack布局&apos;,</span><br><span class="line">            maxLines: 1,</span><br><span class="line">            textAlign: TextAlign.center,</span><br><span class="line">            style: TextStyle(</span><br><span class="line">              color: Colors.lightGreen,</span><br><span class="line">              fontSize: 20,</span><br><span class="line">              fontStyle: FontStyle.italic</span><br><span class="line">            ),</span><br><span class="line">          )</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Card-布局"><a href="#Card-布局" class="headerlink" title="Card 布局"></a>Card 布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">class MyCardLayout extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return new Card(</span><br><span class="line">      child:  Column(</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          new ListTile(</span><br><span class="line">            title: new Text(&apos;card 布局1&apos;),</span><br><span class="line">            subtitle: new Text(&apos;子标题1&apos;, </span><br><span class="line">              textAlign: TextAlign.right,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.lightGreen</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            leading: new Icon(Icons.account_balance, color: Colors.purple)</span><br><span class="line">          ),</span><br><span class="line">          </span><br><span class="line">          new Divider(</span><br><span class="line">            color: Colors.cyan</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          new ListTile(</span><br><span class="line">            title: new Text(&apos;card 布局2&apos;),</span><br><span class="line">            subtitle: new Text(&apos;子标题2&apos;, </span><br><span class="line">              textAlign: TextAlign.right,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.lightGreen</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            leading: new Icon(Icons.account_box, color: Colors.yellow)</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          new Divider(</span><br><span class="line">            color: Colors.red,</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          new ListTile(</span><br><span class="line">            title: new Text(&apos;card 布局3&apos;),</span><br><span class="line">            subtitle: new Text(&apos;子标题3&apos;, </span><br><span class="line">              textAlign: TextAlign.right,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.lightGreen</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            leading: new Icon(Icons.account_circle, color: Colors.red)</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          new Divider(</span><br><span class="line">            color: Colors.orangeAccent,</span><br><span class="line">          ),</span><br><span class="line"></span><br><span class="line">          new ListTile(</span><br><span class="line">            title: new Text(&apos;card 布局4&apos;),</span><br><span class="line">            subtitle: new Text(&apos;子标题4&apos;, </span><br><span class="line">              textAlign: TextAlign.right,</span><br><span class="line">              style: TextStyle(</span><br><span class="line">                color: Colors.lightGreen</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            leading: new Icon(Icons.camera_enhance, color: Colors.brown)</span><br><span class="line">          )</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>GridView组件使用.md</title>
      <link href="/2019/06/18/Flutter%E4%B8%ADGridView%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/18/Flutter%E4%B8%ADGridView%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="GridView-组件使用"><a href="#GridView-组件使用" class="headerlink" title="GridView 组件使用"></a>GridView 组件使用</h2><ul><li>padding: const EdgeInsets.all(10.0) 设置边距为10</li><li>crossAxisCount：横轴子元素的数量crossAxisCount。</li><li>mainAxisSpacing：主轴方向的间距。</li><li>crossAxisSpacing：横轴元素的间距。</li><li>childAspectRatio：元素的宽高比</li></ul><p>简单例子代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class MyGridView2 extends StatelessWidget&#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // TODO: implement build</span><br><span class="line">    return Container(</span><br><span class="line">      child: new GridView(</span><br><span class="line">        // 设置边距</span><br><span class="line">        padding: const EdgeInsets.all(10.0),</span><br><span class="line">        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(</span><br><span class="line">          </span><br><span class="line">          // 横轴 数量</span><br><span class="line">          crossAxisCount: 3,</span><br><span class="line">          crossAxisSpacing: 10,</span><br><span class="line">          mainAxisSpacing: 10.0,  </span><br><span class="line">          // 宽高比：默认是1.0        </span><br><span class="line">          childAspectRatio: 1.5,</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          new Image.network(&apos;https://github.com/Jinxiansen/SwiftUI/raw/master/images/example/Text.png&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/9666f00e-f02a-46ce-9b7c-090bf6aba9aa.png&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/d6fdc891-eec3-47ce-b837-df726c73a9b8.png&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/0cccf224-57d1-4a3e-bf06-9df5fed0f4e0.png&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/2bf5c0d7-dc3a-45d2-ab1b-40fe737aa79a.jpg&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/26153760-b964-45d5-b811-7f2bf5844102.jpg&apos;, fit: BoxFit.cover),</span><br><span class="line">        new Image.network(&apos;https://p.ampmake.com/mall/product/a20bb53c-b710-4b39-9607-91bef06ee54e.png&apos;, fit: BoxFit.cover),</span><br><span class="line">        ],</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前的写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class MyGridView extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: new GridView.count(</span><br><span class="line">        padding: const EdgeInsets.all(15.0),</span><br><span class="line">        // 横轴 item 数量</span><br><span class="line">        crossAxisCount: 3,</span><br><span class="line">        // 横轴 间距</span><br><span class="line">        crossAxisSpacing: 10.0,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          const Text(&apos;我是第一个&apos;),</span><br><span class="line">          const Text(&apos;我是第二个&apos;),</span><br><span class="line">          const Text(&apos;我是第三个&apos;),</span><br><span class="line">          const Text(&apos;我是第四个&apos;),</span><br><span class="line">          const Text(&apos;我是第五个&apos;),</span><br><span class="line">          const Text(&apos;我是第六个&apos;),</span><br><span class="line">          const Text(&apos;我是第七个&apos;),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter GridView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第十四章 第三方库</p><h3 id="AFNetworking"><a href="#AFNetworking" class="headerlink" title="AFNetworking"></a>AFNetworking</h3><h4 id="框架图"><a href="#框架图" class="headerlink" title="框架图"></a>框架图</h4><h4 id="会话NSURSession"><a href="#会话NSURSession" class="headerlink" title="会话NSURSession"></a>会话NSURSession</h4><p><img src="https://i.loli.net/2019/04/19/5cb92763a70c9.jpg" alt></p><h4 id="主要类关系图"><a href="#主要类关系图" class="headerlink" title="主要类关系图"></a>主要类关系图</h4><p><img src="https://i.loli.net/2019/04/19/5cb927e446880.jpg" alt></p><h4 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h4><ul><li>创建和管理 NSURLSession， NSURLSessionTask </li><li>实现NSURLSessionDelegate 等协议的代理方法</li><li>引入AFSecurityPolicy 保证请求安全，https 请求时 证书检验，公钥验证</li><li>引入AFNetworkReachabilityManager 监控网络状态</li></ul><h3 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h3><p>架构图</p><p><img src="https://i.loli.net/2019/04/19/5cb92fed65b5f.jpg" alt></p><p>加载图片流程<br><img src="https://i.loli.net/2019/04/19/5cb93011b9d52.jpg" alt></p><h3 id="Reactive-Cocoa"><a href="#Reactive-Cocoa" class="headerlink" title="Reactive Cocoa"></a>Reactive Cocoa</h3><p><img src="https://i.loli.net/2019/04/19/5cb9303d51275.jpg" alt></p><p>RACStream</p><p><img src="https://i.loli.net/2019/04/19/5cb930588621e.jpg" alt></p><h3 id="AsyncDisplayKit"><a href="#AsyncDisplayKit" class="headerlink" title="AsyncDisplayKit"></a>AsyncDisplayKit</h3><p>主要解决的问题</p><p><img src="https://i.loli.net/2019/04/19/5cb93096d7ecd.jpg" alt></p><p>基本原理</p><p><img src="https://i.loli.net/2019/04/19/5cb930c6d0bff.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%9B%9B%E7%AB%A0OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%9B%9B%E7%AB%A0OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="OC-语言特性"><a href="#OC-语言特性" class="headerlink" title="OC 语言特性"></a>OC 语言特性</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由运行时来决议的，不同分类当中含有同名方法 谁最终生效取决于谁最终参与编译，最后参编译的同名分类方法会最终生效，假如分类方法中添加的方法和宿主类中的某一个方法名相同，分类中的方法会覆盖宿主类中的同名方法，覆盖是指在消息传递过程中优先查找数组靠前的元素，如果查找到了同名方法就直接调用，实际上宿主类的同名方法实现仍然是存在的，我们可可以通过一些手段调用到原有类的同名方法的实现 </p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>申明私有方法，分类的 .m 文件中申明私有方法啊，对外不暴露</li><li>对类中的代码进行抽取分解</li><li>把Framework的私有方法公开化</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>运行时决议，运行时通过runtime 才把分类中的方法添加到了宿主类上</li><li>可以为系统类添加方法</li><li>有多个分类中存在同名方法时，最后编译的方法会最先生效</li><li>分类中有和宿主类同名方法时，底层中通过内存copy将分类方法“覆盖”宿主类方法</li><li>名字相同的分类编译会报错</li></ul><h3 id="分类中可以添加的内容"><a href="#分类中可以添加的内容" class="headerlink" title="分类中可以添加的内容"></a>分类中可以添加的内容</h3><ul><li>实例方法</li><li>类方法</li><li>协议</li><li>属性，实际上只是声明了 getter / setter 方法，并没有添加成员变量</li></ul><h3 id="关联对象技术"><a href="#关联对象技术" class="headerlink" title="关联对象技术"></a>关联对象技术</h3><p>关联对象由 AssocicationsManager 管理并在 AssociationsHashMap 上存储<br>所有对象的关联内容都在同一个全局容器中</p><ul><li>给分类添加成员变量，通过关联对象的方式</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>声明私有属性</li><li>声明私有方法</li><li>声明私有成员变量</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>编译时决议</li><li>只以声明的形式存在，多数情况下寄生在宿主类的.m中</li><li>不能为系统添加扩展</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul><li>代理设计模式，传递方式是一对一</li><li>使用weak 避免循环引用</li></ul><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>使用观察者模式来实现的用于跨层传递消息的机制</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>KVO 是系统对观察者模式的又一实现，使用isa 混写技术（isa - swizzling）来动态运行时为某一个类添加一个子类重写了它的setter 方法，同时将原有类的isa指针指向了新创建的类上</p><ul><li>KVO 是OC对观察者模式的又一实现</li><li>apple 使用isa 混写技术（isa - swizzling）来实现KVO<ul><li>给我A类注册一个观察者时本质上是调用系统的 Observer for keyPath 方法，系统会创建一个NSKVONotifiying_A 的类</li></ul></li><li>使用 setter 方法设置值KVO才能生效</li><li>使用setValue:forKey: 改变值KVO才能生效</li><li>使用下划线的成员变量直接修改值需要手动添加KVO才能生效（增加 willChangeValueForKey 和 didChangeValueForKey 两个方法）</li></ul><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>apple提供的键值编码技术</p><ul><li>(nullable id)valueForKey:(NSString *)key;</li><li><p>(void)setValue:(nullable id)value forKey:(NSString *)key;</p><p>  以上两个方法中的key是没有任何限制的，只要知道对应的成员变量名称，就可以对私有的成员变量设置和操作，这违背了面向对象的编程思想</p></li></ul><p><strong>(void)setValue:(nullable id)value forKey:(NSString *)key; 方法调用流程</strong></p><ul><li>先判断是否有跟key 相关的setter 方法，如果有就直接调用，结束调用</li><li>如果没有再判断是否存在实例变量，如果存在直接给赋值，结束调用</li><li>如果说实例变量不存在，会去调用 <code>- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</code> 抛出异常</li></ul><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><h3 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h3><ul><li><p>readonly</p></li><li><p>readwrite 系统默认</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>atomic （系统默认）保证赋值和获取（对成员属性的直接获取和赋值）时线程安全，并不代表操作和访问，如果atomic修饰的一个数组，只能保证独具改数组的读取和赋值时线程安全，并不能保证对数据操作（增加/删除数组元素）时是安全的</li><li>nonatomic</li></ul><h3 id="引用技术"><a href="#引用技术" class="headerlink" title="引用技术"></a>引用技术</h3><ul><li>assign <ul><li>修饰基本数据类型，</li><li>修饰对象时不改变其引用计数，</li><li>会产生悬垂指针</li></ul></li><li>weak  <ul><li>不改变被修饰对象的引用计数，</li><li>所指对象被释放之后指针自动置为nil</li></ul></li></ul><p><strong>两者区别：</strong></p><ul><li>weak可以修饰对象，而assign 既可以修饰对象也可以修饰基本数据类型</li><li>assign 修饰的对象，对象释放后指针仍然指向原对象的内存地址，而weak 修饰的对象，释放后会自动置为nil</li></ul><p><strong>问题1</strong> </p><p>weak 修饰的对象为什么释放后会自动置为nil</p><p><strong>问题2</strong></p><p><code>@property (copy) NSMutableArray *array;</code> 有什么问题</p><ul><li>被copy修饰后，如果赋值过来的是NSMutableArray，copy之后就是NSArray，如果赋值过来的是NSAarray，copy 之后仍然是NSArray，有可能会调用array的添加元素方法会导致crash</li></ul><h3 id="copy-关键词"><a href="#copy-关键词" class="headerlink" title="copy 关键词"></a>copy 关键词</h3><p> <img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1uh6lwwe2j320s0lm7bm.jpg" alt></p><ul><li>浅拷贝：内存地址的复制，让目标对象指针和源对象指向同一块内存空间，<ul><li>会增加对象的引用计数</li><li>并没有一个新的内存分配</li></ul></li></ul><ul><li>深拷贝：目标对象指针和源对象指针分别指向两块内容相同的内存空间<ul><li>不会增加源对象的引用计数</li><li>有新对象的内存分配</li></ul></li></ul><h2 id="MRC-重写-retain修饰的变量的setter-方法"><a href="#MRC-重写-retain修饰的变量的setter-方法" class="headerlink" title="MRC 重写 retain修饰的变量的setter 方法"></a>MRC 重写 retain修饰的变量的setter 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)setObj:(id)obj &#123;</span><br><span class="line">    if (_obj != obj) &#123;</span><br><span class="line">        [_obj release];</span><br><span class="line">    &#125;</span><br><span class="line">    _obj = [obj retain];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是为了防止异常处理，如果不做 if 判断，当传入的 obj 对象正好是原来的_obj 对象，对原对象尽行releas 操作，实际上也会对传入的对象进行releas 操作进行释放，此时如果再通过obj指针访问废弃的对象时就会导致carsh</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%8D%81%E7%AB%A0%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%8D%81%E7%AB%A0%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>第十章 网络请求相关</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>超文本传输协议</p><h4 id="请求-响应报文"><a href="#请求-响应报文" class="headerlink" title="请求/响应报文"></a>请求/响应报文</h4><p>请求报文：</p><ul><li><p>请求行<br>  方法  URL  协议版本(1.1版本)  CRLF(回车) </p></li><li><p>首部字段区域<br>  首部字段名(key) ：值（value ）CRLF<br>  首部字段名(key) ：值（value ）CRLF</p></li><li><p>实体主体<br>  get 请求没有<br>  post 有实体主体</p></li></ul><p>响应报文：</p><ul><li><p>响应行<br>  版本  状态码  状态码描述（短语）   CRLF</p></li><li><p>首部字段区</p></li><li></li><li>响应实体主体</li></ul><h4 id="连接建立流程"><a href="#连接建立流程" class="headerlink" title="连接建立流程"></a>连接建立流程</h4><p>三次握手和四次挥手</p><p>三次握手</p><ul><li>客户端 发送 syn 同步报文到Server，</li><li>server 端收到syn报文后会，链接建立，server 端会返回一个 syn，ack 报文给客户端，</li><li>客户端收到 server 端的ask 报文后，会再次回应一个确认ack 的报文</li></ul><p>数据请求</p><ul><li>接下来在已经建立的tcp 通道上进行http 的请求报文</li><li>server 端回复给客户端一个http响应报文</li></ul><p>四次挥手</p><ul><li>客户端发送 fin 终止报文到server 端</li><li>server 端收到报文后会回回复一个ack 报文到客户端</li><li>客户端到server 端的tcp的链接已经断开，但是 server 端到客户端的链接还会传输数据</li><li>server 端向客户端发送一个fin ack 报文 ，然后客户端回应给server 一个ack 报文，释放链接</li></ul><h4 id="HTTP-的特点"><a href="#HTTP-的特点" class="headerlink" title="HTTP 的特点"></a>HTTP 的特点</h4><ul><li><p>无连接<br>  非持久链接 需要多次断开/建立链接，就会经历 三次握手，四次挥手</p><p>  HTTP 的持久链接： 多个http请求在同一个tcp 通道上， 一定时间内不会断开tcp通道，提高了网络请求的效率</p><p>  头部字段：</p><pre><code>coonection ： keep-alive 客户端是否采用持久链接time ：20 多长时间有效max：10 最多发生多少个http请求和响应对</code></pre></li><li><p>无状态<br>  同一个用户多次发送http请求，server 端是不知道是同一个用户的，server 端通过 Cookie/Session 规避这个问题</p><ul><li><p>cookie<br>  cookie 主要是用来记录用户状态，区分用户，cookie由server端返回给客户端，cookie 状态保存在客户端</p><p>保证cookie 的安全</p><ul><li>cookie 加密处理</li><li>只在https 上携带Cookie</li><li>设置Cookie为 httpOnly，防止跨站脚本攻击</li></ul></li><li><p>session 用来记录用户的状态，区分用户，状态存放在服务端</p></li></ul></li></ul><h3 id="HTTPS-与网络安全"><a href="#HTTPS-与网络安全" class="headerlink" title="HTTPS 与网络安全"></a>HTTPS 与网络安全</h3><p>HTTPS 都使用了那些加密手段，为什么？</p><ul><li>建立链接过程使用非对称加密，因为耗时</li><li>后续通信数据传输过程中使用对称性加密</li></ul><p>对称性加密 </p><h3 id="TCP：-传输控制协议"><a href="#TCP：-传输控制协议" class="headerlink" title="TCP： 传输控制协议"></a>TCP： 传输控制协议</h3><ul><li>面向链接<br>  TCP 是全双工的所以数据传输之前需要三次握手，传输完毕需要四次挥手， </li><li><p>可靠传输</p><ul><li>无差错 </li><li>按序到达</li><li></li></ul></li><li><p>面向字节流</p><p>  发送方发送数据时不管一次性提交给TCP的缓冲是多大的数据，TCP本身会根据实际情况来划分数据包再发送给接受数据方</p></li><li><p>流量控制</p><p>  滑动窗口协议</p></li></ul><h3 id="UDP-：-用户数据协议"><a href="#UDP-：-用户数据协议" class="headerlink" title="UDP ： 用户数据协议"></a>UDP ： 用户数据协议</h3><ul><li><p>无连接<br>  发送数据时不需要建立链接，传输完毕也不需要释放链接</p></li><li><p>尽最大努力交付<br>  是不保证可靠传输的，</p></li><li><p>面向报文<br>  既不合并，也不拆分</p></li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h4 id="GET-和post-请求的区别"><a href="#GET-和post-请求的区别" class="headerlink" title="GET 和post 请求的区别"></a>GET 和post 请求的区别</h4><ul><li><p>GET 获取资源的</p><ul><li>安全的： 不因该引起Server 端的任何状态变化的</li><li>幂等的：同一个请求方法执行多次和执行一次的效果完全相同 </li><li>可缓存的：请求是可以缓存的，代理服务器可以缓存</li><li>请求参数以? 分割拼接到URL 后面</li></ul></li><li><p>post 请求处理资源</p><ul><li>不安全的： </li><li>非幂等的</li><li>不可缓存的</li></ul></li></ul><p>GET 请求参数有长度限制，是2048 个字符，post 一般没有限制</p><h4 id="HTTPS-链接建立流程"><a href="#HTTPS-链接建立流程" class="headerlink" title="HTTPS 链接建立流程"></a>HTTPS 链接建立流程</h4><p>客户端会发送服务端一个支持的加密算法列表<br>包括 TLS 的版本号 +  随机数C，<br>服务端再回给客户端一个证书<br>包括  商定的加密算法 后续首先通过非对称加密进行对称性加密的密钥传输，http的网络就通过被非对称密钥保护的对称密钥访问和传输数据</p><h3 id="TCP-和-UDP的区别"><a href="#TCP-和-UDP的区别" class="headerlink" title="TCP 和 UDP的区别"></a>TCP 和 UDP的区别</h3><p>tcp是面向链接的，并且支持可靠的传输，支持面向字节流， tcp 提供了流浪上的控制和拥塞的控制<br>UDP 提供了简单的复用/分用及差错检测的传输层的功能，</p><h4 id="状态吗有哪些"><a href="#状态吗有哪些" class="headerlink" title="状态吗有哪些"></a>状态吗有哪些</h4><ul><li>1XX</li><li>2XX：成功</li><li>3XX：重定向</li><li>4XX：客户端请求错误</li><li>5XX： 服务器端请求错误</li></ul><h4 id="为什么需要三次握手，两次行不行？"><a href="#为什么需要三次握手，两次行不行？" class="headerlink" title="为什么需要三次握手，两次行不行？"></a>为什么需要三次握手，两次行不行？</h4><p>解决同步请求链接建立时超时的情况，如果只有两次握手，</p><h4 id="持久链接怎么判断一个请求是否结束"><a href="#持久链接怎么判断一个请求是否结束" class="headerlink" title="持久链接怎么判断一个请求是否结束"></a>持久链接怎么判断一个请求是否结束</h4><ul><li>请求/响应报文的头部字段</li></ul><p>响应报文 content-length: 1024 头部字段是由server 端返回数据大小，客户端根据所接收的数据的字节数是否达到了头部字段 cotent-length 的大小判断</p><ul><li>通过post请求时server 端返回数据有可能需要多次响应才能返回，此时需要根据chunked 字段名 是否为空来判断</li></ul><h4 id="Charels-抓包原理是什么？"><a href="#Charels-抓包原理是什么？" class="headerlink" title="Charels 抓包原理是什么？"></a>Charels 抓包原理是什么？</h4><p>中间人攻击</p><p>正常步骤是 客户端 —- server</p><p>抓包：发送请求和响应请求都可以通过中间人修改再返回给某一端</p><p>客户端 —中间人—-  server</p><h4 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h4><p>域名到IP地址的映射，DNS解析请求采用UDP数据报，且明文</p><h4 id="NDS-解析存在的常见问题"><a href="#NDS-解析存在的常见问题" class="headerlink" title="NDS 解析存在的常见问题"></a>NDS 解析存在的常见问题</h4><ul><li>DNS 劫持问题<br>  钓鱼网站</li><li>DNS 解析转发问题</li></ul><h4 id="DNS-劫持和HTTP-的关系时怎么样的"><a href="#DNS-劫持和HTTP-的关系时怎么样的" class="headerlink" title="DNS 劫持和HTTP 的关系时怎么样的"></a>DNS 劫持和HTTP 的关系时怎么样的</h4><p>没有关系，</p><ul><li>DNS 解析发在HTTP 建立连接之前</li><li>DNS 解析请求使用UDP数据报， 端口是53，跟HTTP没有任何关系</li></ul><p>解决DNS 劫持问题</p><ul><li>httpDNS</li><li>长连接</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第十一章 设计模式</p><h2 id="六大设计原则"><a href="#六大设计原则" class="headerlink" title="六大设计原则"></a>六大设计原则</h2><p>单一职责原则：一个类只负责一件事</p><p>开闭原则： 对修改关闭，对扩展开放</p><p>接口隔离原则：使用多个专门的协议，而不是一个庞大臃肿的协议，iOS系统的UITableView的数据和代理协议分开</p><p>依赖倒置原则：抽象不应该依赖于具体实现，具体实现可以依赖于抽象</p><p>里氏替换原则：父类可以被子类无缝替换，且原有功能不受任何影响，iOS系统 的 KVO 机制遵守了这一原则，当调用 addObserver 方法时，因为系统在动态运行时为我们创建了一个子类，直观感受是仍然使用的是父类，实际上系统已经替换为创建的子类，所以KVO 机制 不但使用了管擦这模式，并且遵从了 里氏替换原则</p><p>迪米特法则： 一个对象应对其他对象有尽可能少的了解，平时所说的高内聚，低耦合</p><h2 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h2><h3 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h3><p>有三个业务分别为A/B/C，以前的调用顺序为 A -&gt; B -&gt; C ，现在顺序有调整，</p><p>定义某一个类，有一个成员变量他的类型跟原有类类型一致，组成一个责任链，让处理具体业务的责任者去处理</p><p><img src="https://i.loli.net/2019/04/18/5cb85694cd028.jpg" alt></p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>业务解耦的问题：同一个列表和多套数据显示，多套数据通过后端来控制是共存，</p><p><img src="https://i.loli.net/2019/04/18/5cb857a83803d.jpg" alt></p><p>类构成</p><p>抽象类A ——&gt; class B </p><p><img src="https://i.loli.net/2019/04/18/5cb85da6d46b6.jpg" alt></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>一个现有类需要适应变化的问题， 年代比较久远的类或者对象</p><p>类构成<br><img src="https://i.loli.net/2019/04/18/5cb8600aa067b.jpg" alt></p><ul><li>对象适配</li><li>类适配</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>行为参数化</p><p>降低代码重合度</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%E6%9E%B6%E6%9E%84%E5%92%8C%E6%A1%86%E6%9E%B6%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第十二章 架构和框架</p><p>目的</p><ul><li>实现模块化</li><li>分层</li><li>解耦</li></ul><h2 id="图片缓存"><a href="#图片缓存" class="headerlink" title="图片缓存"></a>图片缓存</h2><h3 id="图片缓存框架设计方案？"><a href="#图片缓存框架设计方案？" class="headerlink" title="图片缓存框架设计方案？"></a>图片缓存框架设计方案？</h3><p><img src="https://i.loli.net/2019/04/18/5cb8873419c28.jpg" alt></p><h3 id="图片缓存时内存设计上需要考虑的问题"><a href="#图片缓存时内存设计上需要考虑的问题" class="headerlink" title="图片缓存时内存设计上需要考虑的问题"></a>图片缓存时内存设计上需要考虑的问题</h3><ul><li><p>内存存储的size</p><ul><li>10kb的图片开辟的内存空间 50 张</li><li>100kb图片的 20 张</li><li>100kb 以上的 10 张<br>通过队列的方式存储，先进先出的方式淘汰</li></ul></li><li><p>淘汰策略</p><ul><li>以队列先进先出的方式淘汰</li><li>已LRU 算法 (如 30 min 之内是否使用过)</li></ul></li></ul><h3 id="磁盘设计考虑的问题"><a href="#磁盘设计考虑的问题" class="headerlink" title="磁盘设计考虑的问题"></a>磁盘设计考虑的问题</h3><ul><li>存储方式</li><li>大小限制</li><li>淘汰策略(超过 7 天)</li></ul><h3 id="网络部分的设计需要考虑的问题"><a href="#网络部分的设计需要考虑的问题" class="headerlink" title="网络部分的设计需要考虑的问题"></a>网络部分的设计需要考虑的问题</h3><ul><li>图片请求最大并发量</li><li>请求超时策略，一旦超时了，可以重试，如果重试2次失败，是否还下载</li><li>请求优先级，下载或者缓存的图片是否紧急需要</li></ul><h3 id="图片通过什么方式进行读写，过程是怎样的？"><a href="#图片通过什么方式进行读写，过程是怎样的？" class="headerlink" title="图片通过什么方式进行读写，过程是怎样的？"></a>图片通过什么方式进行读写，过程是怎样的？</h3><ul><li>以图片的url 的单向哈希值作为key 存储</li><li>读取过程</li></ul><p><img src="https://i.loli.net/2019/04/18/5cb887ab505f3.jpg" alt></p><h3 id="图片解码"><a href="#图片解码" class="headerlink" title="图片解码"></a>图片解码</h3><ul><li><p>对于不同格式的图片，解码采用什么方式来做？</p><ul><li>应用策略模式对于不同图片格式进行解码</li></ul></li><li><p>在那个阶段做图片解码处理？</p><ul><li>再磁盘读取后未解码或者网络请求返回后，解码后再放到内存中，可以减轻主线程的压力，解码在主线程中</li></ul></li></ul><h3 id="线程处理"><a href="#线程处理" class="headerlink" title="线程处理"></a>线程处理</h3><p> <img src="https://i.loli.net/2019/04/18/5cb8903ae7004.jpg" alt></p><h2 id="阅读时长统计"><a href="#阅读时长统计" class="headerlink" title="阅读时长统计"></a>阅读时长统计</h2><h3 id="怎样设计一个时长统计框架？"><a href="#怎样设计一个时长统计框架？" class="headerlink" title="怎样设计一个时长统计框架？"></a>怎样设计一个时长统计框架？</h3><p><img src="https://i.loli.net/2019/04/18/5cb8915823482.jpg" alt></p><h3 id="为何要有不同类型的记录器，处于什么考虑？"><a href="#为何要有不同类型的记录器，处于什么考虑？" class="headerlink" title="为何要有不同类型的记录器，处于什么考虑？"></a>为何要有不同类型的记录器，处于什么考虑？</h3><p>基于不同分类场景提供的关于记录的封装、适配</p><h3 id="记录的数据由于程序杀死或者断电，关机等丢失，你是怎样处理的？"><a href="#记录的数据由于程序杀死或者断电，关机等丢失，你是怎样处理的？" class="headerlink" title="记录的数据由于程序杀死或者断电，关机等丢失，你是怎样处理的？"></a>记录的数据由于程序杀死或者断电，关机等丢失，你是怎样处理的？</h3><ul><li>定时写磁盘</li><li>限定内存缓存条数，超过该条数就写如磁盘</li></ul><h3 id="记录器上传-中延时上传的具体场景有哪些？上传时机如何把握？"><a href="#记录器上传-中延时上传的具体场景有哪些？上传时机如何把握？" class="headerlink" title="记录器上传 中延时上传的具体场景有哪些？上传时机如何把握？"></a>记录器上传 中延时上传的具体场景有哪些？上传时机如何把握？</h3><p>上传时机</p><ul><li>立刻上传</li><li>延时上传</li><li>定时上传</li></ul><p>延时上传场景</p><p>统计结果立即上传会重复调用接口导致资源浪费</p><ul><li>前后台切换</li><li>从无网到有网的变化时</li><li>通过其他的接口捎带着上传</li></ul><h2 id="复杂页面的架构"><a href="#复杂页面的架构" class="headerlink" title="复杂页面的架构"></a>复杂页面的架构</h2><h3 id="MVVM-框架思想"><a href="#MVVM-框架思想" class="headerlink" title="MVVM 框架思想"></a>MVVM 框架思想</h3><p><img src="https://i.loli.net/2019/04/18/5cb894992c97c.jpg" alt></p><h3 id="RN-的数据流思想"><a href="#RN-的数据流思想" class="headerlink" title="RN 的数据流思想"></a>RN 的数据流思想</h3><p><img src="https://i.loli.net/2019/04/18/5cb895a29c8e3.jpg" alt></p><p>任何一个子节点是没有权力做自己的变化更新的，它必须把这个消息传递给根结点，根结点通过自顶向下的遍历查找需要更新的节点</p><h3 id="系统UIView-更新机制的思想"><a href="#系统UIView-更新机制的思想" class="headerlink" title="系统UIView 更新机制的思想"></a>系统UIView 更新机制的思想</h3><h3 id="AsyncDisplayKit-关于预排版的设计思想"><a href="#AsyncDisplayKit-关于预排版的设计思想" class="headerlink" title="AsyncDisplayKit 关于预排版的设计思想"></a>AsyncDisplayKit 关于预排版的设计思想</h3><h2 id="客户端整体架构"><a href="#客户端整体架构" class="headerlink" title="客户端整体架构"></a>客户端整体架构</h2><p>需要独立于APP 的通用层<br>通用的业务层<br>中间层<br>业务层</p><p><img src="https://i.loli.net/2019/04/18/5cb8962545202.jpg" alt></p><p>业务之间的解耦通信方式</p><ul><li>OpenURL</li><li>依赖注入方式， 在中间层通过代理 的方式实现业务A 和业务B之间的通信</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第十三章算法</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%85%AB%E7%AB%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第三章多线程面试</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="https://ws2.sinaimg.cn/large/006tKfTcly1g1mabhcs20j31cb0u0n2p.jpg" alt></p><ul><li>stack 栈是从高地址向低地址扩展，所以栈是向下增长的，对象和block copy 后都会放在堆上</li><li>heap 堆区向上增长</li></ul><ul><li><p>散列表方式</p><ul><li>自旋锁<ul><li>自旋锁是“忙等” 的锁</li></ul></li><li>引用计数表</li><li>弱应用表</li></ul></li></ul><h2 id="内存管理方案"><a href="#内存管理方案" class="headerlink" title="内存管理方案"></a>内存管理方案</h2><ul><li>小对象使用 TaggedPointer </li><li>64 位架构下面使用的是 NONPONINT_ISA 内存管理方案，非指针型的 isa，内部存储了一些 </li><li>散列表结构 （Side Tables() 结构）<ul><li>自旋锁</li><li>引用计数表</li><li>弱引用表</li><li>Side Tables() 结构</li></ul></li></ul><h3 id="为什么不是一个SideTable，而是多个组成了Side-Tables"><a href="#为什么不是一个SideTable，而是多个组成了Side-Tables" class="headerlink" title="为什么不是一个SideTable，而是多个组成了Side Tables"></a>为什么不是一个SideTable，而是多个组成了Side Tables</h3><p>如果所有对象的存储都放在一张大表当中，因为每个对象是在不同的线程中创建的，要操作其中一个对象时，需要将表加锁处理保证数据安全，要等锁释放之后才能操作下一个对象，此时存在效率问题，引入分离锁技术方案</p><ul><li>分离锁：把引用计数表分成多张表进行，</li><li>Side Tables 本质是一张Hash 表</li></ul><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1wp3j6obfj310u07g0tn.jpg" alt></p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>是“忙等”的锁，如果当前锁已被其他线程获取，当前线程会不断探测是否被释放，会第一时间获取，而其他锁比如信号量当它获取不到锁时，会把自己的线程阻塞休眠，等到其他线程释放这个锁时再唤醒这个锁</p><ul><li>适用于轻量访问</li></ul><h3 id="引用计数表"><a href="#引用计数表" class="headerlink" title="引用计数表"></a>引用计数表</h3><p>使用过Hash表来实现，hash查找提高了查找高效率，插入和获取是通过Hash 算法来是实现的，避免了for循环</p><h4 id="alloc-实现"><a href="#alloc-实现" class="headerlink" title="alloc 实现"></a>alloc 实现</h4><p>经过一系列调用，最终调用了C函数 calloc， 并没有引用计数+1</p><h4 id="retain-实现"><a href="#retain-实现" class="headerlink" title="retain 实现"></a>retain 实现</h4><p>底层经过了2次Hash表查找 </p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1wq0qej61j31kg0dmtca.jpg" alt></p><h4 id="release-实现"><a href="#release-实现" class="headerlink" title="release 实现"></a>release 实现</h4><p>和 retain 实现相反</p><h4 id="dealloc-实现原理"><a href="#dealloc-实现原理" class="headerlink" title="dealloc 实现原理"></a>dealloc 实现原理</h4><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1wqa1mub5j31df0u0gqo.jpg" alt></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1wqvau8guj316u0rwmz9.jpg" alt></p><h4 id="objc-destructInstance-实现"><a href="#objc-destructInstance-实现" class="headerlink" title="objc_destructInstance() 实现"></a>objc_destructInstance() 实现</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1wqvfecquj315t0u0n1e.jpg" alt></p><h4 id="clearDeallocating-实现"><a href="#clearDeallocating-实现" class="headerlink" title="clearDeallocating() 实现"></a>clearDeallocating() 实现</h4><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1wqvivtonj31la0tqdke.jpg" alt></p><h4 id="MRC"><a href="#MRC" class="headerlink" title="MRC"></a>MRC</h4><p>手动引用计数 </p><h4 id="ARC"><a href="#ARC" class="headerlink" title="ARC"></a>ARC</h4><ul><li><p>编译器在对应位置自动插入retain 和 release 操作，并和runtime协作达到自动引用计数管理内存的效果</p></li><li><p>ARC 中禁止手动调用  retain/release </p></li><li>ARC 中新增 weeak、strong 等关键字</li></ul><h3 id="弱引用管理"><a href="#弱引用管理" class="headerlink" title="弱引用管理"></a>弱引用管理</h3><p>被声明为__weak 的对象指针经过编译后会进过调用以下方法，在最终的weak_register_no_lock() 方法中进行弱引用变量的添加。添加的位置是通过Hash算法查找的</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1wr6cz3ctj31ac0hijtf.jpg" alt>  </p><h3 id="weak-修饰的对象，释放时置为nil-如何实现的"><a href="#weak-修饰的对象，释放时置为nil-如何实现的" class="headerlink" title="weak 修饰的对象，释放时置为nil 如何实现的"></a>weak 修饰的对象，释放时置为nil 如何实现的</h3><p>当一个对象被 dealloc 之后，在dealloc内部实现当中会调用弱引用清除的相关函数，在相关函数当中会根据当前对象指针查找弱引用表，把当前对象下对应的弱应用都取出，遍历弱应用指针并置为nil。</p><h3 id="自动释放池"><a href="#自动释放池" class="headerlink" title="自动释放池"></a>自动释放池</h3><p>是以栈为结点通过双向链表的形式组合而成，和线程一一对应</p><p>Autoreleasepool </p><h2 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h2><h3 id="自循环引用"><a href="#自循环引用" class="headerlink" title="自循环引用"></a>自循环引用</h3><p>一个对象中有拥有一个 强持有他的 obj，如果给 obj 赋值为原对象就会造成自循环引用</p><h3 id="相互循环引用"><a href="#相互循环引用" class="headerlink" title="相互循环引用"></a>相互循环引用</h3><ul><li>代理</li><li>Block</li><li>NSTimer</li><li>大环多循环</li></ul><h3 id="多循环引用"><a href="#多循环引用" class="headerlink" title="多循环引用"></a>多循环引用</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1ws3as0wdj31sa0rwae5.jpg" alt></p><h2 id="解决循环引用的方案"><a href="#解决循环引用的方案" class="headerlink" title="解决循环引用的方案"></a>解决循环引用的方案</h2><h3 id="weak"><a href="#weak" class="headerlink" title="__weak"></a>__weak</h3><p>解决相互循环引用</p><h3 id="block"><a href="#block" class="headerlink" title="__block"></a>__block</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1wscj9qnij320o09igq4.jpg" alt></p><h3 id="unsafe-unretained"><a href="#unsafe-unretained" class="headerlink" title="__unsafe_unretained"></a>__unsafe_unretained</h3><p>一般不建议使用</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1wsdln9jrj31iq0a041v.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E4%BA%94%E7%AB%A0Runtime%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E4%BA%94%E7%AB%A0Runtime%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Runtime-相关问题"><a href="#Runtime-相关问题" class="headerlink" title="Runtime 相关问题"></a>Runtime 相关问题</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="objc-object-结构体"><a href="#objc-object-结构体" class="headerlink" title="objc_object 结构体"></a>objc_object 结构体</h3><h3 id="objc-class"><a href="#objc-class" class="headerlink" title="objc_class"></a>objc_class</h3><h4 id="对象、类对象、元类对象的区别"><a href="#对象、类对象、元类对象的区别" class="headerlink" title="对象、类对象、元类对象的区别"></a>对象、类对象、元类对象的区别</h4><ul><li>类对象存储实例方法列表等信息</li><li>元类对象存锤类方法列表等信息</li></ul><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p><code>void objc_msgSend(void /* id self, SEL op, ... */)</code></p><p>经过编译器转变后<br><code>[self class]</code> &lt;==&gt;  <code>objc_msgSend(self, @selector(class))</code><br>第一个参数是消息传递的接收者self, 第二个参数是传递的消息名称（选择器）</p><p><code>void objc_msgSendSuper(void /* struct objc_super *super, SEL op, ... */)</code><br>第一个参数是一个结构体指针</p><p>//<br>struuch objc_super {<br>    __unsafe_unretained id receiver; // 就是当前的对象<br>}</p><p><code>[superclass]</code> &lt;==&gt;  <code>objc_msgSendSuper(super, @selector(class))</code></p><p>无论调用[super class] 还是 [self class] 最终这条消息的接收者都是当前对象</p><p>图1</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1viq97z3cj31k90u0qd3.jpg" alt></p><h2 id="消息传递过程"><a href="#消息传递过程" class="headerlink" title="消息传递过程"></a>消息传递过程</h2><p>图2</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1vigugmvmj31qu0u07a4.jpg" alt></p><p>问题1</p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1vikx3a6wj31hp0u0dmw.jpg" alt></p><p><code>打印结果都是 Phone</code></p><p>原因:</p><ul><li>无论调用[super class] 还是 [self class] 最终这条消息的接收者都是当前对象</li><li>[self class] 在Phone的类对象中查找class 方法，没有去父类查找，父类也没有，如图1顺次往上查找到根类，调用根类中class 的具体实现</li><li>[super class]只是跨越了当前类，直接从当前类的父类中查找 class 方法，父类中没有class 方法，如图1所示只能继续往上查找到根类对象，在NSObject 中有class 方法实现，所以接受者任然是当前的对象</li></ul><h3 id="缓存查找"><a href="#缓存查找" class="headerlink" title="缓存查找"></a>缓存查找</h3><p>根据给定的SEL（方法选择器）通过一个函数来映射出bucket_t 在数组当中的位置，本质上是哈希查找</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1vj2xha6gj318i0jc76s.jpg" alt></p><h3 id="当前类中查找"><a href="#当前类中查找" class="headerlink" title="当前类中查找"></a>当前类中查找</h3><p>当前类中存在着对应的方法列表</p><ul><li>对于已经排序好的列表，采用二分查找算法查找对应的执行函数</li><li>对于没有排序的列表，采用一般遍历查找方法查找对应的执行函数</li></ul><h3 id="父类逐级查找"><a href="#父类逐级查找" class="headerlink" title="父类逐级查找"></a>父类逐级查找</h3><p>图3<br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1vkkjffglj31xm0ssgpn.jpg" alt></p><ul><li>最关键是通过当前类的 superclass 成员变量去查找父类，或者访问父类</li><li>curClass 的父类是否为 nil？如果是NSObject 类，他的父类为空，所以会结束查找</li><li>如果当前类有父类就要去该父类的缓存中查找，如果在缓存中命中，那么就结束查找，如果缓存中没有，就需要遍历当前类的父类的方法列表，如果没有就遍历父类的父类查找，沿着superclass指针逐级向上查找，直到查找到NSObject，再去Superclass。如果还是没有为nil时就结束父类逐级查找</li></ul><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><h3 id="resolveInstanceMethod"><a href="#resolveInstanceMethod" class="headerlink" title="resolveInstanceMethod:"></a>resolveInstanceMethod:</h3><ul><li>该方法是类方法不是实例方法，参数是SEL 方法选择器类型</li><li>返回值是一个BOOL值</li><li>告诉系统是否要解决当前实例方法的实现</li><li>如果返回YES，结束消息转发</li><li>如果返回NO，系统会给第二次机会处理这个消息，会回掉forwardingTargetForSelector:</li></ul><h3 id="forwardingTargetForSelector："><a href="#forwardingTargetForSelector：" class="headerlink" title="forwardingTargetForSelector："></a>forwardingTargetForSelector：</h3><ul><li>参数是 SEL 方法选择器</li><li>返回值是 id 类型，说明有哪个对象来处理，转发的对象是谁，如果返回了转发目标就会结束当前调用</li><li>如果返回为nil，系统会调用 methodSignatureForSelector:方法，最后一次机会处理这个消息</li></ul><h3 id="methodSignatureForSelector："><a href="#methodSignatureForSelector：" class="headerlink" title="methodSignatureForSelector："></a>methodSignatureForSelector：</h3><ul><li>参数是 SEL 方法选择器</li><li>返回值是一个对象，实际上这个对象是对<code>methodSignatureForSelector</code> 方法的参数，参数个数，参数类型和返回值的包装</li><li>如果返回一个方法签名的话，就会调用 forwardInvocation: 方法</li><li>如果返回为nil，标记为消息无法处理，程序crash</li></ul><h3 id="forwardInvocation："><a href="#forwardInvocation：" class="headerlink" title="forwardInvocation："></a>forwardInvocation：</h3><ul><li>如果此方法不能处理消息，程序crash</li></ul><p>代码示例</p><p>.h 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface RunTimeObject : NSObject</span><br><span class="line">// 只声明，不实现，验证消息转发机制</span><br><span class="line">- (void)test;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>.m 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">@implementation RunTimeObject</span><br><span class="line"></span><br><span class="line">// 实现消息转发流程 中的方法</span><br><span class="line">/**</span><br><span class="line"> 是否要解决当前实例方法的实现</span><br><span class="line"> */</span><br><span class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">    if (sel == @selector(test)) &#123;</span><br><span class="line">        NSLog(@&quot;resolveInstanceMethod:&quot;);</span><br><span class="line">        // 如果返回YES，消息转发就会结束</span><br><span class="line">//        return YES;</span><br><span class="line">        </span><br><span class="line">        return NO;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;super resolveInstanceMethod:&quot;);</span><br><span class="line">        // 返回父类的默认调用</span><br><span class="line">        return [super resolveInstanceMethod:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> - 参数是 SEL 方法选择器</span><br><span class="line"> - 返回值是 id 类型，说明有哪个对象来处理，转发的对象是谁，如果返回了转发目标就会结束当前调用</span><br><span class="line"> - 如果返回为nil，系统会调用 methodSignatureForSelector:方法，最后一次机会处理这个消息</span><br><span class="line"> */</span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    NSLog(@&quot; forwardingTargetForSelector: &quot;);</span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> - 参数是 SEL 方法选择器</span><br><span class="line"> - 返回值是一个对象，实际上这个对象是对`methodSignatureForSelector` 方法的参数，参数个数，参数类型和返回值的包装</span><br><span class="line"> - 如果返回一个方法签名的话，就会调用 forwardInvocation: 方法</span><br><span class="line"> - 如果返回为nil，标记为消息无法处理，程序crash</span><br><span class="line"> </span><br><span class="line"> */</span><br><span class="line">- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">    if (aSelector == @selector(test)) &#123;</span><br><span class="line">        NSLog(@&quot;methodSignatureForSelector:&quot;);</span><br><span class="line">        /**</span><br><span class="line">         v: 表示这个方法返回值是 void</span><br><span class="line">         </span><br><span class="line">         固定参数@: 表示参数类型是 id, 即self</span><br><span class="line">         固定参数`:` : 表示参数类型是选择器类型，即 @selector(test)</span><br><span class="line">         */</span><br><span class="line">        return [NSMethodSignature signatureWithObjCTypes:&quot;v@:&quot;];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;super methodSignatureForSelector:&quot;);</span><br><span class="line">        // 返回父类的默认调用</span><br><span class="line">        return [super methodSignatureForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)forwardInvocation:(NSInvocation *)anInvocation &#123;</span><br><span class="line">    NSLog(@&quot;forwardInvocation:&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>调用 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)runTiemTest &#123;</span><br><span class="line">    RunTimeObject *obj = [[RunTimeObject alloc] init];</span><br><span class="line">    [obj test];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">resolveInstanceMethod:</span><br><span class="line">forwardingTargetForSelector:</span><br><span class="line">methodSignatureForSelector:</span><br><span class="line">super resolveInstanceMethod:</span><br><span class="line">forwardInvocation:</span><br></pre></td></tr></table></figure><h2 id="为类动态添加方法"><a href="#为类动态添加方法" class="headerlink" title="为类动态添加方法"></a>为类动态添加方法</h2><p>methond Swizzling</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>页面中的进出添加统计信息，使用 methond Swizzling 替换viewillAppear 方法</li></ul><h3 id="动态添加方法"><a href="#动态添加方法" class="headerlink" title="动态添加方法"></a>动态添加方法</h3><ul><li>perforSelector: 实际上是考察class_addMethod 的方法使用</li></ul><h3 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h3><ul><li>@dynamic关键字</li><li>动态运行时语言将函数决议推迟到运行时</li><li>编译时不生成setter/getter 方法，而是在运行时才添加具体的执行函数</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="obj-foo-和-obj-msgSend-函数之间有什么关系？"><a href="#obj-foo-和-obj-msgSend-函数之间有什么关系？" class="headerlink" title="[obj foo] 和 obj_msgSend()函数之间有什么关系？"></a>[obj foo] 和 obj_msgSend()函数之间有什么关系？</h3><ul><li><code>[obj foo]</code>经过编译器处理过后会变成 <code>obj_msgSend()</code>有两个参数，一个是obj，第二个参数是foo 选择器</li></ul><h3 id="runtime-如何通过Selector找到对应的IMP地址的？"><a href="#runtime-如何通过Selector找到对应的IMP地址的？" class="headerlink" title="runtime 如何通过Selector找到对应的IMP地址的？"></a>runtime 如何通过Selector找到对应的IMP地址的？</h3><p>消息传递机制</p><h3 id="能否向编译后的类增加实例变量"><a href="#能否向编译后的类增加实例变量" class="headerlink" title="能否向编译后的类增加实例变量"></a>能否向编译后的类增加实例变量</h3><p>编译之前就完成了实例变量的布局，<br>runtime_r_t 表示是readonly 的，编译后的类是不能添加实例变量的，可以向动态添加的类中添加实例变量</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E4%B9%9D%E7%AB%A0Runloop%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E4%B9%9D%E7%AB%A0Runloop%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>RunLop</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g21ckps89dj31vy03cq56.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E4%B8%83%E7%AB%A0Blocks%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E4%B8%83%E7%AB%A0Blocks%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h1><h2 id="Block-是什么？"><a href="#Block-是什么？" class="headerlink" title="Block 是什么？"></a>Block 是什么？</h2><p>Blocks 是 C 语言的扩充功能，将函数及其执行上下文封装起来的对象，带有自动变量（局部变量）的匿名函数</p><ul><li>因为block 底层C++ 结构体中存在着 isa 指针，所以是一个对象</li><li>因为block 底层C++ 结构体中存在着一个函数指针 FuncPtr，所以是一个函数</li></ul><h2 id="什么是Block-调用"><a href="#什么是Block-调用" class="headerlink" title="什么是Block 调用"></a>什么是Block 调用</h2><p>Block 的调用就是函数的调用<br>在终端使用 clang 编译之后查看文件内容可得出以下结论：</p><ul><li>对其进行一个强制转换，转换之后取出成员变量 FuncPtr</li></ul><h2 id="截获变量"><a href="#截获变量" class="headerlink" title="截获变量"></a>截获变量</h2><p><strong>以下代码运行结果是 12</strong></p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xvmfjgo8j30uu0jmgnl.jpg" alt></p><pre><code>原因：block 对基本数据类型的局部变量会截获其值，在定义 block 时以值的方式传到了block 对应的结构体当中，而调用block 时直接使用的是block对应结构体当中已经传过来的那个值，所以值为12</code></pre><ul><li><p>局部变量截获</p><ul><li>基本数据类型的局部变量截获其值</li><li>对象类型的局部变量连同所有权修饰符一起截获</li></ul></li><li><p>局部静态变量： 已指针形式截获</p></li><li><p>全局变量：不截获</p></li><li><p>静态全局变量： 不截获</p></li></ul><p><strong>以下代码运行结果是 8</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1xwb9qt9oj30n60bq75i.jpg" alt></p><pre><code>原因：block 对局部静态变量会以指针形式截获，所以值为8</code></pre><h2 id="block-修饰符"><a href="#block-修饰符" class="headerlink" title="__block 修饰符"></a>__block 修饰符</h2><ul><li>__block 修饰后的变量最后变成了对象，底层c++ 结构体中存在isa指针</li><li>一般情况下，对被截获变量进行赋值操作需要添加<strong>block 修饰符，而操作是不需要添加</strong>block 修饰符的</li><li>不需要__block 修饰符，全局变量和静态全局变量 block 是不截获的，所以不需要修饰，静态局部变量是通过指针截获的，修改外部的变量，也不需要添加<ul><li>静态局部变量</li><li>全局变量</li><li>静态全局变量</li></ul></li></ul><p><strong>不需要添加__Block 修饰符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    NSMutableArray *array = [NSMutableArray array];</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        [array addObject:@1234];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>需要添加__Block 修饰符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)test &#123;</span><br><span class="line">    __block NSMutableArray *tempArray = nil;</span><br><span class="line">    void(^block)(void) = ^&#123;</span><br><span class="line">        tempArray = [NSMutableArray array];</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以下代码运行结果是 8</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)test__Block3 &#123;</span><br><span class="line">    __block int multiplier = 6;</span><br><span class="line">    int(^Block)(int) = ^int(int num)&#123;</span><br><span class="line">        return multiplier * num;</span><br><span class="line">    &#125;;</span><br><span class="line">    multiplier = 4;</span><br><span class="line">    NSLog(@&quot;__block--test__Block3---result is %d&quot;, Block(2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原因</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79ly1g1xxea9gckj31hi0l2ju3.jpg" alt></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1xxfpnz45j30zm0lstad.jpg" alt></p><p><strong>栈上Block 的<strong>block 变量中的 </strong>forwarding 指针指向的是自身</strong></p><h2 id="Block-的内存管理"><a href="#Block-的内存管理" class="headerlink" title="Block 的内存管理"></a>Block 的内存管理</h2><p><strong>Block 的 内存分布</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1xxnyye6kj31ag0ran0f.jpg" alt></p><p><strong>Block 的 Copy 操作</strong></p><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1xxouef30j315a0d640x.jpg" alt></p><ul><li>全局block</li><li>堆block</li><li>栈block</li></ul><h2 id="Block-循环引用"><a href="#Block-循环引用" class="headerlink" title="Block 循环引用"></a>Block 循环引用</h2><ul><li>如果当前block对当前对象的某一变量进行截获的话，block 会对对应变量有一个强引用，当前block因为当前的对象对其有个强引用，产生了自循环引用，通过声明为__weak变量来解决</li><li>如果定义了__block 修饰符的话也会产生循环引用，在ARC 下会产生循环引用，而在MRC 下不会，在ARC 下通过打破环来消除，但是存在弊端时当block 没有机会执行时，</li></ul><p>循环引用1<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1xzmtsetqj31g20oewic.jpg" alt></p><p>解决方法：</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1xzmtsetqj31g20oewic.jpg" alt></p><p>大环循环引用2 </p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1xzqfwf1uj319c0la0vk.jpg" alt></p><p>以上代码，在MRC 下，不会产生循环引用，在ARC 下，会产生循环应用，引起内存泄露<br><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1xzvs524zj31h80l20uo.jpg" alt></p><p>解决方法</p><p>如果block 没有机会执行，那么循环引用将不会被打破<br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1xzxf0iyxj31hp0u0aeq.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E7%AC%AC%E4%B8%89%E7%AB%A0UI%E8%A7%86%E5%9B%BE%E5%93%8D%E5%BA%94%E9%93%BE%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E9%9D%A2%E8%AF%95/"/>
      <url>/2019/06/18/%E7%AC%AC%E4%B8%89%E7%AB%A0UI%E8%A7%86%E5%9B%BE%E5%93%8D%E5%BA%94%E9%93%BE%E7%A6%BB%E5%B1%8F%E6%B8%B2%E6%9F%93%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="UITableView-相关"><a href="#UITableView-相关" class="headerlink" title="UITableView 相关"></a>UITableView 相关</h2><ul><li>重用机制</li><li><p>并发访问，数据拷贝问题：主线程删除了一条数据，子线程数据由删除之前的数据源copy而来，子线程网络请求，数据解析，预排版等操作后，回到主线程刷新时已经删除的数据又会重现</p><ul><li><p>主线程数据源删除时对数据进行记录，子线程的数据回来后再进行一次同步删除操作，然后再刷新数据</p></li><li><p>使用GCD中的串行队列，将数据删除和数据解析在此队列中进行</p></li></ul></li></ul><h2 id="UIView-和CALayer-的关系"><a href="#UIView-和CALayer-的关系" class="headerlink" title="UIView 和CALayer 的关系"></a>UIView 和CALayer 的关系</h2><ul><li>UIView 为 CALayer 提供内容，负责处理触摸事件，参与响应链</li><li>CALayer 负责显示内容，分工明确，UIView 的Layer 实际上就是CALayer， backgroundColor 等属性本质是对CALayer 做了一层包装</li></ul><h2 id="事件传递"><a href="#事件传递" class="headerlink" title="事件传递"></a>事件传递</h2><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1omq41fi4j31hn0u0n3a.jpg" alt></p><ul><li>hitTest 方法是返回响应时间的试图</li><li>pointInside withEvent 方法判断点击位置是否在当前视图范围内</li><li>倒序遍历最终响应事件的试图，最后添加的试图会最优先被遍历到</li></ul><p><strong>需求案例</strong></p><p>只让正方形的view中圆形区域内可以响应事件，四个角的位置不响应事件<br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1onklz0k8j309q0a674h.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class CircularAreaResponseButton: UIButton &#123;</span><br><span class="line">    </span><br><span class="line">    override func hitTest(_ point: CGPoint, with event: UIEvent?) -&gt; UIView? &#123;</span><br><span class="line">        if self.isHidden || !self.isUserInteractionEnabled ||  self.alpha &lt;= 0.01 &#123;</span><br><span class="line">            return nil</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        var hitView: UIView?</span><br><span class="line">        if self.point(inside: point, with: event) &#123;</span><br><span class="line">            // 遍历当前视图的子试图</span><br><span class="line">            for subView in subviews &#123;</span><br><span class="line">                // 坐标转换</span><br><span class="line">                let convertPoint = self.convert(point, to: subView)</span><br><span class="line">                if let hitTestView = subView.hitTest(convertPoint, with: event) &#123;</span><br><span class="line">                    // 找到了最终响应事件的试图</span><br><span class="line">                    hitView = hitTestView</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if hitView != nil &#123;</span><br><span class="line">                return hitView</span><br><span class="line">            &#125;</span><br><span class="line">            return self</span><br><span class="line">        &#125;</span><br><span class="line">        return nil</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    override func point(inside point: CGPoint, with event: UIEvent?) -&gt; Bool &#123;</span><br><span class="line">        let x1 = point.x</span><br><span class="line">        let y1 = point.y</span><br><span class="line">        </span><br><span class="line">        let x2 = self.frame.width / 2.0</span><br><span class="line">        let y2 = self.frame.height / 2.0</span><br><span class="line">        // 使用平面内两点见距离公式计算距离, 并且判断是否 &lt;= 圆的半径</span><br><span class="line">        return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)) &lt;= x2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视图响应"><a href="#视图响应" class="headerlink" title="视图响应"></a>视图响应</h2><p>UIView 都继承于 UIResponder，都有以下方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span><br><span class="line">func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) </span><br><span class="line">func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span><br><span class="line">func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span><br></pre></td></tr></table></figure><p>如果事件沿着视图响应链一直传递到 UIApplicationDelegate 仍然没有任何一个视图处理事件，程序将会发生什么？</p><ul><li>忽略掉了这个事件当作什么都没有发生</li></ul><h2 id="图像显示原理"><a href="#图像显示原理" class="headerlink" title="图像显示原理"></a>图像显示原理</h2><p>CALayer 的 contents 是位图</p><p><img src="https://ws1.sinaimg.cn/large/006tKfTcly1g1oqxcw9dvj32260n041w.jpg" alt></p><ul><li><p>CPU的工作</p><p>  Layout   | Display   | Prepare    | Commite |<br>  ———|———–|————|———|<br>  UI布局      | 绘制         | 图片编解码  | 提交位图 |<br>  文本计算  | </p></li><li><p>GPU渲染管线</p><p>  定点着色 | 图元转配 | 光栅化 | 片段着色 | 片段处理 |<br>  ——–|——–|——-|———|———|</p></li></ul><pre><code>提交到帧缓冲区（frameBuffer）</code></pre><h2 id="UI卡顿掉帧的原因"><a href="#UI卡顿掉帧的原因" class="headerlink" title="UI卡顿掉帧的原因"></a>UI卡顿掉帧的原因</h2><p>1/60 ms 时间内， 由cpu 和GPU 协同产生最终的数据，当 CPU UI布局，文本计算所用的时间较长时，留给GPU渲染，提交到帧缓冲区的时间就会变短，这样以来就会发生掉帧情况</p><h3 id="UIView-的绘制原理"><a href="#UIView-的绘制原理" class="headerlink" title="UIView 的绘制原理"></a>UIView 的绘制原理</h3><p><strong>CPU优化方案</strong></p><ul><li>对象的创建、调整、销毁放在子线程，节省cpu的一部分时间</li><li>预排版（布局计算，文本计算）放在子线程中</li><li>预渲染（文本等异步绘制，图片编解码）等</li></ul><p><strong>GPU优化方案</strong></p><h2 id="在屏渲染"><a href="#在屏渲染" class="headerlink" title="在屏渲染"></a>在屏渲染</h2><p>指GPU的渲染操作是在当前用于显示的屏幕缓冲区域中进行</p><h2 id="离屏渲染"><a href="#离屏渲染" class="headerlink" title="离屏渲染"></a>离屏渲染</h2><p>指GPU在当前屏幕缓冲区域外新开劈了一个缓冲区域进行渲染操作<br>指定了UI视图图层的某些属性，标记为视图在未预合成之前不能用于在当前屏幕上直接显示的时候就会发生离屏渲染，例如图层的圆角设置和蒙层设置</p><ul><li><p>离屏渲染何时触发</p><ul><li>设置layer 的圆角并且和 maskToBounds 一起使用时</li><li>图层蒙版</li><li>阴影</li><li>光栅化</li></ul></li><li><p>为何要避免离屏渲染</p><ul><li>离屏渲染，会增加 GPU 的工作量，GPU工作量的增加就很有可能导致CPU和GPU的总耗时超过1/60s，导致UI卡顿和掉帧 </li></ul></li><li><p>避免离屏渲染</p></li></ul><p>###异步绘制</p><p><img src="https://ws3.sinaimg.cn/large/006tKfTcly1g1osowi1dtj31l70u0ag5.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E4%B8%80%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/"/>
      <url>/2019/06/18/%E4%B8%80%E8%87%AA%E5%8A%A8%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>自动引用计数</p><h2 id="什么是自动引用计数"><a href="#什么是自动引用计数" class="headerlink" title="什么是自动引用计数"></a>什么是自动引用计数</h2><p>内存管理中对引用采取自动计数的技术</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li>自己生成的对象，自己所持有 <ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul></li><li>非自己生成的对象，自己也能持有 <ul><li>retain</li></ul></li><li>不再需要自己持有的对象时释放    <ul><li>release</li></ul></li><li><p>非自己持有的对象无法释放</p></li><li><p>废弃对象</p><ul><li>dealloc </li></ul></li></ul><h2 id="strong"><a href="#strong" class="headerlink" title="__strong"></a>__strong</h2><p>__strong 修饰符表示对对象的“强引用”</p><h3 id="unsafe-unretained-修饰符"><a href="#unsafe-unretained-修饰符" class="headerlink" title="__unsafe_unretained 修饰符"></a>__unsafe_unretained 修饰符</h3><p>__unsafe_unretained 是不安全的所有权修饰符， 被它修饰的变量不属于编译器的内存管理对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id __unsafe_unretained objc = [[NSObject alloc] init];</span><br></pre></td></tr></table></figure><p>Xcode 提示：<code>Assigning retained object to unsafe_unretained variable; object will be released after assignment</code></p><p>将保留对象赋给unsafe_unretain变量;对象将在赋值后释放</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">id __unsafe_unretained obj1 = nil;</span><br><span class="line">   </span><br><span class="line">   &#123;</span><br><span class="line">       id __unsafe_unretained obj = [[NSObject alloc] init];</span><br><span class="line">       </span><br><span class="line">       // 自己生成并持有对象</span><br><span class="line">       // 因为obj0 变量是__strong,强引用，所以自己持有对象</span><br><span class="line">       id __strong obj0 = [[NSObject alloc] init];</span><br><span class="line">       </span><br><span class="line">       // obj0 变量赋值给你obj1</span><br><span class="line">       // ojb1 变量不持有对象的强应用，也不持有弱引用</span><br><span class="line">       obj1 = obj0;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       // 输出 obj1 变量表示的对象</span><br><span class="line">       NSLog(@&quot;A: %@&quot;, obj1);</span><br><span class="line">   &#125; // obj0变量 超出了其作用域，强引用失效自动释放自己持有的对象，除此之外没有其他持有者，所以废弃该对象</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   // 输出 obj1 变量表示的对象</span><br><span class="line">   // obj1 变量表示的对象因为无持有者已经销毁，坏的内存访问</span><br><span class="line">   NSLog(@&quot;B: %@&quot;, obj1);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/is%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/"/>
      <url>/2019/06/18/is%20%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<p>swift类型检查和类型转换</p><h3 id="is-关键字类型检查"><a href="#is-关键字类型检查" class="headerlink" title="is 关键字类型检查"></a>is 关键字类型检查</h3><p>判断父类和子类之间的关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func typeCheck() &#123;</span><br><span class="line">    let programmer = Programmer(name: &quot;老张-php&quot;)</span><br><span class="line">    if dev is iOSDeveloper &#123;</span><br><span class="line">        print(&quot;iOS 开发者&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;其他开发者&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if programmer is Coder &#123;</span><br><span class="line">        print(&quot;老张-php是一农个码农&quot;)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        print(&quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="as-关键字类型转换"><a href="#as-关键字类型转换" class="headerlink" title="as 关键字类型转换"></a>as 关键字类型转换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let ios = iosDev as? Programmer</span><br><span class="line">let ios2 = iosDev as! Coder</span><br></pre></td></tr></table></figure><h3 id="判断是否遵守了协议"><a href="#判断是否遵守了协议" class="headerlink" title="判断是否遵守了协议"></a>判断是否遵守了协议</h3><p>swift 中协议可以当作是一个类型使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">et ios = iosDev as? Programmer</span><br><span class="line">    let ios2 = iosDev as Coder</span><br><span class="line">    </span><br><span class="line">    // 是否遵守了 Person 协议</span><br><span class="line">    if iosDev is Person &#123;</span><br><span class="line">        print(&quot;遵守了Person协议&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let devs = [dev, iosDev, programmer] as [Any]</span><br><span class="line">    </span><br><span class="line">    for dev in devs &#123;</span><br><span class="line">        if let dev = dev as? Person &#123;</span><br><span class="line">            print(dev)</span><br><span class="line">            print(&quot;遵守Person协议&quot;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            print(&quot;未遵守Person协议&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="AnyObject-Any"><a href="#AnyObject-Any" class="headerlink" title="AnyObject Any"></a>AnyObject Any</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var anyObjectArray: [AnyObject] = [CGFloat(0.5) as AnyObject,</span><br><span class="line">                             1 as AnyObject,</span><br><span class="line">                             &quot;string&quot; as AnyObject,</span><br><span class="line">                         iOSODev]</span><br></pre></td></tr></table></figure><p>swift是面向函数编程， 函数是一等公民，数组中可以存入一个函数，函数表达的是一个过程，不是一个名词或者物体，所以函数不是一个对象,需要使用 any 关键字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var anyArray: [Any] = [CGFloat(0.5),</span><br><span class="line">1,</span><br><span class="line">&quot;string&quot;, </span><br><span class="line">iOSODev]</span><br></pre></td></tr></table></figure><p>放入函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">anyArray.append(&#123; (a: Int) -&gt; (Int) in return a * a &#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/npm%E5%92%8Ccnpm/"/>
      <url>/2019/06/18/npm%E5%92%8Ccnpm/</url>
      
        <content type="html"><![CDATA[<h1 id="ReactNative配置-npm-和cnpm-相关"><a href="#ReactNative配置-npm-和cnpm-相关" class="headerlink" title="ReactNative配置.npm 和cnpm 相关"></a>ReactNative配置.npm 和cnpm 相关</h1><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>Nodejs的包管理工具</p><h3 id="npm-常用命令"><a href="#npm-常用命令" class="headerlink" title="npm 常用命令"></a>npm 常用命令</h3><ul><li><p>更新或卸载</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update/uninstall moduleName</span><br></pre></td></tr></table></figure></li><li><p>查看当前目录下已安装的包</p>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list</span><br></pre></td></tr></table></figure></li><li><p>查看全局安装的包的路径</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root -g</span><br></pre></td></tr></table></figure></li><li><p>全部命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm help</span><br></pre></td></tr></table></figure></li></ul><h3 id="cnpm"><a href="#cnpm" class="headerlink" title="cnpm"></a>cnpm</h3><p>因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，cnpm <a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝镜像</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><h3 id="设置镜像源"><a href="#设置镜像源" class="headerlink" title="设置镜像源"></a>设置镜像源</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cnpm set registry http://registry.cnpm.taobao.com</span><br><span class="line">npm set registry http://registry.cnpm.taobao.com</span><br></pre></td></tr></table></figure><h3 id="配置-npmrc-文件"><a href="#配置-npmrc-文件" class="headerlink" title="配置 .npmrc 文件"></a>配置 .npmrc 文件</h3><p>前端项目开发离不开安装各种npm依赖包，可以选择远程的仓库也可以选择本地的仓库，但更改仓库地址需要在安装时控制台打命令，比较麻烦， 而npmrc可以很方便地解决上面问题</p><h3 id="npmrc-原理"><a href="#npmrc-原理" class="headerlink" title=".npmrc 原理"></a>.npmrc 原理</h3><p>当安装项目的依赖包时，会查找并读取项目根目录下的.npmrc文件的配置，自动指定仓库地址</p><ul><li><p>打开 .npmrc</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open .npmrc</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>编辑文件, 指定特定的库的镜像源, 比如以<code>@test</code>开头的库镜像为：<code>http://registry.cnpm.test.com/</code> 而其他的正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@test:registry=http://registry.cnpm.lietou.com/</span><br><span class="line">registry=https://registry.npm.taobao.org/</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/swift%E4%B8%AD%E5%BC%BA%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%E5%92%8Cweak%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/06/18/swift%E4%B8%AD%E5%BC%BA%E5%BC%95%E7%94%A8%E5%BE%AA%E7%8E%AF%E5%92%8Cweak%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>Swift中内存管理</p><h3 id="强引用循环和-weak-关键字"><a href="#强引用循环和-weak-关键字" class="headerlink" title="强引用循环和 weak 关键字"></a>强引用循环和 weak 关键字</h3><p>房东</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Landlord &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var house: House?</span><br><span class="line">    </span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;Landlord内存释放&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>房子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class House &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var landlord: Landlord?</span><br><span class="line">    </span><br><span class="line">    init(person: String) &#123;</span><br><span class="line">        self.name = person</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;House内存释放&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func strongRetain() &#123;</span><br><span class="line">    var landlord: Landlord? = Landlord(name: &quot;老李&quot;)</span><br><span class="line">    var house: House? = House(person: &quot;望京府邸&quot;)</span><br><span class="line">    // 房东有个房子</span><br><span class="line">    landlord?.house = house</span><br><span class="line">    // 房子有个主人</span><br><span class="line">    house?.landlord = landlord</span><br><span class="line">    </span><br><span class="line">    landlord = nil</span><br><span class="line">    house = nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>虽然 landlord = nil 和 house = nil，但是 Landlord 和 House 内存空间并没有释放 （并未执行 deinit 函数）</p></li><li><p>原因：因为两个内存空间相互引用，引用计数不为0，形成了强循环引用</p></li><li><p>解决办法：使用weak 关键字来修饰两者中其中一个变量</p><ul><li>使用weak修饰的变量必须是可选类型，可以赋值为nil</li><li>使用weak修饰必须是var 类型变量</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class House &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    weak var landlord: Landlord?</span><br><span class="line">    </span><br><span class="line">    init(person: String) &#123;</span><br><span class="line">        self.name = person</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;House内存释放&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="unowned-关键字的使用"><a href="#unowned-关键字的使用" class="headerlink" title="unowned 关键字的使用"></a>unowned 关键字的使用</h3><h4 id="相互循环引用的两个变量有一个是可选的"><a href="#相互循环引用的两个变量有一个是可选的" class="headerlink" title="相互循环引用的两个变量有一个是可选的"></a>相互循环引用的两个变量有一个是可选的</h4><p>有个身份证的类，每个身份证肯定对应一个人</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class ID &#123;</span><br><span class="line">    var number: String</span><br><span class="line">    let person: Landlord</span><br><span class="line">    </span><br><span class="line">    init(person: Landlord, number: String) &#123;</span><br><span class="line">        self.person = person</span><br><span class="line">        self.number = number</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deinit &#123;</span><br><span class="line">        print(&quot;ID内存释放&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">房东</span><br></pre></td></tr></table></figure><p>class Landlord {<br>    var name: String<br>    var house: House?<br>    /// 身份证可以为nil，<br>    var id: ID?</p><pre><code>init(name: String) {    self.name = name}deinit {    print(&quot;Landlord内存释放&quot;)}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">循环引用</span><br></pre></td></tr></table></figure><p>func unownedTest() {<br>    var person: Landlord? = Landlord(name: “老王”)<br>    var id: ID? = ID(person: person!, number: “10010”)</p><pre><code>person?.id = idperson = nilid = nil</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-  person 和 id 之间有强引用关系</span><br><span class="line">-  每个id必须有一个对应的人并且是固定的只能使用let 修饰，不能为nil, 而id可以为空 </span><br><span class="line">- unowned和 weak 作用相同都是弱引用，只是unowned 修改的变量不能是nil （可选型的）</span><br><span class="line">-  unowned只能使用在 class 类型上，不能修饰函数类型，例如闭包存在循环引用时不能使用unowned修饰</span><br><span class="line">-  解决方法：</span><br><span class="line">-  此时可以通过使用 weak 修饰 id 的方式，因为 id 可以为nil</span><br><span class="line">-  let 修饰并且不能为nil 这种情况可以使用 unowned 修饰解决</span><br></pre></td></tr></table></figure><pre><code>class ID {    var number: String    unowned let person: Landlord    init(person: Landlord, number: String) {        self.person = person        self.number = number    }    deinit {        print(&quot;ID内存释放&quot;)    }}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**unowned有一定的危险性** </span><br><span class="line"></span><br><span class="line">因为unowned 修饰的对象不能赋值为nil，所以执行下面的代码会crash，</span><br></pre></td></tr></table></figure></code></pre><p>func unownedTest() {<br>        var person: Landlord? = Landlord(name: “老王”)<br>        var id: ID? = ID(person: person!, number: “10010”)</p><pre><code>person?.id = id// 提前释放 person 内存person = nil// 获取身份证对应的人print(id?.person) // 此处奔溃，let owner = id?.personid = nil</code></pre><p> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">正确的写法因该是先将🆔设置为nil，再将 Person 设置为nil，再调用 print(id?.person) 就不会再报错</span><br></pre></td></tr></table></figure></p><p>func unownedTest() {<br>        var person: Landlord? = Landlord(name: “老王”)<br>        var id: ID? = ID(person: person!, number: “10010”)</p><pre><code>person?.id = idid = nil// 提前释放 person 内存person = nil// 获取身份证对应的人print(id?.person) // 此处奔溃，let owner = id?.person</code></pre><p> }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 相互循环引用的两个变量都不是可选的</span><br><span class="line"></span><br><span class="line">使用隐式可选类型</span><br><span class="line"></span><br><span class="line">### 闭包中的强引用循环</span><br><span class="line"></span><br><span class="line">- 并不是所有的闭包都会产生循环引用，只有相互引用的两个对象会产生循环引用</span><br><span class="line"></span><br><span class="line">- 使用swift闭包捕获列表，在闭包的声明参数之前使用 [unowned self], 不需要解包</span><br><span class="line"></span><br><span class="line">- 使用 unowned表示这个对象不能为空，可能存在风险，如果对象为空就会crash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用 unowned 对象不能为空，可能存在风险</span><br></pre></td></tr></table></figure></p><p>class Closure {<br>    var closure: ((Int) -&gt; Void)?</p><pre><code>init() {    closure = { [unowned self] index in        print(self)        print(index)    }}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">使用 weak, 此时需要解包</span><br></pre></td></tr></table></figure></p><p>closure = { [weak self] index in<br>            // 解包<br>            if let <code>self</code> = self {<br>                print(self)<br>                print(index)<br>            }<br>        }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">强制解包</span><br></pre></td></tr></table></figure></p><p>closure = { [weak self] index in<br>            // 强制解包<br>            print(self!)<br>            print(index)<br>        }<br><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/typescripe%20%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/18/typescripe%20%E5%AE%89%E8%A3%85%E5%8F%8A%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="ReactNative-中使用-TypeScript"><a href="#ReactNative-中使用-TypeScript" class="headerlink" title="ReactNative 中使用 TypeScript"></a>ReactNative 中使用 TypeScript</h2><blockquote><p>从RN0.57版本开始已经可以直接支持typescript，无需任何配置。在保留根入口文件index.js的前提下，其他文件都可以直接使用.ts或.tsx后缀。但这一由babel进行的转码过程并不进行实际的类型检查，因此仍然需要编辑器和插件来共同进行类型检查</p></blockquote><h3 id="TypeScript和JavaScript对比"><a href="#TypeScript和JavaScript对比" class="headerlink" title="TypeScript和JavaScript对比"></a>TypeScript和JavaScript对比</h3><p><a href="https://juejin.im/entry/5a52ed336fb9a01cbd586f9f" target="_blank" rel="noopener">两者深度对比</a></p><p>最大的区别：</p><ul><li>TypeScript是强类型语⾔和静态类型语⾔（需要指定类型）</li><li>JavaScript是弱类型语⾔和动态类型语⾔（不需要指定类型）</li></ul><h3 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h3><p>由微软开发的自由和开源的编程语言，是JavaScript的一个严格超集，并添加了可选的静态类型和基于类的面向对象编程</p><p><a href="https://zh.wikipedia.org/wiki/TypeScript" target="_blank" rel="noopener">TypeScript定义</a></p><h3 id="安装及语法"><a href="#安装及语法" class="headerlink" title="安装及语法"></a>安装及语法</h3><p><a href="https://www.tslang.cn/docs/home.html" target="_blank" rel="noopener">教程</a></p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure><h5 id="安装-typescript-依赖管理器-typings"><a href="#安装-typescript-依赖管理器-typings" class="headerlink" title="安装 typescript 依赖管理器 typings"></a>安装 typescript 依赖管理器 typings</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typings</span><br></pre></td></tr></table></figure><h5 id="安装-typings-依赖"><a href="#安装-typings-依赖" class="headerlink" title="安装 typings 依赖"></a>安装 typings 依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typings install npm~react --save</span><br><span class="line">typings install dt~react-native --globals --save</span><br></pre></td></tr></table></figure><h5 id="使用-yarn-安装"><a href="#使用-yarn-安装" class="headerlink" title="使用 yarn 安装"></a>使用 yarn 安装</h5><p>如果已经安装了 yarn 安装如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn add tslib @types/react @types/react-native</span><br><span class="line">yarn add --dev react-native-typescript-transformer typescript</span><br></pre></td></tr></table></figure><h5 id="创建-tsconfig-json-配置文件"><a href="#创建-tsconfig-json-配置文件" class="headerlink" title="创建 tsconfig.json 配置文件"></a>创建 tsconfig.json 配置文件</h5><ul><li><p>cd 到 ReactNative 项目根文件夹下</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure></li><li><p>修改 tsconfig.json 文件 </p><p>  如果一个目录下存在一个tsconfig.json文件，那么它意味着这个目录是TypeScript项目的根目录。 tsconfig.json文件中指定了用来编译这个项目的根文件和编译选项</p><p>  <a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html" target="_blank" rel="noopener">tsconfig.json文件配置详解</a></p><p>  <a href="https://github.com/hstarorg/HstarDoc/blob/master/%E5%89%8D%E7%AB%AF%E7%9B%B8%E5%85%B3/TypeScript%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6tsconfig%E7%AE%80%E6%9E%90.md">TypeScript配置文件tsconfig简析</a></p><p>  <strong>务必设置”jsx”:”react”<br>注意多余的注释可能会不兼容，需要移除</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;compilerOptions&quot;: &#123;</span><br><span class="line">        &quot;target&quot;: &quot;es6&quot;,</span><br><span class="line">        &quot;allowJs&quot;: true,</span><br><span class="line">        &quot;jsx&quot;: &quot;react&quot;,</span><br><span class="line">        &quot;outDir&quot;: &quot;./dist&quot;,</span><br><span class="line">        &quot;sourceMap&quot;: true,</span><br><span class="line">        &quot;noImplicitAny&quot;: false</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    // &quot;files&quot;属性 ：指定一个包含相对或绝对文件路径的列表。 &quot;include&quot;和&quot;exclude&quot;属性指定一个文件glob匹配模式列表</span><br><span class="line">    </span><br><span class="line">    &quot;include&quot;: [</span><br><span class="line">        &quot;typings/**/*.d.ts&quot;,</span><br><span class="line">        &quot;src/**/*.ts&quot;,</span><br><span class="line">        &quot;src/**/*.tsx&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;exclude&quot;: [</span><br><span class="line">        &quot;node_modules&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>cd 到项目根目录中新建存放 typescripe 源代码的文件夹</p></li></ul><h5 id="建立-rn-cli-config-js-文件，使用支持typescript的transfomer"><a href="#建立-rn-cli-config-js-文件，使用支持typescript的transfomer" class="headerlink" title="建立 rn-cli.config.js 文件，使用支持typescript的transfomer"></a>建立 rn-cli.config.js 文件，使用支持typescript的transfomer</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  getTransformModulePath() &#123;</span><br><span class="line">    return require.resolve(&apos;react-native-typescript-transformer&apos;);</span><br><span class="line">  &#125;,</span><br><span class="line">  getSourceExts() &#123;</span><br><span class="line">    return [&apos;ts&apos;, &apos;tsx&apos;];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改-babelrc-文件"><a href="#修改-babelrc-文件" class="headerlink" title="修改 .babelrc 文件"></a>修改 .babelrc 文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;presets&quot;: [&quot;react-native&quot;],</span><br><span class="line"> &quot;plugins&quot;: [&quot;transform-decorators-legacy&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改项目中文件导入"><a href="#修改项目中文件导入" class="headerlink" title="修改项目中文件导入"></a>修改项目中文件导入</h5><ul><li>入口<code>index.js</code>和<code>App.js</code>的文件名请不要修改，项目根目录下新建<code>src</code>文件夹</li><li>在<code>src</code>文件夹下新建 <code>.tsx</code> 后缀的文件</li><li><p><code>.tsx</code> 后缀的文件引用react的写法有所区别</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import * as React from &apos;react&apos;</span><br><span class="line">import &#123; Text, View &#125; from &apos;react-native&apos;;</span><br><span class="line">import &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">export default class HelloWorld extends Component&#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;View&gt;</span><br><span class="line">                &lt;Text&gt;Hello!&lt;/Text&gt;</span><br><span class="line">                &lt;Text&gt;Typescript&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在<code>App.js</code>中使用</p><ul><li><p><code>App.js</code> 导入方式修改为如下方式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &apos;./src&apos;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">- 导入 .tsx 类型的组建</span><br></pre></td></tr></table></figure><p>  import HelloWorld from “./src/HelloWorld”;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 配置jsconfig</span><br><span class="line"></span><br><span class="line">`jsconfig.json`目录中存在文件表明该目录是JavaScript项目的根目录。该jsconfig.json文件指定根文件和JavaScript语言服务提供的功能选项</span><br><span class="line"></span><br><span class="line">[jsconfig详解](https://code.visualstudio.com/docs/languages/jsconfig)</span><br><span class="line"></span><br><span class="line">[jsconfig.json](https://jeasonstudio.gitbooks.io/vscode-cn-doc/content/md/%E8%AF%AD%E8%A8%80/javascript.html?q=)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 新建 `jsconfig.json` 文件</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>touch jsconfig.json<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 编辑 `jsconfig.json` 文件</span><br></pre></td></tr></table></figure></p><p>{<br>    “compilerOptions”: {<br>    “allowJs”: true,<br>    “allowSyntheticDefaultImports”: true,<br>    “emitDecoratorMetadata”: true<br>    },<br>    “exclude”: [<br>    “node_modules”,<br>    “rnApp/Tools” // 项目根目录下新建的存放RN中所用的一些工具类<br>    ]<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">### package.json 文件配置</span><br></pre></td></tr></table></figure><p>{<br>  “name”: “RNProject”,<br>  “version”: “0.0.1”,<br>  “private”: true,<br>  “scripts”: { // 通过设置这个可以使npm调用一些命令脚本，封装一些功能<br>    “start”: “node node_modules/react-native/local-cli/cli.js start”,<br>    “test”: “jest”<br>  },<br>  “dependencies”: { // 发布后依赖的包<br>    “@types/react”: “^16.4.16”,<br>    “@types/react-native”: “^0.57.4”,<br>    “react”: “16.5.0”,<br>    “react-native”: “0.57.2”,<br>    “react-transform-hmr”: “^1.0.4”,<br>    “tslib”: “^1.9.3”<br>  },</p><p>  “devDependencies”: { // 开发中依赖的其它包<br>    “babel-jest”: “23.6.0”,<br>    “jest”: “23.6.0”,<br>    “metro-react-native-babel-preset”: “0.48.0”,<br>    “react-native-typescript-transformer”: “^1.2.10”,<br>    “react-test-renderer”: “16.5.0”,<br>    “typescript”: “^3.1.2”<br>  },</p><p>  “jest”: { // JavaScript 的单元测试框架<br>    “preset”: “react-native”<br>  }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### `–save` 和 `-–save-dev` 区别</span><br><span class="line"></span><br><span class="line">- --save参数表示将该模块写入dependencies属性，</span><br><span class="line">- --save-dev表示将该模块写入devDependencies属性。</span><br><span class="line"></span><br><span class="line">##### 添加开发依赖库</span><br><span class="line"></span><br><span class="line">- 类型检查</span><br></pre></td></tr></table></figure></p><pre><code>npm install @types/jest --save-devnpm install @types/react --save-devnpm install @types/react-native --save-dev <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 装饰器转化核心插件</span><br></pre></td></tr></table></figure>npm install babel-plugin-transform-decorators-legacy --save-dev<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 测试框架</span><br></pre></td></tr></table></figure>npm install react-addons-test-utils --save-devnpm install react-native-mock --save-dev<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 删除依赖库</span><br></pre></td></tr></table></figure></code></pre><p>npm uninstall @types/jest –save<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>npm uninstall @types/jest –save-dev<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 彻底删除，-d 表示 devDependencies， -O 表示 optionalDependencies 中</span><br></pre></td></tr></table></figure></p><p>npm uninstall -s -D -O @types/jest</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 报错汇总</span><br><span class="line"></span><br><span class="line">##### 错误1 `Cannot find module &apos;react-transform-hmr/lib/index.js&apos;`</span><br><span class="line"></span><br><span class="line"> [解决1](https://stackoverflow.com/questions/50142561/cannot-find-module-react-transform-hmr-lib-index-js?noredirect=1&amp;lq=1)</span><br><span class="line"></span><br><span class="line"> [解决2](https://github.com/facebook/react-native/issues/21530)</span><br><span class="line"></span><br><span class="line">- 安装 `react-transform-hmr`</span><br></pre></td></tr></table></figure><pre><code>npm install react-transform-hmr --save<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 清除缓存重新启动服务</span><br></pre></td></tr></table></figure>npm start --reset-cache```</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/%E3%80%8A52%E4%B8%AA%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/"/>
      <url>/2019/06/18/%E3%80%8A52%E4%B8%AA%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%80%E7%AB%A0%E3%80%8B/</url>
      
        <content type="html"><![CDATA[<p>《52个方法-第一章》</p><h3 id="一、OC起源"><a href="#一、OC起源" class="headerlink" title="一、OC起源"></a>一、OC起源</h3><ul><li>OC使用的是“消息结构”而不是“函数调用”</li><li>两者区别：<ul><li>消息结构：在运行时所执行的代码由运行环境来决定，无论是否多态总会在运行时才会去查找所要执行的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSObject *objc = [NSObject new];</span><br><span class="line">[objc performWith: parameter1 and: parameter2];</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 函数调用：由编译器决定，如果函数多态，编译时就要查处到底应该执行那个函数实现<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object *objc = new Object;</span><br><span class="line">   objc -&gt; perform(parameter1, parameter2);</span><br></pre></td></tr></table></figure></code></pre><ul><li>消息结构中编译器不会关心接收消息的对象是何种类型，接收消息的对象问题也要在运行时处理，此过程叫做“动态绑定”</li></ul><p><strong>要点：</strong></p><ol><li>OC语言使用的动态绑定的消息结构，在运行时所执行的代码由运行环境来决定，无论是否多态总会在运行时才会去查找所要执行的方法，</li><li>OC 中对象总是分配在“堆空间”，而绝不会分配在”栈“上，不带 “*”的变量或者结构体等可能会使用“栈空间”</li></ol><h3 id="二、类头文件尽量少导入其他头文件"><a href="#二、类头文件尽量少导入其他头文件" class="headerlink" title="二、类头文件尽量少导入其他头文件"></a>二、类头文件尽量少导入其他头文件</h3><p><strong>要点：</strong></p><ol><li>除非必要，否则不要引入头文件，使用向前声明降低类之间的耦合</li><li>有时无法使用向前声明，应该把该类遵守协议的声明放到“class-continuation分类”（匿名分类）中。</li><li>如果“class-continuation分类”也不行的话，就把协议单独放在一个文件中，再将其引入### 三、多用字面量语法，少用与之等价的方法</li></ol><h3 id="三、多用字面量语法，少用与之等价的方法"><a href="#三、多用字面量语法，少用与之等价的方法" class="headerlink" title="三、多用字面量语法，少用与之等价的方法"></a>三、多用字面量语法，少用与之等价的方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (void)tempMethond &#123;</span><br><span class="line">    // OC1.0 起，支持简单方式创建基本类型对象</span><br><span class="line">    </span><br><span class="line">    // - 使用字符串字面量：简介易读</span><br><span class="line">    NSString *someString = @&quot;Effective Objective-C 2.0&quot;;</span><br><span class="line">    // 传统方式</span><br><span class="line">    NSString *someStrongOld = [NSString stringWithFormat:@&quot;Effective Objective-C 2.0&quot;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // - 字面数值</span><br><span class="line">    NSNumber *someNumber = @1;</span><br><span class="line">    NSNumber *floatNumber = @2.5f;</span><br><span class="line">    NSNumber *doubleNumber = @3.1415926;</span><br><span class="line">    NSNumber *boolNumber = @YES;</span><br><span class="line">    NSNumber *charNumber = @&apos;a&apos;;</span><br><span class="line">    // 字面量语法用于表达式</span><br><span class="line">    int x = 5;</span><br><span class="line">    float y = 6.23f;</span><br><span class="line">    NSNumber *expressionNumber = @(x * y);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // - 字面量数组</span><br><span class="line">    NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];</span><br><span class="line">    NSString *dog = animals[1];</span><br><span class="line">    </span><br><span class="line">    // arrayWithObjects 和 字面量 的区别:</span><br><span class="line">    // arrayWithObjects 方法依次处理各个参数，直到发现nil为止</span><br><span class="line">    // 字面量数组遇到nil直接抛出异常</span><br><span class="line">    NSArray *animalsOld = [NSArray arrayWithObjects:@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;, nil];</span><br><span class="line">    NSString *dogOld = [animalsOld objectAtIndex:1];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // - 字面量字典</span><br><span class="line">    // 如果有nil直接抛出异常</span><br><span class="line">    NSDictionary *personData = @&#123;@&quot;firtName&quot;: @&quot;Matt&quot;,</span><br><span class="line">                                 @&quot;lastName&quot;: @&quot;Galloway&quot;,</span><br><span class="line">                                 @&quot;age&quot;: @28&#125;;</span><br><span class="line">    NSString *lastName = personData[@&quot;lastName&quot;];</span><br><span class="line">    </span><br><span class="line">    // dictionaryWithObjectsAndKeys 方法依次处理各个参数，直到发现nil为止</span><br><span class="line">    NSDictionary *personDataOld = [NSDictionary dictionaryWithObjectsAndKeys:@&quot;Matt&quot;,@&quot;firtName&quot;,</span><br><span class="line">                                     @&quot;Galloway&quot;, @&quot;lastName&quot;,</span><br><span class="line">                                     [NSNumber numberWithInteger:28], @&quot;age&quot;, nil];</span><br><span class="line">    </span><br><span class="line">    NSString *lastNameOld = [personData objectForKey:@&quot;lastName&quot;];</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // - 可变数组和字典</span><br><span class="line">    NSMutableArray *mutableArray = animals.mutableCopy;</span><br><span class="line">    mutableArray[1] = @&quot;dog&quot;;</span><br><span class="line">    </span><br><span class="line">    NSMutableDictionary *mutableDict = [personData mutableCopy];</span><br><span class="line">    mutableDict[@&quot;lastName&quot;] = @&quot;Galloway&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>要点：</strong></p><ol><li>使用字面量语法创建字符串，数值，数组，字典简明扼要</li><li>通过下标操作获取数组，字典对应的元素</li><li>使用字面量创建数组，字典时若有nil ，会抛出异常，确保值里不含nil### 五、用枚举表示状态、选项、状态码</li></ol><h3 id="四、多用类型常量，少用-define预处理指令"><a href="#四、多用类型常量，少用-define预处理指令" class="headerlink" title="四、多用类型常量，少用#define预处理指令"></a>四、多用类型常量，少用#define预处理指令</h3><h5 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h5><ul><li>缺点：<ul><li>可以把所有相同的字符串值都替换为定义的值，<ul><li>定义出来的常量没有具体的类型信息</li><li>如果有人重新定义了宏定义，不会有警告或者提醒，导致程序中值不一样</li></ul></li></ul></li></ul><h5 id="类型常量"><a href="#类型常量" class="headerlink" title="类型常量"></a>类型常量</h5><ul><li><p>命名规则：</p><ul><li>如果只是在实现文件.m 中使用，则在前面加字母k</li><li>如果此常量在类之外也可见，则以类名为前缀，（第19条详细了解命名习惯）</li></ul></li><li><p>声明位置：</p><ul><li>总是喜欢在头文件中声明宏定义，可能和常量名冲突，</li><li>所有引入这个头文件的类都会出现宏定义或者常量，相当于声明了一个名叫kAnimationDuration的全局变量</li><li>应该加上前缀，表明其所属的具体类，例如：EOCViewClassAnimationDuration</li></ul></li><li><p>常量从右往左解读依次是: 具体类型，不可修改</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// const 修饰的是常量不希望别人修改， NSString * 指向NSString对象</span><br><span class="line">extern NSString *const EOCStringConstant; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//两者写法都可以</span><br><span class="line">extern const NSTimeInterval EOCAnimatedViewAnimationDuration;</span><br><span class="line">extern NSTimeInterval const EOCAnimatedViewAnimationDuration1;</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- 如果不打算公开常量，可以定义在 .m 实现文件里</span><br></pre></td></tr></table></figure><p>  static const NSTimeInterval kAnimationDuration = 0.3;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- static关键字</span><br><span class="line">- static 修饰意味着该变量仅在定义此变量的编译单元（实现文件.m）中可见，作用域就是当前.m文件</span><br></pre></td></tr></table></figure><pre><code>static const NSTimeInterval kAnimationDuration = 0.3;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 如果需要声明一个外部可见的常值变量，需要在头文件中声明并使用 extern 关键词修饰 &quot;extern </span><br><span class="line"></span><br><span class="line">在 .h 文件中</span><br></pre></td></tr></table></figure>extern NSString *const EOCStringConstant;// 两者写法都可以extern const NSTimeInterval EOCAnimatedViewAnimationDuration;extern NSTimeInterval const EOCAnimatedViewAnimationDuration1;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 .m 文件中</span><br></pre></td></tr></table></figure>NSString *const EOCStringConstant = @&quot;VALUE&quot;;const NSTimeInterval EOCAnimatedViewAnimationDuration = 0.3;NSTimeInterval const EOCAnimatedViewAnimationDuration1 = 0.3;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**要点：**</span><br><span class="line"></span><br><span class="line">1. 定义常量时static const定义编译单元（实现文件.m)中可见的常量，无需为其名称加前缀</span><br><span class="line">2. 在头文件中使用extern 声明全局常量，并在实现文件中定义其值，这种常量要出现在全局符号表中，所以加相关类作为前缀</span><br><span class="line"></span><br><span class="line">### 五、用枚举表示状态、选项、状态码</span><br><span class="line"></span><br><span class="line">- 普通枚举</span><br></pre></td></tr></table></figure></code></pre><p>  enum EOCConnectionState {</p><pre><code>EOCConnectionStateDisconnected, // 断开连接EOCConnectionStateConnecting,   // 连接中...EOCConnectionStateConnected,    // 已连接</code></pre><p>  };</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通枚举如果要使用如下：</span><br></pre></td></tr></table></figure><p>  enum EOCConnectionState status = EOCConnectionStateConnected;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果每次都不需要输入enum关键字，只需要typedef关键字重新定义枚举类型</span><br></pre></td></tr></table></figure><p>  EOCConnectionState status1 = EOCConnectionStateConnecting;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 设置枚举的初始值</span><br></pre></td></tr></table></figure><p>  enum EOCConnectionStateConnectionState {</p><pre><code>EOCConnectionStateConnectionStateDisconnected = 1, // 断开连接EOCConnectionStateConnectionStateConnecting,   // 连接中...EOCConnectionStateConnectionStateConnected,    // 已连接</code></pre><p>  };</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 可选枚举</span><br><span class="line"></span><br><span class="line">- &lt;&lt; 位操作符(左移)， 表示往左移动N位，使用 位运算符 | (或)来组合使用</span><br><span class="line">- 使用位运算符 &amp;（与） 判断是否开启了某个选项</span><br></pre></td></tr></table></figure><p>  enum UIViewAutoresizing {</p><pre><code>UIViewAutoresizingNone                 = 0,UIViewAutoresizingFlexibleLeftMargin   = 1 &lt;&lt; 0,UIViewAutoresizingFlexibleWidth        = 1 &lt;&lt; 1,UIViewAutoresizingFlexibleRightMargin  = 1 &lt;&lt; 2,UIViewAutoresizingFlexibleTopMargin    = 1 &lt;&lt; 3,UIViewAutoresizingFlexibleHeight       = 1 &lt;&lt; 4,UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</code></pre><p>  }</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 使用宏定义枚举</span><br><span class="line"></span><br><span class="line">普通枚举类型（老式语法定义枚举）</span><br></pre></td></tr></table></figure><p>  typedef enum : NSUInteger {</p><pre><code>EOCConnectionState2DisConnected,EOCConnectionState2DisConnecting,EOCConnectionState2Connected,</code></pre><p>  } EOCConnectionState2;</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NS_ENUM 宏定义的枚举展开后：</span><br></pre></td></tr></table></figure><p>  typedef enum EOCConnectionState_3 : NSUInteger EOCConnectionState_3;<br>  enum EOCConnectionState_3 : NSUInteger {</p><pre><code>EOCConnectionState_3DisConnected,EOCConnectionState_3DisConnecting,EOCConnectionState_3Connected,</code></pre><p>  };</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 定义新特性枚举</span><br></pre></td></tr></table></figure><p>  typedef NS_ENUM(NSUInteger, EOCConnectionState3) {</p><pre><code>EOCConnectionState3DisConnected,EOCConnectionState3DisConnecting,EOCConnectionState3Connected,</code></pre><p>  };</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 枚举使用</span><br><span class="line"></span><br><span class="line">.h文件</span><br></pre></td></tr></table></figure><p>  #import &lt;UIKit/UIKit.h&gt;</p><p>  typedef enum EOCConnectionState EOCConnectionState;</p><p>  typedef NS_ENUM(NSUInteger, EOCConnectionState3) {</p><pre><code>EOCConnectionState3DisConnected,EOCConnectionState3DisConnecting,EOCConnectionState3Connected,</code></pre><p>  };</p></li></ul><pre><code>@interface EOCEnum : NSObject@property (nonatomic, assign) enum EOCConnectionState state;@property (nonatomic, assign) EOCConnectionState3 state3;@end<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">.m 文件中</span><br></pre></td></tr></table></figure>#import &quot;EOCEnum.h&quot;@implementation EOCEnum- (void)testEnum {    // 未使用typedef 关键字    enum EOCConnectionState status = EOCConnectionStateConnected;    NSLog(@&quot;%u&quot;, status);    // 使用typedef 关键字    EOCConnectionState status1 = EOCConnectionStateConnecting;    NSLog(@&quot;%u&quot;, status1);    UIViewAutoresizing resizing = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;    if (resizing &amp; UIViewAutoresizingFlexibleWidth) {        // 设置了 UIViewAutoresizingFlexibleWidth 约束    }}// UIKit 试图所支持的设置显示方向- (UIInterfaceOrientationMask)supportedInterfaceOrientations {    return UIInterfaceOrientationMaskPortrait | UIInterfaceOrientationMaskLandscapeLeft;}// 枚举使用- (void)userEnum {    switch (_state3) {        case EOCConnectionState3DisConnected:            // ...            break;        case EOCConnectionState3DisConnecting:            // ...            break;        case EOCConnectionState3Connected:            // ...            break;        default: // 最好不用，防止以后增加一种状态机之后，编译器不发出警告            break;    }}@end```</code></pre><p><strong>要点：</strong></p><ol><li>使用枚举表示状态机的状态、传递给方法的选项以及状态码等值，给枚举值起名时要注重易懂</li><li>如果一个类型可以使用状态机的状态来表示，并且多个选项可同时使用，那么就定义为可选的枚举类型，枚举各值定义为2的幂，以便通过“按位或”操作组合</li><li>使用NS_ENUM 和 NS_OPTIONS 宏来定义枚举，并指明底层的数据类型。这样可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型</li><li>switch语句处理枚举类型时不要实现default 分支，如果以后加入枚举的新状态之后，编译器会发出警告</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/iOS%E9%80%9A%E8%BF%87URL%E8%8E%B7%E5%8F%96HTML%E4%B8%AD%E6%A0%87%E9%A2%98/"/>
      <url>/2019/06/18/iOS%E9%80%9A%E8%BF%87URL%E8%8E%B7%E5%8F%96HTML%E4%B8%AD%E6%A0%87%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>iOS通过URL获取HTML中标题</p><h3 id="获取标题"><a href="#获取标题" class="headerlink" title="获取标题"></a>获取标题</h3><h5 id="String扩展一个方法"><a href="#String扩展一个方法" class="headerlink" title="String扩展一个方法"></a>String扩展一个方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private let patternTitle = &quot;(?&lt;=title&gt;).*(?=&lt;/title)&quot;</span><br><span class="line">extension String &#123;</span><br><span class="line">    static func parseHTMLTitle(_ urlString: String) -&gt; String? &#123;</span><br><span class="line">        let url = URL(string: urlString)!</span><br><span class="line">        do &#123;</span><br><span class="line">            let html = try String(contentsOf: url, encoding: .utf8)</span><br><span class="line">            let range = html.range(of: patternTitle, options: String.CompareOptions.regularExpression, range: html.startIndex..&lt;html.endIndex, locale: nil)</span><br><span class="line">            guard let tempRange = range else &#123; return &quot;&quot; &#125;</span><br><span class="line">            let titleStr = html[tempRange]</span><br><span class="line">            return String(titleStr)</span><br><span class="line">        &#125; catch &#123;</span><br><span class="line">            return &quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="iOS-中简单正则表达式"><a href="#iOS-中简单正则表达式" class="headerlink" title="iOS 中简单正则表达式"></a>iOS 中简单正则表达式</h5><p>iOS 中 正则表达式中的\ 需要使用 \\ 来表示</p><pre><code>// 获取let testStr = &quot;我到底是[iOS]开发还是[产品]经理&quot;// 获取 &quot;[&quot; 和 &quot;]&quot; 之间的所有内容, 左边[ 起一直到 右边 ] 结束的所有内容 let pattern1 = &quot;\\[.*\\]&quot; // [iOS]开发还是[产品]// 获取 &quot;[&quot; 和 &quot;]&quot; 之间的所有内容，包括[]let pattern2 = &quot;\\[.*?\\]&quot;    // [iOS]// 获取第一个 &quot;[&quot; 和 &quot;]&quot; 之间的所有内容 不包括[] let pattern3 = &quot;(?&lt;=\\[).*?(?=\\])&quot; // iOS// 获取html中 title 标签中内容let pattern5 = &quot;(?&lt;=title&gt;).*(?=&lt;/title)&quot; </code></pre><h5 id="获取范围截取子串"><a href="#获取范围截取子串" class="headerlink" title="获取范围截取子串"></a>获取范围截取子串</h5><pre><code>let testRange1 = testStr.range(of: pattern1, options: String.CompareOptions.regularExpression, range: testStr.startIndex..&lt;testStr.endIndex, locale: nil)    let result1 = String(testStr[testRange1!])let testRange2 = testStr.range(of: pattern2, options: String.CompareOptions.regularExpression, range: testStr.startIndex..&lt;testStr.endIndex, locale: nil)let result2 = String(testStr[testRange2!])let testRange3 = testStr.range(of: pattern3, options: String.CompareOptions.regularExpression, range: testStr.startIndex..&lt;testStr.endIndex, locale: nil)let result3 = String(testStr[testRange3!])print(result1) print(result2) print(result3) </code></pre><h5 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h5><p>通过URL解析html中的标题</p><ul><li>获取html字符串</li><li>正则匹配</li><li>生成字符串Range</li><li>截取字符串</li></ul><p>匹配一次直接返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 生成表达式</span><br><span class="line">let regular = try NSRegularExpression(pattern: pattern5, options: .caseInsensitive) </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">// 开始匹配  </span><br><span class="line">let matchResult1 = regular.firstMatch(in: html, options: NSRegularExpression.MatchingOptions.reportProgress, range: NSMakeRange(0, html.count))</span><br><span class="line"></span><br><span class="line">// 获取匹配结果范围</span><br><span class="line">let matchRange = matchResult1?.range</span><br><span class="line">let range = Range(matchRange!)!</span><br><span class="line">    </span><br><span class="line">// 生成String.Index 类型范围 </span><br><span class="line">let startIndex = html.index(html.startIndex, offsetBy: range.lowerBound)</span><br><span class="line">let endIndex = html.index(html.startIndex, offsetBy: range.upperBound)</span><br><span class="line">let range3 = Range(uncheckedBounds: (lower: startIndex, upper: endIndex))</span><br><span class="line"></span><br><span class="line">// 截取字符串</span><br><span class="line">let result1 = String(html[range3])</span><br><span class="line">print(result1)</span><br></pre></td></tr></table></figure><p>全部匹配后返回结果时一个集合</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let matchResult2 = regular.matches(in: html, options: .reportProgress, range: NSMakeRange(0, html.count))</span><br><span class="line">            matchResult2.forEach &#123; (result) in</span><br><span class="line">let range = Range(result.range)!</span><br><span class="line">    </span><br><span class="line">let startIndex = html.index(html.startIndex, offsetBy: range.lowerBound)</span><br><span class="line">let endIndex = html.index(html.startIndex, offsetBy: range.upperBound)</span><br><span class="line">    </span><br><span class="line">let subStr2 = html[Range(uncheckedBounds: (startIndex, endIndex))]</span><br><span class="line">print(String(subStr2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将匹配到的内容提还</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let str3 = regular.stringByReplacingMatches(in: html, options: .reportProgress, range: NSMakeRange(0, html.count), withTemplate: &quot;====&quot;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/iOS%E9%9D%A2%E8%AF%95OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/"/>
      <url>/2019/06/18/iOS%E9%9D%A2%E8%AF%95OC%E8%AF%AD%E8%A8%80%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="OC-语言特性"><a href="#OC-语言特性" class="headerlink" title="OC 语言特性"></a>OC 语言特性</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由运行时来决议的，不同分类当中含有同名方法 谁最终生效取决于谁最终参与编译，最后参编译的同名分类方法会最终生效，假如分类方法中添加的方法和宿主类中的某一个方法名相同，分类中的方法会覆盖宿主类中的同名方法，覆盖是指在消息传递过程中优先查找数组靠前的元素，如果查找到了同名方法就直接调用，实际上宿主类的同名方法实现仍然是存在的，我们可可以通过一些手段调用到原有类的同名方法的实现 </p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>申明私有方法，分类的 .m 文件中申明私有方法啊，对外不暴露</li><li>对类中的代码进行抽取分解</li><li>把Framework的私有方法公开化</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>运行时决议，运行时通过runtime 才把分类中的方法添加到了宿主类上</li><li>可以为系统类添加方法</li><li>有多个分类中存在同名方法时，最后编译的方法会最先生效</li><li>分类中有和宿主类同名方法时，底层中通过内存copy将分类方法“覆盖”宿主类方法</li><li>名字相同的分类编译会报错</li></ul><h3 id="分类中可以添加的内容"><a href="#分类中可以添加的内容" class="headerlink" title="分类中可以添加的内容"></a>分类中可以添加的内容</h3><ul><li>实例方法</li><li>类方法</li><li>协议</li><li>属性，实际上只是声明了 getter / setter 方法，并没有添加成员变量</li></ul><h3 id="关联对象技术"><a href="#关联对象技术" class="headerlink" title="关联对象技术"></a>关联对象技术</h3><p>关联对象由 AssocicationsManager 管理并在 AssociationsHashMap 上存储<br>所有对象的关联内容都在同一个全局容器中</p><ul><li>给分类添加成员变量，通过关联对象的方式</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>声明私有属性</li><li>声明私有方法</li><li>声明私有成员变量</li></ul><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>编译时决议</li><li>只以声明的形式存在，多数情况下寄生在宿主类的.m中</li><li>不能为系统添加扩展</li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><ul><li>代理设计模式，传递方式是一对一</li><li>使用weak 避免循环引用</li></ul><h2 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h2><p>使用观察者模式来实现的用于跨层传递消息的机制</p><h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>KVO 是系统对观察者模式的又一实现，使用isa 混写技术（isa - swizzling）来动态运行时为某一个类添加一个子类重写了它的setter 方法，同时将原有类的isa指针指向了新创建的类上</p><ul><li>KVO 是OC对观察者模式的又一实现</li><li>apple 使用isa 混写技术（isa - swizzling）来实现KVO<ul><li>给我A类注册一个观察者时本质上是调用系统的 Observer for keyPath 方法，系统会创建一个NSKVONotifiying_A 的类</li></ul></li><li>使用 setter 方法设置值KVO才能生效</li><li>使用setValue:forKey: 改变值KVO才能生效</li><li>使用下划线的成员变量直接修改值需要手动添加KVO才能生效（增加 willChangeValueForKey 和 didChangeValueForKey 两个方法）</li></ul><h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><p>apple提供的键值编码技术</p><ul><li>(nullable id)valueForKey:(NSString *)key;</li><li><p>(void)setValue:(nullable id)value forKey:(NSString *)key;</p><p>  以上两个方法中的key是没有任何限制的，只要知道对应的成员变量名称，就可以对私有的成员变量设置和操作，这违背了面向对象的编程思想</p></li></ul><p><strong>(void)setValue:(nullable id)value forKey:(NSString *)key; 方法调用流程</strong></p><ul><li>先判断是否有跟key 相关的setter 方法，如果有就直接调用，结束调用</li><li>如果没有再判断是否存在实例变量，如果存在直接给赋值，结束调用</li><li>如果说实例变量不存在，会去调用 <code>- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;</code> 抛出异常</li></ul><h2 id="属性关键字"><a href="#属性关键字" class="headerlink" title="属性关键字"></a>属性关键字</h2><h3 id="读写权限"><a href="#读写权限" class="headerlink" title="读写权限"></a>读写权限</h3><ul><li><p>readonly</p></li><li><p>readwrite 系统默认</p></li></ul><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul><li>atomic （系统默认）保证赋值和获取（对成员属性的直接获取和赋值）时线程安全，并不代表操作和访问，如果atomic修饰的一个数组，只能保证独具改数组的读取和赋值时线程安全，并不能保证对数据操作（增加/删除数组元素）时是安全的</li><li>nonatomic</li></ul><h3 id="引用技术"><a href="#引用技术" class="headerlink" title="引用技术"></a>引用技术</h3><ul><li>assign <ul><li>修饰基本数据类型，</li><li>修饰对象时不改变其引用计数，</li><li>会产生悬垂指针</li></ul></li><li>weak  <ul><li>不改变被修饰对象的引用计数，</li><li>所指对象被释放之后指针自动置为nil</li></ul></li></ul><p><strong>两者区别：</strong></p><ul><li>weak可以修饰对象，而assign 既可以修饰对象也可以修饰基本数据类型</li><li>assign 修饰的对象，对象释放后指针仍然指向原对象的内存地址，而weak 修饰的对象，释放后会自动置为nil</li></ul><p><strong>问题1</strong> </p><p>weak 修饰的对象为什么释放后会自动置为nil</p><p><strong>问题2</strong></p><p><code>@property (copy) NSMutableArray *array;</code> 有什么问题</p><ul><li>被copy修饰后，如果赋值过来的是NSMutableArray，copy之后就是NSArray，如果赋值过来的是NSAarray，copy 之后仍然是NSArray，有可能会调用array的添加元素方法会导致crash</li></ul><h3 id="copy-关键词"><a href="#copy-关键词" class="headerlink" title="copy 关键词"></a>copy 关键词</h3><p> <img src="https://ws2.sinaimg.cn/large/006tNc79ly1g1uh6lwwe2j320s0lm7bm.jpg" alt></p><ul><li>浅拷贝：内存地址的复制，让目标对象指针和源对象指向同一块内存空间，<ul><li>会增加对象的引用计数</li><li>并没有一个新的内存分配</li></ul></li></ul><ul><li>深拷贝：目标对象指针和源对象指针分别指向两块内容相同的内存空间<ul><li>不会增加源对象的引用计数</li><li>有新对象的内存分配</li></ul></li></ul><h2 id="MRC-重写-retain修饰的变量的setter-方法"><a href="#MRC-重写-retain修饰的变量的setter-方法" class="headerlink" title="MRC 重写 retain修饰的变量的setter 方法"></a>MRC 重写 retain修饰的变量的setter 方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- (void)setObj:(id)obj &#123;</span><br><span class="line">    if (_obj != obj) &#123;</span><br><span class="line">        [_obj release];</span><br><span class="line">    &#125;</span><br><span class="line">    _obj = [obj retain];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断是为了防止异常处理，如果不做 if 判断，当传入的 obj 对象正好是原来的_obj 对象，对原对象尽行releas 操作，实际上也会对传入的对象进行releas 操作进行释放，此时如果再通过obj指针访问废弃的对象时就会导致carsh</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/iOS%20%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AETableHeaderView%E9%AB%98%E5%BA%A6/"/>
      <url>/2019/06/18/iOS%20%E5%8A%A8%E6%80%81%E8%AE%BE%E7%BD%AETableHeaderView%E9%AB%98%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="iOS动态设置tableHeaderView高度"><a href="#iOS动态设置tableHeaderView高度" class="headerlink" title="iOS动态设置tableHeaderView高度"></a>iOS动态设置<code>tableHeaderView</code>高度</h2><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>动态的设置<code>tableHeaderView</code>的高度</p><h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><ul><li>设置<code>tableHeaderView</code> 的<code>frame</code>无法实现，有时候会出现<code>tableView</code> 中间的 <code>cell</code> 不显示</li><li><p>有时候会导致<code>headerView</code>和<code>cell</code>内容重叠</p></li><li><p>通过计算控件高度设置frame方式麻烦</p></li></ul><h4 id="正确的步骤"><a href="#正确的步骤" class="headerlink" title="正确的步骤"></a>正确的步骤</h4><ul><li>创建HeaderView</li><li>取出<code>UITableView</code>的<code>tableHeaderView</code></li><li>设置<code>frame</code>大小，调整headerView布局</li><li>重新给<code>UITableView</code>的<code>tableHeaderView</code></li></ul><h4 id="使用AutoLayout"><a href="#使用AutoLayout" class="headerlink" title="使用AutoLayout"></a>使用AutoLayout</h4><p>给<code>UITableView</code>增加分类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension UITableView &#123;</span><br><span class="line">    /// set tableHeaderView</span><br><span class="line">    func setTableHeaderView(_ headerView: UIView) &#123;</span><br><span class="line">        headerView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">        self.tableHeaderView = headerView</span><br><span class="line">        // autolayout</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .width, relatedBy: .equal, toItem: self, attribute: .width, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">    &#125;</span><br><span class="line">    /// update</span><br><span class="line">    func updateHeaderView() &#123;</span><br><span class="line">        guard let headerView = self.tableHeaderView else &#123; return &#125;</span><br><span class="line">        headerView.layoutIfNeeded()</span><br><span class="line">        let header = self.tableHeaderView</span><br><span class="line">        self.tableHeaderView = header</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/iOS%E5%BC%80%E5%8F%91_%E4%BA%8E%E9%B8%BF%E9%B9%8F/"/>
      <url>/2019/06/18/iOS%E5%BC%80%E5%8F%91_%E4%BA%8E%E9%B8%BF%E9%B9%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="个人信息"><a href="#个人信息" class="headerlink" title="个人信息"></a>个人信息</h3><ul><li>于鸿鹏 | 男 | 27岁 | 本科 | 4年 iOS开发</li><li>手机: <strong>18513852394</strong></li><li>Email: <a href="mailto:**hongpeng03@icloud.com" target="_blank" rel="noopener">**hongpeng03@icloud.com</a>**</li></ul><h3 id="工作经历"><a href="#工作经历" class="headerlink" title="工作经历"></a>工作经历</h3><h3 id="猎聘网-2018-2-至今"><a href="#猎聘网-2018-2-至今" class="headerlink" title="猎聘网 (2018.2 ~ 至今)"></a>猎聘网 (2018.2 ~ 至今)</h3><p>Swift重构猎聘App中应聘记录模块，推进项目组使用AutoLayout技术，后期负责开发迭代乐班班项目，参与每版需求分析和主要代码编写，解决复杂功能页面卡顿，内存优化，BUG修复及iOS新特性适配等。</p><h3 id="北京万朝科技有限公司-2015-5-2018-2"><a href="#北京万朝科技有限公司-2015-5-2018-2" class="headerlink" title="北京万朝科技有限公司(2015.5 ~ 2018.2)"></a>北京万朝科技有限公司(2015.5 ~ 2018.2)</h3><p>在该项目中担任iOS开发⼯作，参与项目需求分析、核⼼代码编写以及常用工具类的封装，BUG修复，版本迭代更新，推进组内swift的使用。</p><h3 id="中盎炬华科技发展有限公司（2014-4月-2015-5）"><a href="#中盎炬华科技发展有限公司（2014-4月-2015-5）" class="headerlink" title="中盎炬华科技发展有限公司（2014.4月 ~ 2015.5）"></a>中盎炬华科技发展有限公司（2014.4月 ~ 2015.5）</h3><p>参与iOS客户端的开发维护完成开发工作，实现一些交互动画和效果；研究最新技术，优化程序代码，集成第三方SDK。</p><h3 id="项⽬经历"><a href="#项⽬经历" class="headerlink" title="项⽬经历"></a>项⽬经历</h3><h4 id="1-猎聘APP-2018-2-至今"><a href="#1-猎聘APP-2018-2-至今" class="headerlink" title="1. 猎聘APP (2018.2 ~ 至今)"></a>1. 猎聘APP (2018.2 ~ 至今)</h4><p><strong>项⽬目描述：</strong> 为中高端人才和经理人提供招聘的平台</p><ul><li>使用 swift 重构应聘记录模块中相关页面及功能</li><li>推进整个项目组使用 <code>AutoLayout</code> 技术</li></ul><h4 id="2-乐班班"><a href="#2-乐班班" class="headerlink" title="2. 乐班班"></a>2. 乐班班</h4><p><strong>项⽬目描述：</strong> 音/视频播放、直播，内购，即时通信等功能，由OC、Swift，RN 技术混编，项⽬应⽤技术</p><ul><li>使用ReactNative技术重构和开发部分页面</li><li>使用Xcode、Instruments工具查找、分析、解决项目内存泄露，修复BUG</li><li>Swift重构通信模块，用collectionView构建消息页面，自定义emoj Keyboard，封装常用UI控件，自定义控制器转场动画</li><li>使用AVFoundation 实现视频录制，上传，播放功能</li><li>通过<code>GCD dispatch semaphors</code> 解决并发网络请求问题</li><li>使用collectionView构建复杂的视频播放页面，企业大学首页</li></ul><h4 id="3-e蜂通信-2015-5-2018-2"><a href="#3-e蜂通信-2015-5-2018-2" class="headerlink" title="3. e蜂通信 (2015.5 ~ 2018.2)"></a>3. e蜂通信 (2015.5 ~ 2018.2)</h4><p><strong>项⽬目描述：</strong>整合了办公OA、CRM系统，新增即时通信、分享、远程监控、解密外发、红包、私聊等功能；由OC和swift混编, 项⽬目应⽤用技术:</p><ul><li>使⽤CocoaAsyncSocket自定义通信协议，实现聊天，特定业务消息触达功能</li><li>使⽤cocoaPod实现组件化，</li><li>封装swift基础库，完善swift和Objective-C混编</li><li>实现分享⼩视频、图片、点赞、评论功能 </li><li>⾃定义相机实现人脸识别打卡、扫描二维码功能</li><li>封装常⽤UI控件，使用Core Animation实现动画效果，集成百度地图SDK</li><li>利⽤JavaScriptCore完成H5和Native之间的交互</li></ul><h4 id="4-四万公里-2014-4-2015-5"><a href="#4-四万公里-2014-4-2015-5" class="headerlink" title="4. 四万公里 (2014.4 ~ 2015.5)"></a>4. 四万公里 (2014.4 ~ 2015.5)</h4><p><strong>项目描述：</strong>针对境外旅游群体提供便捷服务，项⽬目应⽤用技术:</p><ul><li>封装 TableViewController基类，对接服务端接口等</li><li>封装基础UI控件</li><li>集成科大讯飞SDK, 实现了实时翻译功能</li><li>集成滴滴打车SDK, 实现用户可在国外打车功能</li></ul><h3 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h3><ol><li>熟练使用Objective-C、Swift，及Swift与Objective-C混编，有良好的编程习惯</li><li>熟练掌握iOS内存管理机制以及ARC技术，结合Instruments对项目进行内存优化</li><li>熟练掌握NSThread/GCD/NSOperation等并发编程技术</li><li>熟练掌握iOS中事件链和响应链的传递方式</li><li>熟练使⽤AFNetworking，Moya，FMDB，SDWebImage，Masonry等第三⽅开源框架</li><li>熟练掌握各种UI控件封装，熟悉多视图开发，能实现复杂的界⾯面交互</li><li>掌握KVO原理理、KVC原理理、SDWebImage内部实现过程、RunLoop的应⽤</li><li>有团队开发经验，同时能够独立完成APP开发，代码编写，调试和发布</li></ol><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>工作之余了解使⽤ JavaScript，RxSwift 函数响应式编程，小程序开发等知识，经常关注iOS博客和<a href="https://github.com/aTreey?utf8=%E2%9C%93&amp;tab=repositories&amp;q=&amp;type=source&amp;language=">Github</a> 上优秀代码，以及在<a href="https://www.raywenderlich.com" target="_blank" rel="noopener">raywenderlich</a>上学习新知识，在<a href="https://atreey.github.io/" target="_blank" rel="noopener">个人博客</a>做些技术积累。 计划在iOS领域深⼊同时也扩展⾃己的知识⾯，了解使⽤后端和前端技术。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Xcode%E4%B8%AD%E4%BD%BF%E7%94%A8Debug%20Memory%20Graph%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
      <url>/2019/06/18/Xcode%E4%B8%AD%E4%BD%BF%E7%94%A8Debug%20Memory%20Graph%E6%A3%80%E6%9F%A5%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="Xcode中使用Debug-Memory-Graph检查内存泄漏"><a href="#Xcode中使用Debug-Memory-Graph检查内存泄漏" class="headerlink" title="Xcode中使用Debug Memory Graph检查内存泄漏"></a>Xcode中使用Debug Memory Graph检查内存泄漏</h1><h2 id="勾选如下图所示选项"><a href="#勾选如下图所示选项" class="headerlink" title="勾选如下图所示选项"></a>勾选如下图所示选项</h2><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1xy4gg3b5j31ds0s0q7u.jpg" alt></p><h2 id="运行程序后点击"><a href="#运行程序后点击" class="headerlink" title="运行程序后点击"></a>运行程序后点击</h2><p><img src="https://diycode.b0.upaiyun.com/photo/2018/18f8590ab4f9d33296a379a94ae94ccb.png" alt></p><h2 id="内存泄露定位"><a href="#内存泄露定位" class="headerlink" title="内存泄露定位"></a>内存泄露定位</h2><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1g1xyo08z80j31yu0u00zf.jpg" alt></p><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1g1xyovrs7kj321q0u0tln.jpg" alt></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/flutter%E5%AE%89%E8%A3%85/"/>
      <url>/2019/06/18/flutter%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<p>flutter安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 导入头文件</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; (MyApp());</span><br><span class="line"></span><br><span class="line">// 定义类, 继承</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // 重写</span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    // 返回一窗口</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title:&apos;Flutter&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(&apos;flutter 初体验&apos;)</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(&apos;flutter 学习之路&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // This widget is the root of your application.</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        // This is the theme of your application.</span><br><span class="line">        //</span><br><span class="line">        // Try running your application with &quot;flutter run&quot;. You&apos;ll see the</span><br><span class="line">        // application has a blue toolbar. Then, without quitting the app, try</span><br><span class="line">        // changing the primarySwatch below to Colors.green and then invoke</span><br><span class="line">        // &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;,</span><br><span class="line">        // or simply save your changes to &quot;hot reload&quot; in a Flutter IDE).</span><br><span class="line">        // Notice that the counter didn&apos;t reset back to zero; the application</span><br><span class="line">        // is not restarted.</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: &apos;Flutter Demo Home Page&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  // This widget is the home page of your application. It is stateful, meaning</span><br><span class="line">  // that it has a State object (defined below) that contains fields that affect</span><br><span class="line">  // how it looks.</span><br><span class="line"></span><br><span class="line">  // This class is the configuration for the state. It holds the values (in this</span><br><span class="line">  // case the title) provided by the parent (in this case the App widget) and</span><br><span class="line">  // used by the build method of the State. Fields in a Widget subclass are</span><br><span class="line">  // always marked &quot;final&quot;.</span><br><span class="line"></span><br><span class="line">  final String title;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  int _counter = 0;</span><br><span class="line"></span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // This call to setState tells the Flutter framework that something has</span><br><span class="line">      // changed in this State, which causes it to rerun the build method below</span><br><span class="line">      // so that the display can reflect the updated values. If we changed</span><br><span class="line">      // _counter without calling setState(), then the build method would not be</span><br><span class="line">      // called again, and so nothing would appear to happen.</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // This method is rerun every time setState is called, for instance as done</span><br><span class="line">    // by the _incrementCounter method above.</span><br><span class="line">    //</span><br><span class="line">    // The Flutter framework has been optimized to make rerunning build methods</span><br><span class="line">    // fast, so that you can just rebuild anything that needs updating rather</span><br><span class="line">    // than having to individually change instances of widgets.</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        // Here we take the value from the MyHomePage object that was created by</span><br><span class="line">        // the App.build method, and use it to set our appbar title.</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        // Center is a layout widget. It takes a single child and positions it</span><br><span class="line">        // in the middle of the parent.</span><br><span class="line">        child: Column(</span><br><span class="line">          // Column is also layout widget. It takes a list of children and</span><br><span class="line">          // arranges them vertically. By default, it sizes itself to fit its</span><br><span class="line">          // children horizontally, and tries to be as tall as its parent.</span><br><span class="line">          //</span><br><span class="line">          // Invoke &quot;debug painting&quot; (press &quot;p&quot; in the console, choose the</span><br><span class="line">          // &quot;Toggle Debug Paint&quot; action from the Flutter Inspector in Android</span><br><span class="line">          // Studio, or the &quot;Toggle Debug Paint&quot; command in Visual Studio Code)</span><br><span class="line">          // to see the wireframe for each widget.</span><br><span class="line">          //</span><br><span class="line">          // Column has various properties to control how it sizes itself and</span><br><span class="line">          // how it positions its children. Here we use mainAxisAlignment to</span><br><span class="line">          // center the children vertically; the main axis here is the vertical</span><br><span class="line">          // axis because Columns are vertical (the cross axis would be</span><br><span class="line">          // horizontal).</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              &apos;你可以点击按钮来修改文字，我是热重载的结果&apos;,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              &apos;$_counter&apos;,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: &apos;Increment&apos;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), // This trailing comma makes auto-formatting nicer for build methods.</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90RN/"/>
      <url>/2019/06/18/Swift%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90RN/</url>
      
        <content type="html"><![CDATA[<p>Swift已有项目中集成ReactNative</p><p>本教程针对于已经有的Swift项目集成ReactNative</p><h3 id="创建新的空目录"><a href="#创建新的空目录" class="headerlink" title="创建新的空目录"></a>创建新的空目录</h3><p>为了不影响原有的swift项目目录结构，建议先创建一个空的文件夹，例如<code>SwiftRN</code></p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fuymbnmjazj30vc0bqgm4.jpg" alt></p><h3 id="创建package-json文件"><a href="#创建package-json文件" class="headerlink" title="创建package.json文件"></a>创建package.json文件</h3><p>终端进入创建的<code>SwiftRN</code>文件目录下，创建package.json文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch package.json</span><br></pre></td></tr></table></figure><h5 id="修改package-json文件，指定各个版本"><a href="#修改package-json文件，指定各个版本" class="headerlink" title="修改package.json文件，指定各个版本"></a>修改package.json文件，指定各个版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;SwiftRN&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;private&quot;: true,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;react&quot;: &quot;16.3.1&quot;,</span><br><span class="line">    &quot;react-native&quot;: &quot;^0.56.0&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行npm-install"><a href="#执行npm-install" class="headerlink" title="执行npm install"></a>执行npm install</h5><p>在创建package.json所在的文件目录下执行，在此过程中可以遇到的错误可能较多</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><h5 id="添加index-js文件"><a href="#添加index-js文件" class="headerlink" title="添加index.js文件"></a>添加index.js文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch index.js</span><br></pre></td></tr></table></figure><h5 id="修改文件内容"><a href="#修改文件内容" class="headerlink" title="修改文件内容"></a>修改文件内容</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import &#123;</span><br><span class="line">    AppRegistry,</span><br><span class="line">    Text,</span><br><span class="line">    View,</span><br><span class="line">&#125; from &apos;react-native&apos;;</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">// 用于最后在项目中测试</span><br><span class="line">class SwiftRNHomeView extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;View style=&#123;&#123;backgroundColor:&apos;white&apos;&#125;&#125;&gt;</span><br><span class="line">                &lt;Text style=&#123;&#123;fontSize: 20, marginTop: 200&#125;&#125;&gt;Hellow world&lt;/Text&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyApp extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;SwiftRNHomeView&gt;&lt;/SwiftRNHomeView&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AppRegistry.registerComponent(&apos;SwiftRN&apos;, () =&gt; MyApp);</span><br></pre></td></tr></table></figure><h3 id="配置swift项目"><a href="#配置swift项目" class="headerlink" title="配置swift项目"></a>配置swift项目</h3><p>将新创建的Swift文件目录下的所有文件拷贝到Swift项目所在的根目录下</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdly1fuymlkt3lgj30no0giq3s.jpg" alt></p><h3 id="使用Pod集成RN"><a href="#使用Pod集成RN" class="headerlink" title="使用Pod集成RN"></a>使用Pod集成RN</h3><p>swift项目采用了pod管理第三方库，在Podfile文件中加入下面代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [</span><br><span class="line">    &apos;Core&apos;,</span><br><span class="line">    &apos;RCTText&apos;,</span><br><span class="line">    &apos;RCTNetwork&apos;,</span><br><span class="line">    &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的</span><br><span class="line">    &apos;CxxBridge&apos;, # Include this for RN &gt;= 0.47，不引入的话会报错误或者警告</span><br><span class="line">    &apos;DevSupport&apos;, # Include this to enable In-App Devmenu if RN &gt;= 0.43，不引入的话会报错误或者警告</span><br><span class="line">    &apos;RCTAnimation&apos;, 不引入的话会报错误或者警告</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 如果你的RN版本 &gt;= 0.42.0，请加入下面这行，不引入的话会报错误或者警告</span><br><span class="line">pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot;</span><br><span class="line">pod &apos;DoubleConversion&apos;, :podspec =&gt; &apos;./node_modules/react-native/third-party-podspecs/DoubleConversion.podspec&apos;</span><br><span class="line">pod &apos;glog&apos;, :podspec =&gt; &apos;./node_modules/react-native/third-party-podspecs/glog.podspec&apos;</span><br><span class="line">pod &apos;Folly&apos;, :podspec =&gt; &apos;./node_modules/react-native/third-party-podspecs/Folly.podspec&apos;</span><br></pre></td></tr></table></figure><h4 id="创建桥接文件"><a href="#创建桥接文件" class="headerlink" title="创建桥接文件"></a>创建桥接文件</h4><ul><li>如果原项目中有SwiftDemo-Bridging-Header.h类似这个文件可以跳过。</li><li>如果从来没有创建过桥接文件，创建一个OC的类会自动弹出是否需要创建桥接文件，直接创建即可，最后把无用的OC文件删掉</li></ul><h4 id="引用RN头文件"><a href="#引用RN头文件" class="headerlink" title="引用RN头文件"></a>引用RN头文件</h4><p>在桥接文件中导入头文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;React/RCTRootView.h&gt;</span><br><span class="line">#import &lt;React/RCTBundleURLProvider.h&gt;</span><br></pre></td></tr></table></figure><h4 id="使用RN页面"><a href="#使用RN页面" class="headerlink" title="使用RN页面"></a>使用RN页面</h4><p>在模拟器中使用RN的页面, 确保在 info.plist 文件中添加了<code>Allow Arbitrary Loads=YES</code>项</p><ul><li>moduleName 对应的名字和index.js中 AppRegistry.registerComponent(‘SwiftRN’, () =&gt; MyApp)注册的名字必须相同</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import UIKit</span><br><span class="line"></span><br><span class="line">class RNTestController: UIViewController &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        super.viewDidLoad()</span><br><span class="line">        let url = URL(string: &quot;http://localhost:8081/index.bundle?platform=ios&quot;)!</span><br><span class="line">        let rootView = RCTRootView(</span><br><span class="line">            bundleURL: url,</span><br><span class="line">            moduleName: &quot;SwiftRN&quot;, //这里的名字必须和AppRegistry.registerComponent(&apos;MyApp&apos;, () =&gt; MyApp)中注册的名字一样</span><br><span class="line">            initialProperties: nil,</span><br><span class="line">            launchOptions: nil</span><br><span class="line">        )</span><br><span class="line">        view = rootView</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2019/06/18/Swift%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Swift 中错误处理</p><h3 id="assert-断言"><a href="#assert-断言" class="headerlink" title="assert 断言"></a>assert 断言</h3><p>只在debug 模式下程序会自动退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func assert(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</span><br></pre></td></tr></table></figure><h3 id="assertionFailure-断言错误"><a href="#assertionFailure-断言错误" class="headerlink" title="assertionFailure 断言错误"></a>assertionFailure 断言错误</h3><p>只在debug 模式下程序会自动退出, 没有条件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func assertionFailure(_ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</span><br></pre></td></tr></table></figure><h3 id="precondition"><a href="#precondition" class="headerlink" title="precondition"></a>precondition</h3><p>releas 模式程序也会退出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public func precondition(_ condition: @autoclosure () -&gt; Bool, _ message: @autoclosure () -&gt; String = default, file: StaticString = #file, line: UInt = #line)</span><br></pre></td></tr></table></figure><h3 id="throw"><a href="#throw" class="headerlink" title="throw"></a>throw</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E6%B3%9B%E5%9E%8B/"/>
      <url>/2019/06/18/Swift%E6%B3%9B%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Swift-泛型"><a href="#Swift-泛型" class="headerlink" title="Swift 泛型"></a>Swift 泛型</h2><h3 id="泛型定义–wikipedia"><a href="#泛型定义–wikipedia" class="headerlink" title="泛型定义–wikipedia"></a>泛型定义–<code>wikipedia</code></h3><ol><li>在程序编码中一些包含类型参数的类型，也就是说泛型的参数只可以代表类，不能代表个别对象。（这是当今较常见的定义）</li><li>在程序编码中一些包含参数的类。其参数可以代表类或对象等等。（现在人们大多把这称作模板）</li></ol><h3 id="泛型的用处"><a href="#泛型的用处" class="headerlink" title="泛型的用处"></a>泛型的用处</h3><p>泛型可以实现传入一个指定类型后做一些操作然后返回后还是原来指定的类型，你可以指定特定的类型（特定是指约束）</p><h3 id="泛型和-Any-的区别"><a href="#泛型和-Any-的区别" class="headerlink" title="泛型和 Any 的区别"></a>泛型和 <code>Any</code> 的区别</h3><p>区别：<code>Any</code>能代表任何类型，但是不能返回某个具体的类型，都需要使用 as 去转化，而泛型正好相反</p><ul><li>Any 可以代表任何类型，除了class之外还可以代表struct，enum，</li><li><code>AnyObject</code> 可以代码任何 <code>class</code> 的类型, swift 中基本类型， <code>Array</code> 和 <code>Dictionary</code> 都是 <code>struct</code> 类型，都不能使用 <code>AnyObject</code> 来接受</li></ul><p><a href="http://swifter.tips/any-anyobject/" target="_blank" rel="noopener">Swift中Any 和 AnyObject用法</a></p><h3 id="泛型函数和泛型参数"><a href="#泛型函数和泛型参数" class="headerlink" title="泛型函数和泛型参数"></a>泛型函数和泛型参数</h3><p><code>swapTwoValues</code>是一个泛型函数，可以接收或者返回任何类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func swapTwoValues&lt;T&gt;(inout a: T, inout b: T) &#123;</span><br><span class="line">    let temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>swapTwoValues</code> 函数名后面的 <code>&lt;T&gt;</code> 表示这个 <code>T</code> 类型是函数所定义的一个类型, <code>T</code> 只是一个类型的占位符，不用关心具体类型</p></li><li><p><code>(inout a: T, inout b: T)</code> 中a和b两个参数类型<code>T</code>是泛型参数</p></li></ul><h3 id="类型约束"><a href="#类型约束" class="headerlink" title="类型约束"></a>类型约束</h3><p>两个泛型参数的泛型函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123;</span><br><span class="line">    // function body goes here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>泛型参数<code>T</code>约束条件：必须是<code>SomeClass</code>类的子类</li><li>泛型参数<code>U</code>约束条件：必须遵守<code>SomeProtocol</code>协议</li><li>使用where指定约束</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E5%8D%8F%E8%AE%AE%E5%88%AB%E5%90%8D/"/>
      <url>/2019/06/18/Swift%E5%8D%8F%E8%AE%AE%E5%88%AB%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>Swift协议和别名</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>某些属性的集合，可以有多个协议组成，具有的特点</p><ol><li>可以声明函数，但是不能实现，由实现这协议的具体结构或者类来实现</li><li>声明的函数如果有参数也不能设置参数的默认值， 默认参数被认为也是函的一种实现</li><li>可以声明属性，必须是计算型属性 只能使用var 修饰，不能是存储型属，必须在 {} 中明确指出属性的读取类型 例如 {get set}</li><li>遵守协议的类可选择存储型属性或者计算型属性来实现协议中定义的属性</li><li>protocol Person: class { } 表示此协议只能被类来遵守，结构体能遵守</li><li><p>协议可以看着是一种类型，如果协议中的属性是只读的，如果是协议类型只能访问get 方法， 但是遵守协议的具体类或者结构可以设置属性的读和写</p></li><li><p>协议中的构造函数</p><pre><code>- 如果父类中遵守了协议中的构造函数，子类中必须重写父类中的构造函数并且使用require修饰构造函数，表示继承此类的子类也必须实现该构造函数- 如果class 使用了final 修饰，表示不能被继承，此时不需要 require 关键词修饰</code></pre></li></ol><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul><li><p>定义别名 <code>typealias</code>, 供扩展使用</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typealias Length = Double</span><br><span class="line">extension Double &#123;</span><br><span class="line">    var km: Length &#123;return self * 1_000.0&#125;</span><br><span class="line">    var m: Length &#123;return self * 100.0&#125;</span><br><span class="line">    var cm: Length &#123;return self / 10.0&#125;</span><br><span class="line">    /// 英尺</span><br><span class="line">    var ft: Length &#123; return self / 3.28084&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let distance: Length = 10.5.km</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>定义别名防止硬编码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 音频采样率</span><br><span class="line">typealias AudioSample = UInt64</span><br></pre></td></tr></table></figure></li></ul><h3 id="协议中-typealias"><a href="#协议中-typealias" class="headerlink" title="协议中 typealias"></a>协议中 <code>typealias</code></h3><p><strong>协议中定义一个属性，该属性的类型根据不同的情况返回不同的类型（我理解为类似泛型），具体的类型由遵守此协议的类或者结构指定</strong></p><ul><li>定义协议中别名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">protocol WeightCalculable &#123;</span><br><span class="line">    // 属性重量根据不同体积返回的可能是Int，可以可能是double类型，所以使用别名, 协议中使用associatedtype关键词，</span><br><span class="line">    associatedtype WeightType</span><br><span class="line">    var weight: WeightType &#123;  get  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展 Int 中的吨单位</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    typealias Weight = Int</span><br><span class="line">    var t: Weight &#123;return self * 1_000&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用协议中别名</li></ul><ul><li>一部手机的时使用该协议<code>WeightCalculable</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class iPhone: WeightCalculable &#123;</span><br><span class="line">    typealias WeightType = Double</span><br><span class="line">    var weight: WeightType &#123;</span><br><span class="line">        return 0.5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一辆大卡时使用该协议<code>WeightCalculable</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Car: WeightCalculable &#123;</span><br><span class="line">    typealias WeightType = Int</span><br><span class="line">    let weight: WeightType</span><br><span class="line">    </span><br><span class="line">    init(weight: Int) &#123;</span><br><span class="line">        self.weight = weight</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let bigCar = Car(weight: 8_000.t) // 8 吨</span><br></pre></td></tr></table></figure><h3 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h3><ul><li>定义比赛协议，具有 赢/输/总场次/胜率 等特性</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">protocol Recordable: CustomStringConvertible &#123;</span><br><span class="line">    var wins: Int &#123; get &#125;</span><br><span class="line">    var losses: Int &#123; get &#125;</span><br><span class="line">    </span><br><span class="line">    func winningPerent() -&gt; Double</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>协议中方法或者属性的默认实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">extension Recordable &#123;</span><br><span class="line">// CustomStringConvertible 协议默认实现</span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return String(format: &quot;WINS: %d---LOSSES: %d&quot;, [wins, losses])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 默认实现总场数计算型属性</span><br><span class="line">    var totalGames: Int &#123;</span><br><span class="line">        return wins + losses</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 默认实现的方法</span><br><span class="line">    func shoutWins() &#123;</span><br><span class="line">        print(&quot;come on&quot;, wins, &quot;times!&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="篮球比赛："><a href="#篮球比赛：" class="headerlink" title="篮球比赛："></a>篮球比赛：</h4><ul><li>Equatable 协议 - 相等比较 需要重载 <code>==</code></li><li>Comparable 协议 - 是否可比较 ，重载 <code>&lt;</code> 可直接调用sort()函数</li><li>CustomStringConvertible 协议 - 打印信息，需重写 <code>description</code></li><li>Recordable协议 - 比赛协议，没有平局 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">struct BasketballRecord:Equatable, Comparable, CustomStringConvertible, Recordable &#123;</span><br><span class="line">    var wins: Int</span><br><span class="line">    var losses: Int</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /// 在具体定义的类型中实现 协议中的属性或者方法就会覆盖协议中的</span><br><span class="line">    var totalGames: Int = 200</span><br><span class="line">    </span><br><span class="line">    var description: String &#123;</span><br><span class="line">        return &quot;本次比赛胜: &quot; + String(wins) + &quot;负&quot; + &quot;\(losses)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 胜率</span><br><span class="line">    func winningPerent() -&gt; Double &#123;</span><br><span class="line">        return (Double(wins) / Double(totalGames))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // swift4.1 后，不需要再重写此方法，swift 会自动合成，如果不想让某一个属性参与比较，就需要重写该方法</span><br><span class="line">    static func == (lhs: BasketballRecord, rhs: BasketballRecord) -&gt; Bool &#123;</span><br><span class="line">        return lhs.wins == rhs.wins &amp;&amp; lhs.losses == rhs.losses</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Comparable</span><br><span class="line">    static func &lt; (lhs: BasketballRecord, rhs: BasketballRecord) -&gt; Bool &#123;</span><br><span class="line">        if lhs.wins != rhs.wins &#123;</span><br><span class="line">            return lhs.wins &lt; rhs.wins</span><br><span class="line">        &#125;</span><br><span class="line">        return lhs.losses &gt; rhs.losses</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">#### 足球比赛：</span><br><span class="line"></span><br><span class="line">有平局的情况，原来的协议不能满足，需要增加一个平局的协议</span><br><span class="line"></span><br><span class="line">- 定义平局协议</span><br></pre></td></tr></table></figure><p>protocol Tieable {<br>    /// 平局，可读写<br>    var ties: Int { get set }</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 足球比赛需要遵守的协议 `Recordable` 和 `Tieable`</span><br><span class="line"></span><br><span class="line">- 总场数需要加上平局的场数，需要实现totalGames的get方法</span><br></pre></td></tr></table></figure></p><p>struct FootableRecord: Recordable, Tieable {<br>    var wins: Int<br>    var losses: Int<br>    // 平局数<br>    var ties: Int</p><pre><code>// 总场数var totalGames: Int {    return wins + losses + ties}var description: String {    return &quot;本次比赛胜: &quot; + String(wins) + &quot;负&quot; + &quot;\(losses)&quot;}func winningPerent() -&gt; Double {    return (Double(wins) / Double(totalGames))}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 足球比赛中以上写法存在的问题</span><br><span class="line"></span><br><span class="line">- 所有有平局的比赛计算总场次的逻辑都是一样，每次都要写一次实现</span><br><span class="line">- 单一修改 Recordable 协议不能解决问题，</span><br><span class="line">- 存在平局和没有平局两种情况 totalGames 的计算逻辑不相同 </span><br><span class="line"></span><br><span class="line">- 解决办法：</span><br><span class="line">- 扩展遵守了`Recordable`协议的类型，前提条件是：这个类型遵守了 Tieable 同时也遵守了 `Recordable ` 协议，可以理解为如果该类型遵守了 `Tieable `协议之后，`Recordable` 协议中的 totalGames 属性实现是另一种方式了，不在是以前的 `totalGames` 中直接返回 `wins + losses` 的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">定义协议</span><br></pre></td></tr></table></figure></p><p>protocol Recordable: CustomStringConvertible {<br>    var wins: Int { get }<br>    var losses: Int { get }</p><pre><code>func winningPerent() -&gt; Double</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">协议默认实现</span><br></pre></td></tr></table></figure></p><p>extension Recordable {<br>    var description: String {<br>        return String(format: “WINS: %d—LOSSES: %d”, [wins, losses])<br>    }</p><pre><code>// 默认实现总场数计算型属性var totalGames: Int {    return wins + losses}// 默认实现胜率func winningPerent() -&gt; Double {    return (Double(wins) / Double(totalGames))}// 默认实现的方法func shoutWins() {    print(&quot;come on&quot;, wins, &quot;times!&quot;)}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">扩展遵守了Tieable 的 类型的 Recordable 协议</span><br></pre></td></tr></table></figure><p>extension Recordable where Self: Tieable {<br>    var totalGames: Int {<br>        return wins + losses + ties<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 协议聚合</span><br><span class="line"></span><br><span class="line">如果对某一类型需要限制他必须遵守某些协议，可以使用协议聚合来定义</span><br><span class="line"></span><br><span class="line">比如： 有个奖赏协议</span><br></pre></td></tr></table></figure><p>protocol Prizable {<br>    func isPrizable() -&gt; Bool<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">篮球比赛遵守此协议</span><br></pre></td></tr></table></figure><p>// 篮球比赛奖赏<br>extension BasketballRecord: Prizable {<br>    func isPrizable() -&gt; Bool {<br>        return totalGames &gt; 10 &amp;&amp; winningPerent() &gt; 0.5<br>    }<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">足球比赛奖赏遵守此协议</span><br></pre></td></tr></table></figure><p>extension FootableRecord: Prizable {<br>    func isPrizable() -&gt; Bool {<br>        return wins &gt; 1<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">现在有某一个学生也遵守了此协议</span><br></pre></td></tr></table></figure></p><p>struct Student: Prizable {<br>    var name: String<br>    var score: Int</p><pre><code>func isPrizable() -&gt; Bool {    return score &gt;= 60}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">定义奖赏的方法，参数类型必须是遵守了此协议的结构或者类型</span><br></pre></td></tr></table></figure><p>private func award(_ one: Prizable) {<br>    if one.isPrizable() {<br>        print(one)<br>        print(“恭喜获得奖励”)<br>    } else {<br>        print(one)<br>        print(“很遗憾”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果说 BasketballRecord 这个类还遵守了其他的协议，例如遵守了 `Recordable` 协议， 并且这个协议也遵守了 `CustomStringConvertible` 并且默认实现了`description` 的`get` 方法</span><br></pre></td></tr></table></figure></p><p>// MARK: - 比赛协议，具有 赢。输。总场次。胜率 特性<br>protocol Recordable: CustomStringConvertible {<br>    var wins: Int { get }<br>    var losses: Int { get }</p><pre><code>func winningPerent() -&gt; Double</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`Recordable` 默认实现</span><br></pre></td></tr></table></figure><p>extension Recordable {<br>    var description: String {<br>        return String(format: “WINS: %d—LOSSES: %d”, [wins, losses])<br>    }</p><pre><code>// 默认实现总场数计算型属性var totalGames: Int {    return wins + losses}// 默认实现胜率func winningPerent() -&gt; Double {    return (Double(wins) / Double(totalGames))}// 默认实现的方法func shoutWins() {    print(&quot;come on&quot;, wins, &quot;times!&quot;)}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">此时如果 `Student` 类还是调用 `award` 方法的话，print(one) 打印的信息将是`Recordable `中默认实现的内容，因此需要约束`award`函数的参数必须遵守两个协议让`Student` 也重写自己的`description `属性的`get`方法，不能再让 `Prizable` 扩展 默认实现</span><br><span class="line"></span><br><span class="line">- swift 3 写法： protocol&lt;A, B&gt;</span><br><span class="line">- swift 4 写法： A &amp; B</span><br></pre></td></tr></table></figure></p><p>private func award2(_ one: Prizable &amp; CustomStringConvertible) {<br>    if one.isPrizable() {<br>        print(one)<br>        print(“恭喜获得奖励”)<br>    } else {<br>        print(one)<br>        print(“很遗憾”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 泛型约束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-  定义一个函数，找出一个学生数组中分数最大的</span><br><span class="line">- 参数：一个学生数组，都遵守了 Comparable 的类型</span><br><span class="line">- 返回值：某个遵守了 Comparable 的类型实例</span><br><span class="line">   - 此时函数报错 `Protocol &apos;Comparable&apos; can only be used as a generic constraint because it has Self or associated type requirements`, </span><br><span class="line">   </span><br><span class="line">   因为 Comparable 协议中定义的方法  public static func &lt; (lhs: Self, rhs: Self) -&gt; Bool 的参数类型是Self，是具体的某个类型</span><br></pre></td></tr></table></figure></p><p>func maxScore(seq: [Comparable]) -&gt; Comparable { }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">- 如果需要定义一个函数实现在一个数组中找出需要奖励的人的名字该如何实现呢</span><br><span class="line">- 参数：遵守两个协议 Comparable 和 Prizable 协议, 并且使用泛型</span><br><span class="line">- 返回值：返回值是可选值，有可能没有任何奖励的对象</span><br></pre></td></tr></table></figure></p><p>func topPrizable&lt;T: Comparable &amp; Prizable&gt;(seq: [T]) -&gt; T? {<br>    return seq.reduce(nil) { (tempTop: T?, condender: T) in<br>        guard condender.isPrizable() else { return tempTop }<br>        // 解包 condender 失败, 上一层验证了他必须是奖励的那个<br>        guard let tempTop = tempTop else { return condender }<br>        return max(tempTop, condender)<br>    }<br>}</p><p><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95/"/>
      <url>/2019/06/18/Swift%E5%8D%8F%E8%AE%AE%E6%89%A9%E5%B1%95/</url>
      
        <content type="html"><![CDATA[<p>Swift协议扩展</p><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct Point &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    var y = 0.0</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Size &#123;</span><br><span class="line">    var height = 0.0</span><br><span class="line">    var width = 0.0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct Rectangle &#123;</span><br><span class="line">    var origin = Point()</span><br><span class="line">    var size = Size()</span><br><span class="line">    </span><br><span class="line">    init(origin: Point, size: Size) &#123;</span><br><span class="line">        self.origin = origin</span><br><span class="line">        self.size = size</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>扩展方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Rectangle &#123;</span><br><span class="line">    mutating func translate(x: Double, y: Double) &#123;</span><br><span class="line">        self.origin.x += x</span><br><span class="line">        self.origin.y += y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只能扩展计算型的属性，不能扩展存储型属性, 存储型属性需要在定义类或者结构体时声明</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">extension Rectangle &#123;</span><br><span class="line">    var center: Point &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            let center_x = origin.x + size.width / 2.0</span><br><span class="line">            let center_y = origin.y + size.height / 2.0</span><br><span class="line">            return Point(x: center_x, y: center_y)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set &#123;</span><br><span class="line">            origin.x = newValue.x - size.width / 2.0</span><br><span class="line">            origin.y = newValue.y - size.height / 2.0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>扩展构造方法</p><ul><li>类中不能扩展指定构造方法，只能在结构体中扩展</li><li>结构体中不能扩展便利构造方法m，只能在类中扩展</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">extension Rectangle &#123;</span><br><span class="line">    init(center: Point, size: Size) &#123;</span><br><span class="line">        let origin_x = center.x - size.width / 2.0</span><br><span class="line">        let origin_y = center.y - size.height / 2.0</span><br><span class="line">        self.origin = Point(x: origin_x, y: origin_y)</span><br><span class="line">        self.size = size</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 结构体中不能扩展便利构造函数 Delegating initializers in structs are not marked with &apos;convenience&apos;</span><br><span class="line">//    convenience init(center: Point, size: Size) &#123;</span><br><span class="line">//        let origin_x = center.x - size.width / 2.0</span><br><span class="line">//        let origin_y = center.y - size.height / 2.0</span><br><span class="line">//        self.origin = Point(x: origin_x, y: origin_y)</span><br><span class="line">//        self.size = size</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展嵌套类型</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">extension Rectangle &#123;</span><br><span class="line">    enum Vertex: Int &#123;</span><br><span class="line">        case left_top</span><br><span class="line">        case left_bottom</span><br><span class="line">        case right_bottom</span><br><span class="line">        case right_top</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 获取某一个顶点坐标</span><br><span class="line">    func point(of vertex: Vertex) -&gt; Point &#123;</span><br><span class="line">        switch vertex &#123;</span><br><span class="line">        case .left_top:</span><br><span class="line">            return origin</span><br><span class="line">        case .left_bottom:</span><br><span class="line">            return Point(x: origin.x, y: origin.y + size.height)</span><br><span class="line">        case .right_bottom:</span><br><span class="line">            return Point(x: origin.x + size.width, y: origin.y + size.height)</span><br><span class="line">        case .right_top:</span><br><span class="line">            return Point(x: origin.x + size.width, y: origin.y)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>扩展下标,根据传入的索引获取对应顶点坐标</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extension Rectangle &#123;</span><br><span class="line">    subscript(index: Int) -&gt; Point? &#123;</span><br><span class="line">        assert(0 &lt;= index &amp;&amp; index &lt; 4, &quot;传入值非法&quot;)</span><br><span class="line">        return point(of: Vertex(rawValue: index)!)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="扩展系统方法"><a href="#扩展系统方法" class="headerlink" title="扩展系统方法"></a>扩展系统方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">extension Int &#123;</span><br><span class="line">    /// 平方</span><br><span class="line">    var square: Int &#123;</span><br><span class="line">        return self * self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 立方</span><br><span class="line">    var cube: Int &#123;</span><br><span class="line">        return self * self * self</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 判断数组是否在某一个范围内</span><br><span class="line">    func inRange(clousedLeft left: Int, openRight right: Int) -&gt; Bool &#123;</span><br><span class="line">        return self &gt;= left &amp;&amp; self &gt; right</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 重复执行操作</span><br><span class="line">    func repeatitions(task: () -&gt; ()) &#123;</span><br><span class="line">        for _ in 0..&lt;self &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 变长函数</span><br><span class="line">    func stride(from: Int, to: Int, by: Int, task: () -&gt; ()) &#123;</span><br><span class="line">        // 系统变长函数</span><br><span class="line">        for i in Swift.stride(from: 0, to: 21, by: 3) &#123;</span><br><span class="line">            print(i)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for _ in Swift.stride(from: from, to: to, by: by) &#123;</span><br><span class="line">            task()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩展后使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">print(2.square)</span><br><span class="line">print(3.cube)</span><br><span class="line">print(4.inRange(clousedLeft: 0, openRight: 4))</span><br><span class="line">4.repeatitions &#123;</span><br><span class="line">    print(&quot;extension&quot;)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">// 使用变长函数</span><br><span class="line">4.stride(from: 0, to: 8, by: 4) &#123;</span><br><span class="line">    print(&quot;stride&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/SwiftLint%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/18/SwiftLint%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>SwiftLint 将 swift 强制检查代码风格</p><p><a href="https://github.com/realm/SwiftLint/blob/master/README_CN.md">教程</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%E4%B8%8B%E6%A0%87%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"/>
      <url>/2019/06/18/Swift%E4%B8%8B%E6%A0%87%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<p>Swift下标和运算符重载</p><h3 id="字典数组下标"><a href="#字典数组下标" class="headerlink" title="字典数组下标"></a>字典数组下标</h3><pre><code>var array = [1,2,3,4,5,6]let temp = array[0]     // 通过下标访问let temp2 = array[2]    // 通过下标访问</code></pre><h3 id="结构体下标"><a href="#结构体下标" class="headerlink" title="结构体下标"></a>结构体下标</h3><ul><li><p>对于结构体不是直接使用下标访问，会直接报错<br>直接使用下标获取属性值报错： <code>Type &#39;Vector_3&#39; has no subscript members</code></p></li><li><p>可以通过实现 <code>subscript(index: Int) -&gt; Double?</code>方法让结构体支持下标访问，可以理解为一个特殊的函数，需要传入参数和返回值</p></li><li>可以增加第二种下标–根据坐标轴获取属性值</li><li>重写 subscript 的 set 方法 可以使用下标修改属性值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">struct Vector_3 &#123;</span><br><span class="line">    var x = 0.0</span><br><span class="line">    var y = 0.0</span><br><span class="line">    var z = 0.0</span><br><span class="line">    </span><br><span class="line">    // 根据索引获取</span><br><span class="line">    subscript(index: Int) -&gt; Double? &#123;</span><br><span class="line">        </span><br><span class="line">        // 重写了get方法 实现通过下标获取属性值</span><br><span class="line">        get &#123;</span><br><span class="line">            switch index &#123;</span><br><span class="line">            case 0: return x</span><br><span class="line">            case 1: return y</span><br><span class="line">            case 2: return z</span><br><span class="line">            default: return nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 重写 set 方法，实现g通过下标设置属性值，使用系统默认的newValue</span><br><span class="line">        set &#123;</span><br><span class="line">            guard let newValue = newValue else &#123;return&#125;</span><br><span class="line">            switch index &#123;</span><br><span class="line">            case 0: x = newValue</span><br><span class="line">            case 1: y = newValue</span><br><span class="line">            case 2: z = newValue</span><br><span class="line">            default: return</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    // 增加第二种下标--根据坐标轴获取属性值</span><br><span class="line">    subscript(axis: String) -&gt; Double? &#123;</span><br><span class="line">        </span><br><span class="line">        get &#123;</span><br><span class="line">            switch axis &#123;</span><br><span class="line">            case &quot;X&quot;, &quot;x&quot;: return x</span><br><span class="line">            case &quot;Y&quot;, &quot;y&quot;: return y</span><br><span class="line">            case &quot;Z&quot;, &quot;z&quot;: return z</span><br><span class="line">            default: return nil</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set &#123;</span><br><span class="line">            guard let newValue = newValue else &#123;return&#125;</span><br><span class="line">            switch axis &#123;</span><br><span class="line">            case &quot;X&quot;, &quot;x&quot;: x = newValue</span><br><span class="line">            case &quot;Y&quot;, &quot;y&quot;: y = newValue</span><br><span class="line">            case &quot;Z&quot;, &quot;z&quot;: z = newValue</span><br><span class="line">            default: return</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">### 下标访问</span><br><span class="line"></span><br><span class="line">结构体使用下标获取值</span><br></pre></td></tr></table></figure><p>var v = Vector_3(x: 1, y: 2, z: 3)<br>print(v[0], v[1], v[2], v[3], v[100]) // Optional(1.0) Optional(2.0) Optional(3.0) nil nil<br>print(v[“x”], v[“y”], v[“z”], v[“i”]) // Optional(1.0) Optional(2.0) Optional(3.0) nil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">结构体使用下标修改值</span><br></pre></td></tr></table></figure><p>v[0] = 101<br>v[1] = 202<br>v[2] = 303<br>v[3] = 400<br>v[100] = 51<br>print(v[0], v[1], v[2], v[3], v[100]) // Optional(101.0) Optional(202.0) Optional(303.0) nil nil<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></p><p>v[“x”] = 100<br>v[“y”] = 200<br>v[“z”] = 300<br>v[“i”] = 50<br>print(v[“x”], v[“y”], v[“z”], v[“i”]) // Optional(100.0) Optional(200.0) Optional(300.0) nil</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 多维下标</span><br><span class="line"></span><br><span class="line">定义一个关于矩阵的结构体</span><br><span class="line"></span><br><span class="line">struct Matrix &#123;</span><br><span class="line">    var data: [[Double]]</span><br><span class="line">    let row: Int</span><br><span class="line">    let column: Int</span><br><span class="line">    </span><br><span class="line">    init(row: Int, column: Int) &#123;</span><br><span class="line">        self.row = row</span><br><span class="line">        self.column = column</span><br><span class="line">        data = [[Double]]()</span><br><span class="line">        for _ in 0..&lt;row &#123;</span><br><span class="line">            let aRow = Array(repeating: 1.0, count: column)</span><br><span class="line">            data.append(aRow)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 通过下标 [row,column] 方式访问</span><br><span class="line">    subscript(row: Int, column: Int) -&gt; Double &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            assert(row &gt;= 0 &amp;&amp; row &lt; self.row &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; self.column, &quot;下标不合法&quot;)</span><br><span class="line">            return data[row][column]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set &#123;</span><br><span class="line">            assert(row &gt;= 0 &amp;&amp; row &lt; self.row &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; self.column, &quot;下标不合法&quot;)</span><br><span class="line">            data[row][column] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 通过下标 [row][column] 方式访问</span><br><span class="line">    subscript(row: Int) -&gt; [Double] &#123;</span><br><span class="line">        get &#123;</span><br><span class="line">            assert(row &gt;= 0 &amp;&amp; row &lt; self.row, &quot;下标不合法&quot;)</span><br><span class="line">            // 直接返回数组，数组本身有下标</span><br><span class="line">            return data[row]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set &#123;</span><br><span class="line">            assert(newValue.count == column, &quot;下标不合法&quot;)</span><br><span class="line">            data[row] = newValue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">### 运算符重载</span><br><span class="line"> </span><br><span class="line">- 重载 + 运算符</span><br></pre></td></tr></table></figure><p>func +(one: Vector_3, other: Vector_3) -&gt; Vector_3 {<br>    return Vector_3(x: one[0]! + other[0]!, y: one[1]! + other[1]!, z: one[2]! + other[2]!)</p><p>//    return Vector_3(x: one.x + other.x, y: one.y + other.y, z: one.z + other.z)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 两个参数时相减</span><br></pre></td></tr></table></figure><p>func -(one: Vector_3, other: Vector_3) -&gt; Vector_3 {<br>    return Vector_3(x: one.x - other.x, y: one.y - other.y, z: one.z - other.z)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 一个参数时去反, 需要 prefix 修饰</span><br></pre></td></tr></table></figure><p>prefix func -(a: Vector_3) -&gt; Vector_3 {<br>    return Vector_3(x: -a.x, y: -a.y, z: -a.z)<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 向量相乘/向量和常量相乘</span><br></pre></td></tr></table></figure></p><p>func <em>(one: Vector_3, other: Vector_3) -&gt; Double {<br>    return (one.x </em> other.x) + (one.y <em> other.y) + (one.z </em> other.z)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 两个参数不能交换，需要重载两次 `*`</span><br></pre></td></tr></table></figure><p>func <em>(one: Vector_3, a: Double) -&gt; Vector_3 {<br>    return Vector_3(x: a </em> one.x, y: a <em> one.y, z: a </em> one.z)<br>}</p><p>func <em>(a: Double, one: Vector_3) -&gt; Vector_3 {<br>    return one </em> a</p><pre><code>// 也可采用下面写法</code></pre><p>//    return Vector_3(x: a <em> one.x, y: a </em> one.y, z: a * one.z)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 修改自身参数，不需要返回值</span><br></pre></td></tr></table></figure><p>func +=(one: inout Vector_3, other: Vector_3) {<br>    // 已经重载过 + 运算符，可以直接调用<br>    one = one + other<br>}</p><p>func ==(one: Vector_3, other: Vector_3) -&gt; Bool {<br>    return one.x == other.x &amp;&amp;<br>            one.y == other.y &amp;&amp;<br>            one.z == other.z<br>}</p><p>func !=(one: Vector_3, other: Vector_3) -&gt; Bool {<br>    return !(one == other)</p><pre><code>// 也可采用下面写法return one.x != other.x ||        one.y != other.y ||        one.z != other.z</code></pre><p>}</p><p>func &lt;(one: Vector_3, other: Vector_3) -&gt; Bool {<br>    if one.x != other.x {return one.x &lt; other.x}<br>    if one.y != other.y {return one.y &lt; other.y}<br>    if one.z != other.z {return one.z &lt; other.z}<br>    return false<br>}</p><p>func &lt;=(one: Vector_3, other: Vector_3) -&gt; Bool {<br>    return one &lt; other || one == other</p><pre><code>// 也可采用下面写法return one.x &gt; other.x &amp;&amp;        one.y &gt; other.x &amp;&amp;        one.z &gt; other.z</code></pre><p>}</p><p>func &gt;(one: Vector_3, other: Vector_3) -&gt; Bool {<br>    return (one &lt;= other)<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 自定义操作符</span><br><span class="line"></span><br><span class="line">`postfix` 声明前后缀关键词， `operator ` 操作符关键词</span><br><span class="line"></span><br><span class="line">- a+++</span><br></pre></td></tr></table></figure><p>声明后置操作符<br>postfix operator +++<br>postfix func +++(vector: inout Vector_3) -&gt; Vector_3 {<br>    vector += Vector_3(x: 1.0, y: 1.0, z: 1.0)<br>    return vector<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- +++a</span><br></pre></td></tr></table></figure><p>// 声明前置操作符<br>prefix operator +++<br>prefix func +++(vector: inout Vector_3) -&gt; Vector_3 {<br>    let temp = vector<br>    vector += Vector_3(x: 1.0, y: 1.0, z: 1.0)<br>    return temp<br>}</p><p><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%20%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/18/Swift%20%E5%8D%8F%E8%AE%AE%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Swift-协议使用"><a href="#Swift-协议使用" class="headerlink" title="Swift 协议使用"></a>Swift 协议使用</h1><h2 id="对UIView-扩展"><a href="#对UIView-扩展" class="headerlink" title="对UIView 扩展"></a>对UIView 扩展</h2><h3 id="按钮-文本框抖动动画"><a href="#按钮-文本框抖动动画" class="headerlink" title="按钮/文本框抖动动画"></a>按钮/文本框抖动动画</h3><ul><li><p>声明协议</p><ul><li><p>协议中定义属性：遵循该协议的类型都具有此属性</p><ul><li>必须明确规定该属性是可读的 <code>{get}</code> 或者可写的 <code>{set}</code>，或是可读可写的 <code>{get set}</code></li><li>使用static修饰声明一个类类型属性</li></ul></li><li><p>协议中定义方法</p></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">protocol Shakable &#123;&#125;</span><br><span class="line">extension Shakable where Self: UIView &#123;</span><br><span class="line">    func shakeAnimation() &#123;</span><br><span class="line">        let animation = CABasicAnimation(keyPath: &quot;position&quot;)</span><br><span class="line">        animation.duration = 0.08</span><br><span class="line">        animation.repeatCount = 5</span><br><span class="line">        animation.autoreverses = true</span><br><span class="line">        animation.fromValue = NSValue(cgPoint: CGPoint(x: self.center.x - 4, y: self.center.y))</span><br><span class="line">        animation.toValue = NSValue(cgPoint: CGPoint(x: self.center.x + 4, y: self.center.y))</span><br><span class="line">        layer.add(animation, forKey: &quot;position&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>自定义UI控件并遵守协议</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MyButton: UIButton, Shakable &#123;  &#125;</span><br><span class="line">class MySwitch: UISwitch, Shakable &#123;  &#125;</span><br><span class="line">class MyTextField: UITextField, Shakable &#123;  &#125;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let mySwitch = MySwitch()</span><br><span class="line">mySwitch.isOn = true</span><br><span class="line">self.mySwitch = mySwitch</span><br><span class="line">view.addSubview(mySwitch)</span><br><span class="line">mySwitch.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">mySwitch.topAnchor.constraint(equalTo: view.bottomAnchor, constant: 10).isActive = true</span><br><span class="line">mySwitch.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 10).isActive = true</span><br><span class="line"></span><br><span class="line">// 调用</span><br><span class="line">mySwitch.shakeAnimation()</span><br></pre></td></tr></table></figure><h2 id="UITableViewCell使用"><a href="#UITableViewCell使用" class="headerlink" title="UITableViewCell使用"></a>UITableViewCell使用</h2><h3 id="定义协议"><a href="#定义协议" class="headerlink" title="定义协议"></a>定义协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">protocol ReusableView: class &#123;&#125;</span><br><span class="line"></span><br><span class="line">extension ReusableView where Self: UIView &#123;</span><br><span class="line">    static var reuseIdentifier: String &#123;</span><br><span class="line">        return String(describing: self)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 对tableView扩展</span><br></pre></td></tr></table></figure><p>extension UITableView {<br>    /// 注册cell<br>    func register&lt;T: UITableViewCell&gt;(T: T.Type) where T: ReusableView {<br>        print(T.reuseIdentifier)<br>        self.register(T.self, forCellReuseIdentifier: T.reuseIdentifier)<br>    }</p><pre><code>/// 调用cellfunc dequeueReusableCell&lt;T: UITableViewCell&gt;(_ indexPath: IndexPath) -&gt; T where T: ReusableView {    print(T.reuseIdentifier)    return self.dequeueReusableCell(withIdentifier: T.reuseIdentifier, for: indexPath) as! T}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 用法</span><br><span class="line"></span><br><span class="line">- 创建自定义的cell，需要遵守协议</span><br></pre></td></tr></table></figure></p><p>class TableProtocolCell: UITableViewCell, ReusableView {<br>    override var reuseIdentifier: String? {<br>        return “cell”<br>    }<br>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {<br>        super.init(style: style, reuseIdentifier: reuseIdentifier)<br>        self.backgroundColor = .cyan<br>        self.textLabel?.text = “通过协议和泛型创建的cell”<br>        self.textLabel?.textColor = .blue<br>    }<br>    required init?(coder aDecoder: NSCoder) {<br>        fatalError(“init(coder:) has not been implemented”)<br>    }<br>}</p><p>class TableProtocolCell2: UITableViewCell, ReusableView {<br>    override init(style: UITableViewCellStyle, reuseIdentifier: String?) {<br>        super.init(style: style, reuseIdentifier: reuseIdentifier)<br>        self.backgroundColor = .red<br>        self.textLabel?.text = “cell1 - 通过协议和泛型创建的”<br>        self.textLabel?.textAlignment = .right<br>    }<br>    required init?(coder aDecoder: NSCoder) {<br>        fatalError(“init(coder:) has not been implemented”)<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注册和使用</span><br></pre></td></tr></table></figure></p><p>class TableViewProtocolController: UITableViewController {<br>    override func viewDidLoad() {<br>        super.viewDidLoad()<br>        tableView.register(T: TableProtocolCell.self)<br>        tableView.register(T: TableProtocolCell2.self)<br>    }</p><pre><code>override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int {    return 10}override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell {    var cell = UITableViewCell()    if indexPath.row % 2 == 0 {        cell = tableView.dequeueReusableCell(indexPath) as TableProtocolCell    } else {        cell = tableView.dequeueReusableCell(indexPath) as TableProtocolCell2    }    return cell}</code></pre><p>}</p><p><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Swift%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/06/18/Swift%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>Swift 学习</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h4 id="1-定义-rawValue-为-Int-类型，初始值为1，"><a href="#1-定义-rawValue-为-Int-类型，初始值为1，" class="headerlink" title="1. 定义 rawValue 为 Int 类型，初始值为1，"></a>1. 定义 rawValue 为 Int 类型，初始值为1，</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum Month: Int &#123;</span><br><span class="line">    case January = 1</span><br><span class="line">    case February</span><br><span class="line">    case March</span><br><span class="line">    case April</span><br><span class="line">    case May</span><br><span class="line">    case June</span><br><span class="line">    case July</span><br><span class="line">    case August</span><br><span class="line">    case September</span><br><span class="line">    case October</span><br><span class="line">    case November</span><br><span class="line">    case December</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-rawValue-的整型值可以不连续"><a href="#2-rawValue-的整型值可以不连续" class="headerlink" title="2. rawValue 的整型值可以不连续"></a>2. rawValue 的整型值可以不连续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Season: Int &#123;</span><br><span class="line">    case Spring = 1</span><br><span class="line">    case Summer = 5</span><br><span class="line">    case Autumn = 10</span><br><span class="line">    case Winter = 40</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-枚举可以是字符串-字符串是变量名和-rawValue-的值相等"><a href="#3-枚举可以是字符串-字符串是变量名和-rawValue-的值相等" class="headerlink" title="3. 枚举可以是字符串,字符串是变量名和 rawValue 的值相等"></a>3. 枚举可以是字符串,字符串是<code>变量名</code>和 <code>rawValue</code> 的值相等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum ProgrammerLanguae: String &#123;</span><br><span class="line">    case Swift</span><br><span class="line">    case OC = &quot;Objective-C&quot;</span><br><span class="line">    case C = &quot;语言&quot;</span><br><span class="line">    case RN = &quot;React-Native&quot;</span><br><span class="line">    case Java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>rawValue</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func residueNewYear(month: Month) -&gt; Int &#123;</span><br><span class="line">    return 12 - month.rawValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用枚举的Moth的构造函数生成一个Month</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let month = Month(rawValue: 5)</span><br><span class="line">let swift = ProgrammerLanguae.Swift.rawValue</span><br><span class="line">let oc = ProgrammerLanguae.OC</span><br><span class="line">let RN = ProgrammerLanguae.RN.rawValue</span><br></pre></td></tr></table></figure><h4 id="4-枚举关联值-associate-value"><a href="#4-枚举关联值-associate-value" class="headerlink" title="4. 枚举关联值 associate value"></a>4. 枚举关联值 associate value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">    case success(Int)</span><br><span class="line">    case fail(String)</span><br><span class="line">    case null // 未关联值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func associateValueTest(isSuccess: Bool) -&gt; Status &#123;</span><br><span class="line">    if isSuccess &#123;</span><br><span class="line">        return .success(200)</span><br><span class="line">    &#125;</span><br><span class="line">    return .fail(&quot;失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-枚举associateValue多个值"><a href="#5-枚举associateValue多个值" class="headerlink" title="5. 枚举associateValue多个值"></a>5. 枚举associateValue多个值</h4><ul><li>本质是关联了一个元祖(value0, value1, value2…)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enum Shape &#123;</span><br><span class="line">    case Square(width: Double)</span><br><span class="line">    case Reactangle(width: Double, height: Double)</span><br><span class="line">    case Circle(x: Double, y: Double, radius: Double)</span><br><span class="line">    case Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = Shape.Square(width: 20)</span><br><span class="line">let reactangle = Shape.Reactangle(width: 10, height: 20)</span><br><span class="line">let circle = Shape.Circle(x: 10, y: 10, radius: 20)</span><br><span class="line">let point = Shape.Point</span><br><span class="line"></span><br><span class="line">private func area(shape: Shape) -&gt; Double &#123;</span><br><span class="line">    switch shape &#123;</span><br><span class="line">    case let .Square(width):</span><br><span class="line">        return width * width</span><br><span class="line">    case let .Reactangle(width, height):</span><br><span class="line">        return width * height</span><br><span class="line">    case let .Circle(_, _, radius):</span><br><span class="line">        return radius * radius * Double.pi</span><br><span class="line">    case .Point:</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-递归枚举"><a href="#6-递归枚举" class="headerlink" title="6. 递归枚举"></a>6. 递归枚举</h4><ul><li>定义一个递归算术表达式</li><li>使用 indirect 来修饰</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">indirect enum ArithmeticalExpression &#123;</span><br><span class="line">    case Number(Int)</span><br><span class="line">    case Addition(ArithmeticalExpression, ArithmeticalExpression) // + 时两边也是一个表达式</span><br><span class="line">    case Multiplication(ArithmeticalExpression, ArithmeticalExpression) // * 时两边也是一个表达式</span><br><span class="line">    </span><br><span class="line">//    indirect case Addition(ArithmeticalExpression, ArithmeticalExpression) // + 时两边也是一个表达式</span><br><span class="line">//    indirect case Multiplication(ArithmeticalExpression, ArithmeticalExpression) // * 时两边也是一个表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>递归表达式使用 (2+3) * 4</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let two = ArithmeticalExpression.Number(2)</span><br><span class="line">let one = ArithmeticalExpression.Number(3)</span><br><span class="line">let sum = ArithmeticalExpression.Addition(two, one)</span><br><span class="line">let indirectEnumResult = ArithmeticalExpression.Multiplication(sum, ArithmeticalExpression.Number(4))</span><br></pre></td></tr></table></figure><ul><li>计算表达式值的函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private func calculate(expression: ArithmeticalExpression) -&gt; Int &#123;</span><br><span class="line">    switch expression &#123;</span><br><span class="line">    case let .Number(value):</span><br><span class="line">        return value</span><br><span class="line">    case let .Addition(left, right):</span><br><span class="line">        return calculate(expression: left) + calculate(expression: right)</span><br><span class="line">    case let .Multiplication(left, right):</span><br><span class="line">        return calculate(expression: left) * calculate(expression: right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li>结构体中的属性值没有初始化时必须使用构造函数来初始化，否则报错</li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Location &#123;</span><br><span class="line">    var latitude: Double</span><br><span class="line">    var longitude: Double</span><br><span class="line">    var placeName: String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let location1 = Location(latitude: 37.3230, longitude: -122.0322, placeName: &quot;测试&quot;)</span><br></pre></td></tr></table></figure><ul><li>结构体中属性如果都赋了初始值就可以直接初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Location2 &#123;</span><br><span class="line">    var latitude: Double = 0</span><br><span class="line">    var longitude: Double = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let location2 = Location2()</span><br></pre></td></tr></table></figure><ul><li>如果未指定初始值，swift 就不会默认初始化为（不初始化）</li><li>当属性值为可选值时此时允许值为nil，那么就允许不通过构造函数来初始化赋值</li><li>let 只有一次赋值机会</li><li>不管是类还是结构体都应该提供一个全参数的构造函数 <code>init(latitude: Double, longitude: Double, placeName: String?)</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Location3 &#123;</span><br><span class="line">    let latitude: Double</span><br><span class="line">    let longtitude: Double</span><br><span class="line">    var placeName: String?</span><br><span class="line">    </span><br><span class="line">    init(coordinateString: String) &#123;</span><br><span class="line">        let index = coordinateString.index(of: &quot;,&quot;)</span><br><span class="line">        let index1 = coordinateString.index(after: index!)</span><br><span class="line">        let test_1 = coordinateString.prefix(upTo: index!)</span><br><span class="line">        let test_2 = coordinateString.suffix(from: index1)</span><br><span class="line">        </span><br><span class="line">        latitude = Double(test_1)!</span><br><span class="line">        longtitude = Double(test_2)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(latitude: Double, longitude: Double, placeName: String?) &#123;</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longtitude = longitude</span><br><span class="line">        self.placeName = placeName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let test3 = Location3(coordinateString: &quot;12,45&quot;)</span><br></pre></td></tr></table></figure><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><h4 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h4><h4 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h4><h4 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h4><h4 id="属性管擦器"><a href="#属性管擦器" class="headerlink" title="属性管擦器"></a>属性管擦器</h4><h4 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h4><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h4 id="单利模式"><a href="#单利模式" class="headerlink" title="单利模式"></a>单利模式</h4><h2 id="继承和构造函数"><a href="#继承和构造函数" class="headerlink" title="继承和构造函数"></a>继承和构造函数</h2><h4 id="swift-中继承"><a href="#swift-中继承" class="headerlink" title="swift 中继承"></a>swift 中继承</h4><h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><h4 id="属性和函数重载"><a href="#属性和函数重载" class="headerlink" title="属性和函数重载"></a>属性和函数重载</h4><h4 id="子类两段式构造"><a href="#子类两段式构造" class="headerlink" title="子类两段式构造"></a>子类两段式构造</h4><ul><li><p>子类构造函数分为两段，第一段是构造自己，第二段是构造父类</p><ul><li>父类中构造函数</li><li>子类要设置一个自己的构造函数</li><li>子类构造函数中需要先初始化自己的属性</li><li><p>然后在构造函数中调用父类初始化父类构造函数中的相关属性</p><p>父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>子类<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line"></span><br><span class="line">    var isSwimming = true</span><br><span class="line">    </span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>子类两段构造都完成后子类的初始化才完成，可以使用<code>self</code>调用属性或者方法</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init(name: String, computer: String) &#123;</span><br><span class="line">       self.computer = computer</span><br><span class="line">       self.getToys() // 此代码报错，子类初始化未完成</span><br><span class="line">       super.init(name: name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="便利构造函数和指定构造函数"><a href="#便利构造函数和指定构造函数" class="headerlink" title="便利构造函数和指定构造函数"></a>便利构造函数和指定构造函数</h4><ul><li>便利构造函数只能调用自己的指定构造函数</li><li>指定构造函数通过一系列的调用都会调用super.init()</li><li>便利构造函数无法调用super.init()</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(name: String, old: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.old = old</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类便利构造函数，调用了指定构造函数</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        let computer = &quot;iMac&quot;</span><br><span class="line">        self.init(name: name, computer: computer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><ul><li>子类有可能会继承父类的构造函数</li><li>子类没有实现父类的任何指定构造函数；则自动继承父类的所有指定构造函数, 因为继承了指定构造函数所以同时便利构造函数也被继承</li></ul><p>父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father指定构造函数-1</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father指定构造函数-2</span><br><span class="line">    init(name: String, old: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.old = old</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father便利构造函数</span><br><span class="line">    convenience init(old: Int) &#123;</span><br><span class="line">        self.init(name: &quot;Father&quot;, old: old)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    var job: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-1</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;Dell&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-2</span><br><span class="line">    override convenience init(name: String, old: Int) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;acer&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /// 子类自己的指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        self.job = &quot;C#&quot;</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类便利构造函数，调用了自己指定构造函数</span><br><span class="line">    convenience init(computer: String) &#123;</span><br><span class="line">        let name = &quot;小张&quot;</span><br><span class="line">        self.init(name: name, computer: computer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未实现父类任何的指定构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Grandson: Son &#123;</span><br><span class="line">    var toy: String = &quot;dog toys&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类可以调用的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let grandSon0 = Grandson(old: 4)</span><br><span class="line">let grandSon1 = Grandson(computer: &quot;Mi&quot;)</span><br><span class="line">let grandSon2 = Grandson(name: &quot;小王&quot;)</span><br><span class="line">let grandSon3 = Grandson(name: &quot;小虎&quot;, computer: &quot;👽&quot;)</span><br><span class="line">let grandSon4 = Grandson(name: &quot;小李&quot;, old: 8)</span><br></pre></td></tr></table></figure><ul><li>子类实现了父类所有的指定构造函数，则自动继承父类的所有便利构造函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let son0 = Son(old: 30)</span><br><span class="line">let son1 = Son(computer: &quot;Mi&quot;)</span><br><span class="line">let son2 = Son(name: &quot;小王&quot;)</span><br><span class="line">let son3 = Son(name: &quot;小虎&quot;, computer: &quot;👽&quot;)</span><br><span class="line">let son4 = Son(name: &quot;小李&quot;, old: 8)</span><br></pre></td></tr></table></figure><h4 id="required-构造函数"><a href="#required-构造函数" class="headerlink" title="required 构造函数"></a>required 构造函数</h4><ul><li>父类中有被 required 关键词修饰的构造函数子类必须实现此构造函数</li><li>子类实现的此构造函数不需要再使用 override 关键词修饰，需要 required 修饰</li></ul><p>子类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    /// Father指定构造函数-1</span><br><span class="line">    // required 修饰的指定构造函数子类中必须实现</span><br><span class="line">    required init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-1</span><br><span class="line">    convenience required init(name: String) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;Dell&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类自己的指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        self.job = &quot;C#&quot;</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类如果实现了自己的指定构造函数，那么 required 修饰指定构造函数就初始化失败，因为自己实现了指定构造函数所以不能继承父类中的构造函数，此时可以自己实现被required 修饰的便利构造函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Son1: Son &#123;</span><br><span class="line">    var sport: String</span><br><span class="line">    </span><br><span class="line">    // 指定构造函数，需要调用父类的指定构造函数</span><br><span class="line">    init(name: String, sport: String) &#123;</span><br><span class="line">        self.sport = sport</span><br><span class="line">        Son.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 父类中有被 required 关键词修饰的必须实现的构造函数</span><br><span class="line">    convenience required init(name: String) &#123;</span><br><span class="line">       // fatalError(&quot;init(name:) has not been implemented&quot;)</span><br><span class="line">        // 调用自己的指定构造函数，</span><br><span class="line">        self.init(name: name, sport: &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/RN%E6%8A%A5%E9%94%99/"/>
      <url>/2019/06/18/RN%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>RN学习中遇到的错误总结</p><h3 id="执行-npm-install-时报错"><a href="#执行-npm-install-时报错" class="headerlink" title="执行 npm install 时报错"></a>执行 npm install 时报错</h3><h4 id="错误1-Unexpected-end-of-JSON-input-while-parsing-near-39-er-quot-quot-0-4-0-quot-quot-bin-quot-quot-39"><a href="#错误1-Unexpected-end-of-JSON-input-while-parsing-near-39-er-quot-quot-0-4-0-quot-quot-bin-quot-quot-39" class="headerlink" title="错误1. Unexpected end of JSON input while parsing near &#39;...er&quot;:&quot;0.4.0&quot;},&quot;bin&quot;:{&quot;&#39;"></a>错误1. <code>Unexpected end of JSON input while parsing near &#39;...er&quot;:&quot;0.4.0&quot;},&quot;bin&quot;:{&quot;&#39;</code></h4><p>本地有<code>package.json</code>文件，执行 npm install 报错，或者clone 的项目执行npm install 也报同样的错误, 可能是因为缓存导致，</p><p>解决办法：</p><ol><li><p>设置镜像源，以前可能大部分都是用的淘宝</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm set registry https://registry.npmjs.org/</span><br></pre></td></tr></table></figure></li><li><p>清除缓存</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean –-force</span><br></pre></td></tr></table></figure></li><li><p>如果提示失败，使用<code>sudo</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm cache clean --force</span><br></pre></td></tr></table></figure></li></ol><h4 id="错误2-xcrun-error-unable-to-find-utility-quot-simctl-quot-not-a-developer-tool-or-in-PATH"><a href="#错误2-xcrun-error-unable-to-find-utility-quot-simctl-quot-not-a-developer-tool-or-in-PATH" class="headerlink" title="错误2. xcrun: error: unable to find utility &quot;simctl&quot;, not a developer tool or in PATH"></a>错误2. <code>xcrun: error: unable to find utility &quot;simctl&quot;, not a developer tool or in PATH</code></h4><p>可能是因为 Xcode 版本问题引起，XCode 偏好设置中 Command line Tools 中为选择版本问题导致（我的情况是安装了Xcode 10 beta版导致的）</p><p>解决办法：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fut616x7ivj31840uc77y.jpg" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">The following build commands failed:</span><br><span class="line">        CompileC /Users/liepin/LiePinWorkspace/RNDemo/GitHubPopular/ios/build/Build/Intermediates.noindex/RCTWebSocket.build/Debug-iphonesimulator/RCTWebSocket.build/Objects-normal/x86_64/RCTSRWebSocket.o RCTSRWebSocket.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compiler</span><br><span class="line">(1 failure)</span><br><span class="line">Installing build/Build/Products/Debug-iphonesimulator/GitHubPopular.app</span><br><span class="line">An error was encountered processing the command (domain=NSPOSIXErrorDomain, code=2):</span><br><span class="line">Failed to install the requested application</span><br><span class="line">An application bundle was not found at the provided path.</span><br><span class="line">Provide a valid path to the desired application bundle.</span><br><span class="line">Print: Entry, &quot;:CFBundleIdentifier&quot;, Does Not Exist</span><br><span class="line"></span><br><span class="line">Command failed: /usr/libexec/PlistBuddy -c Print:CFBundleIdentifier build/Build/Products/Debug-iphonesimulator/GitHubPopular.app/Info.plist</span><br><span class="line">Print: Entry, &quot;:CFBundleIdentifier&quot;, Does Not Exist</span><br></pre></td></tr></table></figure><h4 id="错误3-Error-Cannot-find-module-39-lib-utils-unsupported-js-39"><a href="#错误3-Error-Cannot-find-module-39-lib-utils-unsupported-js-39" class="headerlink" title="错误3. Error: Cannot find module &#39;../lib/utils/unsupported.js&#39;"></a>错误3. <code>Error: Cannot find module &#39;../lib/utils/unsupported.js&#39;</code></h4><p>安装的node 版本不是稳定的版本，需要删除后重新安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo rm -rf /usr/local/lib/node_modules/npm</span><br><span class="line">brew reinstall node</span><br></pre></td></tr></table></figure><h4 id="错误4-Couldn-39-t-find-preset-quot-module-metro-react-native-babel-preset-quot-when-running-jest"><a href="#错误4-Couldn-39-t-find-preset-quot-module-metro-react-native-babel-preset-quot-when-running-jest" class="headerlink" title="错误4. Couldn&#39;t find preset &quot;module:metro-react-native-babel-preset&quot; when running jest"></a>错误4. <code>Couldn&#39;t find preset &quot;module:metro-react-native-babel-preset&quot; when running jest</code></h4><p><a href="https://github.com/facebook/metro/issues/242">解决方法</a></p><h3 id="已有项目集成RN"><a href="#已有项目集成RN" class="headerlink" title="已有项目集成RN"></a>已有项目集成RN</h3><p>报错1. 文件路径错误，查看你的<code>node_modules</code> 文件夹是在当前目录还是上级目录</p><pre><code>[!] No podspec found for `React` in `../node_modules/react-native</code></pre><ul><li><p><code>../</code> 是指父级目录</p></li><li><p><code>./</code> 是指当前目录</p></li></ul><p>报错 2. yoga Y 大小写为问题</p><pre><code>[!] The name of the given podspec `yoga` doesn&apos;t match the expected one `Yoga`_modules/react-native/ReactCommon/yoga&quot;</code></pre><h3 id="pod-install-之后"><a href="#pod-install-之后" class="headerlink" title="pod install 之后"></a>pod install 之后</h3><h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错 1."></a>报错 1.</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fuwfgkx6z1j31kw10nu0x.jpg" alt></p><p>解决办法： pod ‘React’, :subspecs 中加入 ‘CxxBridge’, ‘DevSupport’</p><pre><code>pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [&apos;Core&apos;,&apos;RCTText&apos;,&apos;RCTNetwork&apos;,&apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的&apos;CxxBridge&apos;, # Include this for RN &gt;= 0.47&apos;DevSupport&apos;, # Include this to enable In-App Devmenu if RN &gt;= 0.43</code></pre><p>]</p><h4 id="报错-2"><a href="#报错-2" class="headerlink" title="报错 2."></a>报错 2.</h4><p><code>RCTAnimation/RCTValueAnimatedNode.h&#39; file not found</code></p><p>解决方法：</p><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;RCTAnimation/RCTValueAnimatedNode.h&gt;</span><br></pre></td></tr></table></figure><p>替换为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;RCTValueAnimatedNode.h&quot;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/facebook/react-native/issues/13198">修改头文件导入方式</a></p><h4 id="报错3-版本不匹配-react-native-version-mismatch-javascript-version-0-54-3-native-0-57-2"><a href="#报错3-版本不匹配-react-native-version-mismatch-javascript-version-0-54-3-native-0-57-2" class="headerlink" title="报错3 版本不匹配 react native version mismatch javascript version 0.54.3 native 0.57.2"></a>报错3 版本不匹配 <code>react native version mismatch javascript version 0.54.3 native 0.57.2</code></h4><ul><li><p>关闭所有的 terminal，或者是集成开发环境的命令行窗口</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">watchman watch-del-all</span><br><span class="line">react-native start --reset-cache</span><br></pre></td></tr></table></figure></li><li><p>重新打开一个terminal窗口</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native run-ios</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/awy1988/article/details/80336913" target="_blank" rel="noopener">问题描述和解决1</a></p><p><a href="https://stackoverflow.com/questions/47763824/react-native-version-mismatch" target="_blank" rel="noopener">问题描述和解决2</a></p></li></ul><h4 id="报错4-Unable-to-resolve-module-quot-schedule-tracking-quot"><a href="#报错4-Unable-to-resolve-module-quot-schedule-tracking-quot" class="headerlink" title="报错4 Unable to resolve module &quot;schedule/tracking&quot;"></a>报错4 <code>Unable to resolve module &quot;schedule/tracking&quot;</code></h4><p>缺少一些开发依赖的库</p><pre><code>npm i schedule@0.4.0 --save-dev</code></pre><p><a href="https://github.com/facebook/react-native/issues/21150">问题描述和解决</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/React-Native%E5%BC%80%E5%8F%91iOS%E6%89%93%E5%8C%85/"/>
      <url>/2019/06/18/React-Native%E5%BC%80%E5%8F%91iOS%E6%89%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="React-Native开发iOS打包"><a href="#React-Native开发iOS打包" class="headerlink" title="React-Native开发iOS打包"></a>React-Native开发iOS打包</h1><h2 id="打jsbudnle包"><a href="#打jsbudnle包" class="headerlink" title="打jsbudnle包"></a>打jsbudnle包</h2><h4 id="创建打包后存放文件目录"><a href="#创建打包后存放文件目录" class="headerlink" title="创建打包后存放文件目录"></a>创建打包后存放文件目录</h4><ul><li>cd 到 React-Native 项目根目录下 并且 进入 ios 文件目录下</li><li><p>创建 bundle 文件夹</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir bundle</span><br></pre></td></tr></table></figure></li></ul><h4 id="配置-React-Native-打包命令"><a href="#配置-React-Native-打包命令" class="headerlink" title="配置 React-Native 打包命令"></a>配置 React-Native 打包命令</h4><ul><li><p>打包命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle</span><br></pre></td></tr></table></figure></li><li><p>在React Native项目的根目录下执行命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">react-native bundle --entry-file index.js --platform ios --dev false --bundle-output ./ios/bundle/index.jsbundle --assets-dest ./ios/bundle</span><br></pre></td></tr></table></figure></li></ul><pre><code>- `--entry-file`： ios或者android入口的js名称，比如 `index.js`- `--platform`： 平台名称(ios或者android)- `--dev`： 设置为`false`的时候将会对`JavaScript`代码进行优化处理。- `--bundle-output`： 生成的jsbundle文件的名称和路径，比如 `./ios/bundle/index.jsbundle`- `--assets-dest`： 图片以及其他资源存放的目录</code></pre><h4 id="使用打包命令"><a href="#使用打包命令" class="headerlink" title="使用打包命令"></a>使用打包命令</h4><ul><li><p>将打包命令添加到 <code>packger.json</code> 中</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;jest&quot;,</span><br><span class="line">    &quot;bundle-ios&quot;: &quot;node node_modules/react-native/local-cli/cli.js bundle --entry-file index.js --platform ios --dev false --bundle-output ./ios/bundle/index.jsbundle --assets-dest ./ios/bundle&quot;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>再次打包只需要 <code>React Native</code>项目的根目录下执行命令，不用再次输入类似上面的命令</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run bundle-ios</span><br></pre></td></tr></table></figure></li></ul><h2 id="集成到Xcode（iOS原生项目中）"><a href="#集成到Xcode（iOS原生项目中）" class="headerlink" title="集成到Xcode（iOS原生项目中）"></a>集成到Xcode（iOS原生项目中）</h2><ul><li><p>添加已经打好的<code>.jsbundle</code> 离线包</p><p>  <img src="https://ws1.sinaimg.cn/large/006tNbRwly1fw4adqh37aj318e130gpd.jpg" alt></p></li></ul><ul><li><p>iOS 项目代码配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private func loadReactNativeTest() &#123;</span><br><span class="line">// debug 测试加载本地文件</span><br><span class="line">       let url = URL(string: &quot;http://localhost:8081/index.bundle?platform=ios&quot;)!</span><br><span class="line">       </span><br><span class="line">       // 加载已经加入的离线包</span><br><span class="line">       let url2 = Bundle.main.url(forResource: &quot;index&quot;, withExtension: &quot;jsbundle&quot;)</span><br><span class="line">       </span><br><span class="line">       let rootView = RCTRootView(</span><br><span class="line">           bundleURL: url,</span><br><span class="line">           moduleName: &quot;MyApp&quot;, //这里的名字要和index.js中相同</span><br><span class="line">           initialProperties: nil,</span><br><span class="line">           launchOptions: nil</span><br><span class="line">       )</span><br><span class="line">       view = rootView</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/ReactNative%E4%B8%ADref%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/06/18/ReactNative%E4%B8%ADref%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Reat Native ref 使用</p><h3 id="State-状态的使用"><a href="#State-状态的使用" class="headerlink" title="State 状态的使用"></a>State 状态的使用</h3><p>在父控件中指定,整个生命周期讲不再改变<br>需求：一段闪烁的文字， Props 属性显示文字内容创建时初始化，State控制随时间变化是否显示，在父控件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Blink extends Component&#123;</span><br><span class="line">    // 构造</span><br><span class="line">      constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        // 初始状态</span><br><span class="line">        this.state = &#123;showWithText:true&#125;;</span><br><span class="line">    this.state = &#123;&#125;</span><br><span class="line">        setInterval(() =&gt; &#123;</span><br><span class="line">            this.setState(previousState =&gt; &#123;</span><br><span class="line">                return &#123;showWithText: !previousState.showWithText&#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;, 100);</span><br><span class="line">      &#125;</span><br><span class="line">      render() &#123;</span><br><span class="line">          let display= this.state.showWithText ? this.props.text : &apos; &apos;;</span><br><span class="line">          return(</span><br><span class="line">              &lt;Text&gt;&#123;display&#125;&lt;/Text&gt;</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export default class App extends Component&lt;Props&gt; &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Blink</span><br><span class="line">                    text=&apos;I love to blink&apos;</span><br><span class="line">                /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Blink</span><br><span class="line">                  text=&apos;猜猜猜&apos;</span><br><span class="line">                /&gt;</span><br><span class="line"></span><br><span class="line">                &lt;Blink</span><br><span class="line">                    text=&apos;Blink is great&apos;</span><br><span class="line">                /&gt;</span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Props-属性的使用"><a href="#Props-属性的使用" class="headerlink" title="Props 属性的使用"></a>Props 属性的使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个组件</span><br><span class="line">class Greeting extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;Text&gt; Hello &#123;this.props.name&#125;!</span><br><span class="line">            &lt;/Text&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">export default class App extends Component&lt;Props&gt; &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return(</span><br><span class="line">            &lt;View style=&#123;styles.container&#125;&gt;</span><br><span class="line">                &lt;Image source=&#123;&#123;uri:&apos;https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg&apos;&#125;&#125;</span><br><span class="line">                       style=&#123;&#123;width: 190, height: 110&#125;&#125;</span><br><span class="line">                /&gt;</span><br><span class="line">                &lt;Text style=&#123;styles.instructions&#125;&gt;</span><br><span class="line">                    使用Props属性</span><br><span class="line">                &lt;/Text&gt;</span><br><span class="line">                &lt;View&gt;</span><br><span class="line">                    &lt;Greeting name=&apos;React-Native&apos;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &lt;Greeting name=&apos;iOS&apos;</span><br><span class="line">                    /&gt;</span><br><span class="line">                    &lt;Greeting name=&apos;Swift&apos;</span><br><span class="line">                    /&gt;</span><br><span class="line">                &lt;/View&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/View&gt;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ref的使用"><a href="#ref的使用" class="headerlink" title="ref的使用"></a>ref的使用</h4><ul><li>可以理解为组件渲染后指向组件的一个应用，可以通过ref获取到真实的组件（类似指针？）</li></ul><p>定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ref=&apos;scrollView&apos;</span><br></pre></td></tr></table></figure><p>获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let scrollView = this.refs.scrollView</span><br><span class="line">let scrollView = this.refs[&apos;scrollView&apos;]</span><br></pre></td></tr></table></figure><ul><li>可以通过ref访问组件的属性和方法</li></ul><h4 id="ES6-定时器"><a href="#ES6-定时器" class="headerlink" title="ES6 定时器"></a>ES6 定时器</h4><ul><li>开启定时器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">let scrollView = this.refs.scrollView;</span><br><span class="line">// 2.4timer 定时器的写法</span><br><span class="line">this.timer = setInterval(</span><br><span class="line">    ()=&gt;&#123;</span><br><span class="line">        var tempPage = 0;</span><br><span class="line">        //  修改banner索引</span><br><span class="line">        if ((this.state.currentPage+1) &gt;= ImageData.data.length) &#123;</span><br><span class="line">            tempPage = 0;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            tempPage = this.state.currentPage+1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 更新状态</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            currentPage: tempPage</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        let offSet_x = width * tempPage</span><br><span class="line">        scrollView.scrollResponderScrollTo(&#123;x:offSet_x, y:0, animated: true&#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    this.state.duration</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>暂停定时器</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.timer &amp;&amp; clearInterval(this.timer)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/JavaScript%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/06/18/JavaScript%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>js 学习</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fullName;</span><br><span class="line">//  undefined</span><br><span class="line"></span><br><span class="line">fullName</span><br><span class="line">// undefined</span><br><span class="line"></span><br><span class="line">fullName + 2</span><br><span class="line">// NaN</span><br></pre></td></tr></table></figure><ul><li><p>判断类型名称</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fullName = &apos;张&apos;</span><br><span class="line">&quot;张&quot;</span><br><span class="line">typeof(fullName)</span><br><span class="line">// &quot;string&quot;</span><br></pre></td></tr></table></figure></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var weight = 100;</span><br><span class="line">undefined</span><br><span class="line">typeof(weight)</span><br><span class="line">// &quot;number&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var firstName = &apos;王&apos;, lastName = &apos;张&apos;</span><br><span class="line">undefined</span><br><span class="line">firstName + lastName</span><br><span class="line">// &quot;王张&quot;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>类型不相同时转换后在拼接 </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var weightIncrease = &apos;2.5斤&apos;</span><br><span class="line">undefined</span><br><span class="line">weight + weightIncrease</span><br><span class="line">// &quot;1002.5斤&quot;</span><br></pre></td></tr></table></figure></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><pre><code>var array = [];undefinedarray.length// 0typeof(array)// &quot;object&quot;</code></pre><ul><li><p>增加元素</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array.push(&apos;1&apos;)</span><br><span class="line">// 4</span><br><span class="line">array</span><br><span class="line">// (4) [&quot;ab&quot;, &quot;cbd&quot;, &quot;fcg&quot;, &quot;1&quot;]</span><br></pre></td></tr></table></figure></li><li><p>数组前面添加</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array.unshift(&apos;0&apos;)</span><br><span class="line">// 6</span><br><span class="line">array</span><br><span class="line">// (6) [&quot;0&quot;, &quot;ab&quot;, &quot;cbd&quot;, &quot;fcg&quot;, &quot;1&quot;, Array(2)]</span><br></pre></td></tr></table></figure><ul><li><p>删除最后元素</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array.pop() // 返回删除的元素</span><br><span class="line">// (2) [&quot;2&quot;, &quot;3&quot;]</span><br><span class="line">array</span><br><span class="line">// (5) [&quot;0&quot;, &quot;ab&quot;, &quot;cbd&quot;, &quot;fcg&quot;, &quot;1&quot;]</span><br></pre></td></tr></table></figure></li><li><p>删除第一个元素</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array.shift()</span><br><span class="line">// &quot;0&quot;</span><br><span class="line">array</span><br><span class="line"> // (4) [&quot;ab&quot;, &quot;cbd&quot;, &quot;fcg&quot;, &quot;1&quot;]</span><br><span class="line">```</span><br><span class="line">- 删除指定的值，但数组元素没有被删</span><br></pre></td></tr></table></figure><p>  delete array[2]<br>  // true<br>  array<br>  // (4) [“ab”, “cbd”, empty, “1”]</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 删除指定的元素</span><br></pre></td></tr></table></figure><p>  array.splice(1)<br>  // (3) [“cbd”, empty, “1”]<br>  array<br>  // [“ab”]</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 函数</span><br><span class="line"></span><br><span class="line">### 调用调用</span><br></pre></td></tr></table></figure></li></ul><p>alertMessage();</p><p>function alertMessageWithParamter(message) {<br>    alert(message)<br>}</p><p>alertMessageWithParamter(‘有参数的函数’)<br>alertMessageWithParamter(250)<br>alertMessageWithParamter(<br>    console.log(‘test’)<br>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 函数表达式，使用函数声明的方式</span><br></pre></td></tr></table></figure><p>var alertMessage_expression = function expression_alert (message) {<br>    alert(message)<br>}</p><p>alertMessage_expression(‘匿名函数调用’)</p><p>expression_alert(‘函数表达式’)<br><code>`</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/MasonrySnapkit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2019/06/18/MasonrySnapkit%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Masonry使用"><a href="#Masonry使用" class="headerlink" title="Masonry使用"></a>Masonry使用</h2><p>基本使用官网Demo非常详细，以下总结的是常见问题和技巧</p><h3 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h3><ul><li><p>pod 安装后出现⚠️，项目运行报错</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIView mas_makeConstraints:]: unrecognized selector sent to instance</span><br></pre></td></tr></table></figure><p>  <a href="https://github.com/SnapKit/Masonry/issues/188">github</a></p><p>  <a href="https://www.jianshu.com/p/3c3fc3cf1218" target="_blank" rel="noopener">解决方法</a></p></li><li><p>使用<code>lastBaseline</code>属性<code>crash</code></p><p>  <a href="https://github.com/SnapKit/Masonry/issues/353">解决办法</a></p></li></ul><h3 id="使用时注意点"><a href="#使用时注意点" class="headerlink" title="使用时注意点"></a>使用时注意点</h3><ul><li><p><code>edgesForExtendedLayout</code> 方法</p><p>  重写此方法的目的是为了确定布局位置从什么位置开始什么位置结束，</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIRectEdge)edgesForExtendedLayout &#123;</span><br><span class="line">   return UIRectEdgeNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><pre><code>**重写后**![](https://ws1.sinaimg.cn/large/006tNc79ly1fsgcn3fmo0j30s61iyalk.jpg)**重写前**![](https://ws4.sinaimg.cn/large/006tNc79ly1fsgcokvpdwj30s61iy7eq.jpg)</code></pre><ul><li><p><code>translucent</code> 设置<code>UINavigationBar</code>是否半透明, 如果设置了导航栏的<code>style</code> 为<code>UIBarStyleBlackTranslucent</code> 就为true</p><p>  <strong>设置为false不透明效果</strong><br>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fsgg7ugz8mj30ow0nqq4h.jpg" alt></p></li></ul><ul><li><p><code>extendedLayoutIncludesOpaqueBars</code> 导航栏不透明条件下是否可以扩展，默认是NO不可以扩展</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController?.navigationBar.isTranslucent = false</span><br><span class="line"> self.extendedLayoutIncludesOpaqueBars = true</span><br></pre></td></tr></table></figure></li></ul><pre><code>**设置不透明，设置可以扩展此时从坐标的（0，0）点开始布局**![](https://ws2.sinaimg.cn/large/006tNc79ly1fsggem13mjj30ow0j83zy.jpg)    </code></pre><ul><li><p><code>inset</code> 的使用，当约束控件的属性相同时不用再考虑正负值的问题，例如要约束一个控件左边距离另一控件的右边位置时还需要使用负值情况</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[yellowdView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">       make.height.equalTo(@150);</span><br><span class="line">       make.top.equalTo(self).inset(220);</span><br><span class="line">       make.leading.equalTo(self).inset(10);</span><br><span class="line">       make.trailing.equalTo(greenView.leading).inset(10);</span><br><span class="line">       make.width.equalTo(greenView);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure></li><li><p><code>edges</code>的使用，约束边距更方便</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[edgeView remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">           make.edges.equalTo(lasView).insets(UIEdgeInsetsMake(10, 5, 5, 5));</span><br><span class="line">       &#125;];</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>Priority</code> 设置约束的优先级</p><ul><li><code>priorityHigh</code></li><li><code>priorityMedium</code></li><li><code>priorityLow</code></li></ul></li><li><p><code>makeConstraints</code>、<code>updateConstraints</code>、<code>remakeConstraints</code>三者区别</p><ul><li><code>makeConstraints</code> 添加约束</li><li><code>updateConstraints</code> 更新约束，更新之前会查找一边控件已经存在的约束，没有就添加，有就更新到最新的约束</li><li><code>remakeConstraints</code>删除控件以前的所有约束重新添加约束</li></ul></li><li><p>设置控件或者某一约束的’key’ 方便冲突时⚠️查找</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">greenView.mas_key = @&quot;greenView&quot;;</span><br><span class="line">    [greenView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.height.equalTo(yellowdView).key(@&quot;greenView-height&quot;);</span><br><span class="line">        make.top.equalTo(yellowdView).key(@&quot;greenView-top&quot;);</span><br><span class="line">        make.width.equalTo(yellowdView).key(@&quot;greenView-width&quot;);</span><br><span class="line">        make.trailing.equalTo(self).inset(10).key(@&quot;greenView-trailing&quot;);</span><br><span class="line">        // 冲突约束</span><br><span class="line">//        make.leading.equalTo(greenView.trailing).inset(10).key(@&quot;greenView-leading&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- 使用 `MASAttachKeys`批量给`view`设置key</span><br></pre></td></tr></table></figure><p>  MASAttachKeys(greenView, yellowdView);</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![](https://ws3.sinaimg.cn/large/006tNc79ly1fsgalvd4l6j31a20modnp.jpg)</span><br><span class="line"></span><br><span class="line">- `dividedBy`和 `multipliedBy` 约束宽高比</span><br></pre></td></tr></table></figure><p>  [topInnerView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>// 设置自己的宽高比是3:1make.width.equalTo( topInnerView.height).multipliedBy(3); // 乘因数// 设置宽高并且设置他们的优先级最低make.width.height.lessThanOrEqualTo(topView);make.width.height.equalTo(topView).priorityLow();// 设置位置make.top.equalTo(topView);</code></pre><p>  }];</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 多个控件批量约束</span><br></pre></td></tr></table></figure><p>  NSValue <em>sizeValue = [NSValue valueWithCGSize:CGSizeMake(100, 100)];<br>  [@[blueView, redView, yellowView] makeConstraints:^(MASConstraintMaker </em>make) {</p><pre><code>make.size.equalTo(sizeValue);</code></pre><p>  }];</p><p>  [@[blueView, redView, yellowView] mas_makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.top.equalTo(self).inset(20);</code></pre><p>  }];</p><p>  [blueView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.left.equalTo(self).inset(20);</code></pre><p>  }];</p><p>  [redView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.left.equalTo(blueView.right).inset(10);</code></pre><p>  }];</p><p>  [yellowView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.left.equalTo(redView.right).inset(10);</code></pre><p>  }];</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![批量约束](https://ws1.sinaimg.cn/large/006tNc79ly1fsgaz670hvj30s61iyn2l.jpg)</span><br><span class="line"></span><br><span class="line">**以上代码也可以简化为**</span><br></pre></td></tr></table></figure><p>  [redView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.left.equalTo(blueView.right).inset(10);</code></pre><p>  }];</p><p>  [yellowView makeConstraints:^(MASConstraintMaker *make) {</p><pre><code>make.left.equalTo(redView.right).inset(10);</code></pre><p>  }];</p></li></ul><pre><code>[blueView makeConstraints:^(MASConstraintMaker *make) {    make.top.left.equalTo(self);    make.size.equalTo(@[redView, yellowView, sizeValue]);}];<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">![](https://ws2.sinaimg.cn/large/006tNc79ly1fsgbhz8lw5j30s61iyte5.jpg)</span><br><span class="line"></span><br><span class="line">## Snapkit 使用</span><br><span class="line"></span><br><span class="line">- Swift 中`edgesForExtendedLayout:UIRectEdge` 扩展布局的边缘是一个属性，默认是`All`</span><br></pre></td></tr></table></figure>self.edgesForExtendedLayout = []<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在Swift中闭包参数可以使用$0、$1、$2 一次代表第一个，第二个，第三个参数</span><br><span class="line"></span><br><span class="line">- 使用$0 来代替闭包参数</span><br></pre></td></tr></table></figure>nullDataImageView.snp.makeConstraints {    $0.top.equalTo(view).offset(44)    $0.centerX.equalTo(view)    $0.width.height.equalTo(200)}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `deactivate` 和 `activate` 使用</span><br><span class="line"></span><br><span class="line">- `activate` 激活指定的约束</span><br><span class="line">- `deactivate` 移除指定的约束</span><br><span class="line"></span><br><span class="line">添加约束</span><br></pre></td></tr></table></figure>nullDataImageView.snp.makeConstraints {    nullDataViewTopConstraint = $0.top.equalTo(view).offset(80).constraint    nullDataViewLeftConstraint = $0.left.equalTo(view).inset(10).constraint    $0.width.height.equalTo(200)}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移除对应约束，设置约束再激活约束</span><br></pre></td></tr></table></figure>nullDataViewLeftConstraint?.deactivate()nullDataViewLeftConstraint?.update(inset: 100)nullDataViewLeftConstraint?.activate()UIView.animate(withDuration: 1.5) {    self.view.layoutIfNeeded()}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 更新约束</span><br><span class="line"></span><br><span class="line">- 添加约束</span><br></pre></td></tr></table></figure>nullDataImageView.snp.makeConstraints {    nullDataViewTopConstraint = $0.top.equalTo(view).offset(64).constraint    $0.centerX.equalTo(view)    $0.width.height.equalTo(200)}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 更新约束</span><br></pre></td></tr></table></figure>nullDataViewTopConstraint?.update(inset: 84)UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {    self.view.layoutIfNeeded()}) { (finished) in    print(&quot;动画执行完毕&quot;)}<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 添加`debug`模式中的`key`使用`labeled()`方法</span><br></pre></td></tr></table></figure>nullDataImageView.snp.makeConstraints {    nullDataViewTopConstraint = $0.top.equalTo(view).offset(80).constraint    nullDataViewLeftConstraint = $0.left.equalTo(view).inset(10).constraint    $0.width.height.equalTo(200).labeled(&quot;width和height约束&quot;)}```</code></pre><ul><li>其他注意点都和<code>Masnory</code>相同</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/ES6%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/06/18/ES6%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-ES6-语法"><a href="#JS-ES6-语法" class="headerlink" title="JS ES6 语法"></a>JS ES6 语法</h1><h3 id="1-let-var-变量，作用域"><a href="#1-let-var-变量，作用域" class="headerlink" title="1. let var 变量，作用域"></a>1. let var 变量，作用域</h3><pre><code>var a = 10;if (a &gt; 10) {    let b = 5; // let 只能在代码块内被访问    console.log(b);}// 访问 b 报错console.log(b);console.log(a);</code></pre><h3 id="2-const-只能分配一次值"><a href="#2-const-只能分配一次值" class="headerlink" title="2. const 只能分配一次值"></a>2. const 只能分配一次值</h3><p>{<br>    const const_a = 1;<br>    console.log(const_a)</p><pre><code>// 报错const_a = 2;// 声明一个常量数组const const_array = [];const_array.push(1);const_array.push(2);// 再次赋值时会报错const_array = [3];</code></pre><p>}</p><h3 id="3-解构语法"><a href="#3-解构语法" class="headerlink" title="3. 解构语法"></a>3. 解构语法</h3><p>{<br>    // 1.解构数组<br>    function getArray() {<br>        return [10, 20, 30];<br>    }</p><pre><code>let [a,b,c] = getArray()console.log(a, b, c)// 函数返回一个对象function getObj() {    return {dessert: &apos;面包&apos;, drink: &apos;水&apos;, play: &apos;Game&apos;};}// 2.解构对象let {des: dessert,  dri: drink, pla: play} = getObj()console.log(des, dri, pla);</code></pre><p>}</p><h3 id="4-模版字符串"><a href="#4-模版字符串" class="headerlink" title="4. 模版字符串"></a>4. 模版字符串</h3><p>{<br>    let name = ‘姓名：’, password = ‘密码：’<br>    let str_4 = name + ‘李老师’ + ‘—-‘ + password + ‘北京太热。。。’<br>    console.log(str_4)</p><pre><code>// 使用 `${}` 包裹会生成字符串let str_41 = `${name}李老师----${password}北京太热`console.log(str_41)// 多行显示时直接回车换行let str_42 = `${name}李老师----${password}北京太热`console.log(str_42)</code></pre><p>}</p><h3 id="5-带标签的模版字符串"><a href="#5-带标签的模版字符串" class="headerlink" title="5. 带标签的模版字符串"></a>5. 带标签的模版字符串</h3><p>{<br>    let name = ‘姓名：’, password = ‘密码：’<br>    // 多行显示时直接回车换行<br>    let str_5 = strTest<code>${name}李老师 ---- ${password}北京太热</code><br>    console.log(str_5)</p><pre><code>// strings 字符中包含的被插值分割的子字符串已数组形式展现// values 字符串中的插值数组function strTest(strings, ...values) {    console.log(strings)    console.log(values)}function strTest1(strings, ...values) {    let result = &apos;&apos;;    for (let i = 0; i &lt; values.length; i++) {        result += strings[i]        result += values[i]    }    return result}</code></pre><p>}</p><h3 id="6-判断字符串是否包含其他字符"><a href="#6-判断字符串是否包含其他字符" class="headerlink" title="6. 判断字符串是否包含其他字符"></a>6. 判断字符串是否包含其他字符</h3><p>{<br>    let name = ‘姓名：’, password = ‘密码：’<br>    let str_6 = <code>${name}李老师---${password}北京真热</code><br>    console.log(str_6.startsWith(<code>${name}</code>))<br>    console.log(str_6.endsWith(<code>${name}</code>))<br>    console.log(str_6.includes(‘李老师’))<br>}</p><h3 id="7-函数默认参数"><a href="#7-函数默认参数" class="headerlink" title="7. 函数默认参数"></a>7. 函数默认参数</h3><p>{<br>    function funcDefaultParame(param1 = ‘a’, param2 = ‘b’, param3 = ‘c’) {<br>        return <code>${param1}--${param2}--${param3}</code><br>    }<br>    console.log(funcDefaultParame(1, 2,3))<br>}</p><h3 id="8-“…”展开操作符"><a href="#8-“…”展开操作符" class="headerlink" title="8. “…”展开操作符"></a>8. “…”展开操作符</h3><p>{<br>    let a = [1,2,3];<br>    console.log(a);<br>    console.log(…a)</p><pre><code>let b = [...a, 4, 5];console.log(a);console.log(b)</code></pre><p>}</p><h3 id="9-‘…-‘剩余操作符-一般用在函数参数，-可以看作是一个可以展开的参数"><a href="#9-‘…-‘剩余操作符-一般用在函数参数，-可以看作是一个可以展开的参数" class="headerlink" title="9. ‘… ‘剩余操作符, 一般用在函数参数， 可以看作是一个可以展开的参数"></a>9. ‘… ‘剩余操作符, 一般用在函数参数， 可以看作是一个可以展开的参数</h3><pre><code>//  ... param3表示函数可以接收除了param1, param2,两个参数外，多个参数，都会放在param3中function operator(param1, param2, ...param3) {    console.log(param1, param2, param3)}operator(&apos;a&apos;,&apos;b&apos;,&apos;c&apos;,&apos;d&apos;,&apos;e&apos;,&apos;f&apos;,&apos;g&apos;)</code></pre><h3 id="10-解构对象解构函数"><a href="#10-解构对象解构函数" class="headerlink" title="10. 解构对象解构函数"></a>10. 解构对象解构函数</h3><pre><code>// 当函数参数是对象是可以按照对象解构function getObjcValue(param1, param2, {value1, value2} = {}) {    console.log(param1, param2, value1, value2)}getObjcValue(1,2,{value1: -3,value2: -4})</code></pre><h3 id="11-获取函数名称"><a href="#11-获取函数名称" class="headerlink" title="11. 获取函数名称"></a>11. 获取函数名称</h3><pre><code>function getObjcValue(param1, param2, {value1, value2} = {}) {    console.log(param1, param2, value1, value2)}console.log(getObjcValue.name)let funName = function getfunctionName() {  }console.log(funName.name)</code></pre><h3 id="12-箭头函数"><a href="#12-箭头函数" class="headerlink" title="12. 箭头函数"></a>12. 箭头函数</h3><pre><code>// 原来普通写法var funType = function arrowfunction(param) {    return param}// 函数参数 =&gt; 函数返回值// &apos;=&gt;&apos; 的左边表示箭头函数的参数，多个时表示为 (param1, param2, param3)// &apos;=&gt;&apos; 的右边表示箭头函数的返回值，如果返回值是一个对象时用 { } 表示let arrowFunction = (param1, param2) =&gt; {    return `${param1}${param2}`</code></pre><p>}</p><h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
      <url>/2019/06/18/Flutter%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>flutter 常用组件</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><ul><li>StatefulWidget<ul><li>具有可变状态的窗口部件，使用应用时可随时变化，例如进度条</li></ul></li><li>StatelessWidget <ul><li>不可变窗口部件</li></ul></li></ul><h2 id="Text-组件"><a href="#Text-组件" class="headerlink" title="Text 组件"></a>Text 组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  Text 组件</span><br><span class="line">class MyText extends StatelessWidget&#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    return Text(&apos;reacctNative、 flutter 学习之路是非常坚信不疑的，作为一个程序员，因该对于技术有着追求，不断的提高自己才是王道，可是道理都懂依然过不好这一生&apos;,</span><br><span class="line">      maxLines: 2,</span><br><span class="line">      overflow: TextOverflow.fade,</span><br><span class="line">      textAlign: TextAlign.center,</span><br><span class="line">      style: TextStyle(</span><br><span class="line">        fontSize: 20.0,</span><br><span class="line">        color: Colors.deepOrange,</span><br><span class="line">        decoration: TextDecoration.underline,</span><br><span class="line">        decorationColor: Colors.redAccent,</span><br><span class="line">        decorationStyle: TextDecorationStyle.dotted</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="COntainer-组件"><a href="#COntainer-组件" class="headerlink" title="COntainer 组件"></a>COntainer 组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Container容器组件</span><br><span class="line">class MyContainer extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: Text(&apos;Container 容器中有文字&apos;,</span><br><span class="line">        style: TextStyle(</span><br><span class="line">          backgroundColor: Colors.cyan,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      alignment: Alignment.center, // 容器中内容对其方式</span><br><span class="line">      width: 300.0,</span><br><span class="line">      height: 200.0,</span><br><span class="line">      padding: const EdgeInsets.all(10), // 容器内边距</span><br><span class="line">      margin: const EdgeInsets.fromLTRB(10, 5, 10, 5), // container 和外部控件的边距</span><br><span class="line">      decoration: new BoxDecoration(</span><br><span class="line">        gradient: const LinearGradient(</span><br><span class="line">          colors: [Colors.lightBlue, Colors.greenAccent, Colors.yellow]</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        // 设置 border 的宽度</span><br><span class="line">        border: Border.all(width: 5, color: Colors.black) </span><br><span class="line"></span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Image-组件"><a href="#Image-组件" class="headerlink" title="Image 组件"></a>Image 组件</h2><h3 id="fit属性"><a href="#fit属性" class="headerlink" title="fit属性"></a>fit属性</h3><ul><li>BoxFit.fill:全图显示，图片会被拉伸，并充满父容器。</li><li>BoxFit.contain:全图显示，显示原比例，可能会有空隙。</li><li>BoxFit.cover：显示可能拉伸，可能裁切，充满（图片要充满整个容器，还不变形）。</li><li>BoxFit.fitWidth：宽度充满（横向充满），显示可能拉伸，可能裁切。</li><li>BoxFit.fitHeight ：高度充满（竖向充满）,显示可能拉伸，可能裁切。</li><li>BoxFit.scaleDown：效果和contain差不多，但是此属性不允许显示超过源图片大小，可小不可大。</li></ul><h3 id="图片的混合模式"><a href="#图片的混合模式" class="headerlink" title="图片的混合模式"></a>图片的混合模式</h3><ul><li>color：是要混合的颜色，如果你只设置color是没有意义的。</li><li>colorBlendMode: 是混合模式。</li></ul><h3 id="repeat-图片填充模式"><a href="#repeat-图片填充模式" class="headerlink" title="repeat 图片填充模式"></a>repeat 图片填充模式</h3><ul><li>ImageRepeat.repeat : 横向和纵向都进行重复，直到铺满整个画布。</li><li>ImageRepeat.repeatX: 横向重复，纵向不重复。</li><li>ImageRepeat.repeatY：纵向重复，横向不重复</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class MyImage extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: new Image.network(</span><br><span class="line">        // &apos;https://images.xiaozhuanlan.com/photo/2019/28ed76123023e46483fcf0ae5c2ba11b.png&apos;,</span><br><span class="line">        &apos;https://p.ampmake.com/mall/product/9666f00e-f02a-46ce-9b7c-090bf6aba9aa.png&apos;,</span><br><span class="line"></span><br><span class="line">        // 1. 设置填充模式</span><br><span class="line">        // fit: BoxFit.scaleDown,</span><br><span class="line">        // fit: BoxFit.none,</span><br><span class="line">        // fit: BoxFit.fill,</span><br><span class="line">        // fit: BoxFit.fitHeight,</span><br><span class="line">        // fit: BoxFit.fitWidth,</span><br><span class="line"></span><br><span class="line">        // 保持原图比例</span><br><span class="line">        // fit: BoxFit.contain,</span><br><span class="line"></span><br><span class="line">        // 充满整个容器，图片被裁切</span><br><span class="line">        // fit: BoxFit.cover,</span><br><span class="line">        // scale: 1.0,</span><br><span class="line"></span><br><span class="line">        // 2. 图片混合</span><br><span class="line">        color: Colors.red,</span><br><span class="line">        colorBlendMode: BlendMode.overlay,</span><br><span class="line">        </span><br><span class="line">        // 3. reap</span><br><span class="line">        repeat: ImageRepeat.repeat,</span><br><span class="line">      ),</span><br><span class="line">      width: 300.0,</span><br><span class="line">      height: 200.0,</span><br><span class="line">      color: Colors.lightBlue,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ListView-列表组件"><a href="#ListView-列表组件" class="headerlink" title="ListView 列表组件"></a>ListView 列表组件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyListView extends StatelessWidget&#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext contex)&#123;</span><br><span class="line">    </span><br><span class="line">    return ListView(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        new ListTile(</span><br><span class="line">              leading: new Icon(Icons.camera),</span><br><span class="line">              title: Text(&apos;相册&apos;),</span><br><span class="line">            ),</span><br><span class="line">            </span><br><span class="line">            new ListTile(</span><br><span class="line">              leading: new Icon(Icons.camera_alt),</span><br><span class="line">              title: Text(&apos;相机&apos;),</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            new ListTile(</span><br><span class="line">              leading: new Icon(Icons.camera_enhance),</span><br><span class="line">              title: Text(&apos;相机1&apos;),</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            new ListTile(</span><br><span class="line">              leading: new Icon(Icons.camera_front),</span><br><span class="line">              title: Text(&apos;相机2&apos;),</span><br><span class="line">            ),</span><br><span class="line"></span><br><span class="line">            new ListTile(</span><br><span class="line">              leading: new Icon(Icons.camera_rear),</span><br><span class="line">              title: Text(&apos;相机3&apos;),</span><br><span class="line">            ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ListView-builder-适合列表项比较多（或者无限）的情况"><a href="#ListView-builder-适合列表项比较多（或者无限）的情况" class="headerlink" title="ListView.builder 适合列表项比较多（或者无限）的情况"></a>ListView.builder 适合列表项比较多（或者无限）的情况</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class MyListViewBuilder extends StatelessWidget &#123;</span><br><span class="line">  </span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context)&#123;</span><br><span class="line">    return ListView.builder(</span><br><span class="line">      itemCount: 100, // 数量</span><br><span class="line">      itemExtent: 40, // Tile 高度</span><br><span class="line">      itemBuilder: (BuildContext context, int index)&#123;</span><br><span class="line">        return ListTile(title: Text(&quot;$index&quot;));</span><br><span class="line">      &#125;</span><br><span class="line">    ); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="横向列表"><a href="#横向列表" class="headerlink" title="横向列表"></a>横向列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class MyHorizontalListView extends StatelessWidget &#123;</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      height: 100,</span><br><span class="line">      child: ListView(</span><br><span class="line">        // 设置滚动方式</span><br><span class="line">        scrollDirection: Axis.horizontal,</span><br><span class="line">        children: &lt;Widget&gt;[</span><br><span class="line">          new Container(</span><br><span class="line">            width: 180.0,</span><br><span class="line">            color: Colors.green,</span><br><span class="line">          ),</span><br><span class="line">          new Container(</span><br><span class="line">            width: 180.0,</span><br><span class="line">            color: Colors.yellow,</span><br><span class="line">          ),</span><br><span class="line">          new Container(</span><br><span class="line">            width: 180.0,</span><br><span class="line">            color: Colors.blue,</span><br><span class="line">          ),</span><br><span class="line">          new Container(</span><br><span class="line">            width: 180.0,</span><br><span class="line">            color: Colors.cyan,</span><br><span class="line">          ),</span><br><span class="line">          new Container(</span><br><span class="line">            width: 180.0,</span><br><span class="line">            color: Colors.purple,</span><br><span class="line">          ),</span><br><span class="line">        ],</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态列表和构造方法的创建"><a href="#动态列表和构造方法的创建" class="headerlink" title="动态列表和构造方法的创建"></a>动态列表和构造方法的创建</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class MyDynamicListView extends StatelessWidget &#123;</span><br><span class="line">  // 声明参数</span><br><span class="line">  final List&lt;String&gt; items;</span><br><span class="line">  // 构造方法</span><br><span class="line">  MyDynamicListView(&#123;Key key, @required this.items&#125;):super(key:key);</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return Container(</span><br><span class="line">      child: new ListView.builder(</span><br><span class="line">          itemCount: items.length,</span><br><span class="line">          itemBuilder: (context, index)&#123;</span><br><span class="line">            return ListTile(</span><br><span class="line">              title: new Text(&apos;通过构造方法创建的动态列表$&#123;items[index]&#125;&apos;),</span><br><span class="line">            );</span><br><span class="line">          &#125;,</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GridView-网格列表的使用"><a href="#GridView-网格列表的使用" class="headerlink" title="GridView 网格列表的使用"></a>GridView 网格列表的使用</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/GCD%20%E4%BF%A1%E5%8F%B7%E9%87%8F/"/>
      <url>/2019/06/18/GCD%20%E4%BF%A1%E5%8F%B7%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>GCD信号量用法</p><p>对于异步网络请求相互依赖问题一般用三种方式解决：</p><ul><li>网络请求嵌套</li><li>使用 BlockOperation </li><li>GCD DispatchGroup</li><li>GCD semaphore（信号量）</li></ul><h3 id="GCD-信号量"><a href="#GCD-信号量" class="headerlink" title="GCD 信号量"></a>GCD 信号量</h3><ul><li>semaphore 值 &lt;= 0 阻塞</li><li>semaphore semaphore.signal() 使信号量值增加</li><li>semaphore.wait() 等待，可设置时长</li></ul><p>request – 3 依赖 request – 1 和 request – 2，1 和 2 无需关注顺序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">private func gcdSemaphore() &#123;</span><br><span class="line">       let semaphore = DispatchSemaphore(value: 0)</span><br><span class="line">       DispatchQueue.global().async &#123;</span><br><span class="line">           for i in 0...300 &#123;</span><br><span class="line">               print(&quot;request -- 1&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">           semaphore.signal()</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       DispatchQueue.global().async &#123;</span><br><span class="line">           for i in 0...200 &#123;</span><br><span class="line">               print(&quot;request -- 2&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">           semaphore.signal()</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line">       DispatchQueue.global().async &#123;</span><br><span class="line">           semaphore.wait()</span><br><span class="line">           semaphore.wait()</span><br><span class="line">           for i in 0...160 &#123;</span><br><span class="line">               print(&quot;request -- 3&quot;)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>request – 3 ，request – 2 和 request – 1，依次相互依赖</p><pre><code>private func gcdSemaphore() {        let semaphore = DispatchSemaphore(value: 0)        DispatchQueue.global().async {            for i in 0...300 {                print(&quot;request -- 1&quot;)            }            semaphore.signal()        }        DispatchQueue.global().async {            semaphore.wait()            for i in 0...200 {                print(&quot;request -- 2&quot;)            }            semaphore.signal()        }        DispatchQueue.global().async {            semaphore.wait()            for i in 0...160 {                print(&quot;request -- 3&quot;)            }        }    }</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/Charles%20%E6%8A%93%E5%8C%85/"/>
      <url>/2019/06/18/Charles%20%E6%8A%93%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<p>Charles 抓包</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>简单理解如下：</p><ul><li><p>正常请求</p><p>  客户端 ——&gt; 服务器</p></li></ul><ul><li><p>Charles 抓包</p><p>  客户端 ——&gt;  代理 （Charles）——&gt; 服务器</p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles官网</a></p><p>破解版本请自行百度</p><p><strong>重要说明安装之前请暂时关闭电脑的VPN</strong></p><p><strong>重要说明安装之前请暂时关闭电脑的VPN</strong></p><p><strong>重要说明安装之前请暂时关闭电脑的VPN</strong></p><h3 id="启动Charles"><a href="#启动Charles" class="headerlink" title="启动Charles"></a>启动Charles</h3><h3 id="安装Charles证书"><a href="#安装Charles证书" class="headerlink" title="安装Charles证书"></a>安装Charles证书</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuumd2nkoj320y0j6jtz.jpg" alt></p><pre><code>如果安装失败，请检查以前是否已经安装过，如果已经安装过并且已经失效，请删除失效证书后再安装</code></pre><h3 id="打开钥匙串–-gt-选择Charles-CA-gt-双击证书-–-gt-信任证书"><a href="#打开钥匙串–-gt-选择Charles-CA-gt-双击证书-–-gt-信任证书" class="headerlink" title="打开钥匙串–&gt; 选择Charles CA -&gt; 双击证书 –&gt; 信任证书"></a>打开钥匙串–&gt; 选择Charles CA -&gt; 双击证书 –&gt; 信任证书</h3><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuuq2z76mj31as0ri76z.jpg" alt></p><h3 id="设置-https"><a href="#设置-https" class="headerlink" title="设置 https"></a>设置 https</h3><pre><code>- Proxy -&gt; SSL Proxying Settings -&gt; SSL Proxying -&gt; Add- Host: * 为需要过滤的域名地址,- *: 表示不过滤Port, 固定为443 `*`表示任意端口</code></pre><p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuv3ii2bkj30wm0ocmye.jpg" alt></p><h2 id="Mac-抓包"><a href="#Mac-抓包" class="headerlink" title="Mac 抓包"></a>Mac 抓包</h2><ul><li><p>Proxy -&gt; macOS Proxy （☑️）</p><p>  <img src="https://ws2.sinaimg.cn/large/006tNc79ly1fyuv7zqgaij31v00l0wik.jpg" alt></p></li></ul><h2 id="真机抓包"><a href="#真机抓包" class="headerlink" title="真机抓包"></a>真机抓包</h2><p>此时可以将 macOS Proxy 选项中的 ✅ 去掉，</p><h3 id="Mac与iPhone连接必须同一网络"><a href="#Mac与iPhone连接必须同一网络" class="headerlink" title="Mac与iPhone连接必须同一网络"></a>Mac与iPhone连接必须同一网络</h3><h3 id="设置代理端口号"><a href="#设置代理端口号" class="headerlink" title="设置代理端口号"></a>设置代理端口号</h3><p><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fyuve5e6mbj31240u0wnu.jpg" alt></p><h3 id="手机安装证书"><a href="#手机安装证书" class="headerlink" title="手机安装证书"></a>手机安装证书</h3><ul><li><p>安装手机证书</p><p>  <img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuvn5p8ijj31zi0iuq5h.jpg" alt></p></li><li><p>安装完成后弹窗</p><p>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyuvln2bycj31b20cq0tz.jpg" alt></p></li></ul><ul><li><p>查看mac 地址，为手机设置代理</p><ol><li><p>根据安装手机证书后的弹窗显示IP配置</p></li><li><p>Charles –&gt; Help –&gt; Loca IP Address</p><p> <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyuvgh515wj30uo0k0dhh.jpg" alt></p></li><li><p>打开电脑网络设置查看</p><p> <img src="https://ws2.sinaimg.cn/large/006tNc79ly1fyuvic8h7vj30yo0u0dl3.jpg" alt></p></li></ol></li></ul><ul><li><p>设置代理</p><p>  第一步<br>  <img src="https://ws1.sinaimg.cn/large/006tNc79ly1fyuvzrnksjj30oo0g8t96.jpg" alt></p><p>  第二步<br>  <img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuvztfs46j30pu16uq4f.jpg" alt></p><p>  第三步<br>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyuvzv0wdzj30q216wq46.jpg" alt></p></li><li><p>根据弹窗提示，在手机浏览器下载并安装证书</p><p>  <img src="https://ws3.sinaimg.cn/large/006tNc79ly1fzej631vkbj30ve06gmya.jpg" alt></p></li></ul><ul><li><p>手机信任证书 </p><ul><li><p>设置 –&gt; 通用 –&gt; 关于本机 –&gt; 证书信任设置</p><p> <img src="https://ws3.sinaimg.cn/large/006tNc79ly1fyuvzqy9shj31310u0doe.jpg" alt></p></li></ul></li></ul><h3 id="模拟器抓包"><a href="#模拟器抓包" class="headerlink" title="模拟器抓包"></a>模拟器抓包</h3><ul><li><p>安装模拟器证书</p><p>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyux3vn7cbj31d80imaij.jpg" alt></p></li><li><p>勾选 <code>macOS Proxy</code> 选项</p><p>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fyux3cejcij30e40j4gmi.jpg" alt></p></li></ul><p>如果失败，请先关闭模拟器，重新启动Charles 再打开模拟器</p><h3 id="使用浏览器打开网页提示不是私密链接"><a href="#使用浏览器打开网页提示不是私密链接" class="headerlink" title="使用浏览器打开网页提示不是私密链接"></a>使用浏览器打开网页提示不是私密链接</h3><p><a href="https://blog.csdn.net/qq_31411389/article/details/79615688" target="_blank" rel="noopener">解决办法</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 入门.md</title>
      <link href="/2019/06/18/Flutterr%E5%85%A5%E9%97%A8/"/>
      <url>/2019/06/18/Flutterr%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>flutter安装</p><p>flutter入门</p><h2 id="flutter-安装"><a href="#flutter-安装" class="headerlink" title="flutter 安装"></a>flutter 安装</h2><h2 id="flutter-项目代码"><a href="#flutter-项目代码" class="headerlink" title="flutter 项目代码"></a>flutter 项目代码</h2><p>fluter 中一切皆是组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 导入头文件</span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">// 程序的入口，main 函数</span><br><span class="line">void main() =&gt; (MyApp());</span><br><span class="line"></span><br><span class="line">// 定义类, 继承</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // 重写</span><br><span class="line">  @override</span><br><span class="line"></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line"></span><br><span class="line">    // 返回一窗口</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title:&apos;Flutter&apos;,</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          title: Text(&apos;flutter 初体验&apos;)</span><br><span class="line">        ),</span><br><span class="line"></span><br><span class="line">        body: Center(</span><br><span class="line">          child: Text(&apos;flutter 学习之路&apos;),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import &apos;package:flutter/material.dart&apos;;</span><br><span class="line"></span><br><span class="line">void main() =&gt; runApp(MyApp());</span><br><span class="line"></span><br><span class="line">class MyApp extends StatelessWidget &#123;</span><br><span class="line">  // This widget is the root of your application.</span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    return MaterialApp(</span><br><span class="line">      title: &apos;Flutter Demo&apos;,</span><br><span class="line">      theme: ThemeData(</span><br><span class="line">        // This is the theme of your application.</span><br><span class="line">        //</span><br><span class="line">        // Try running your application with &quot;flutter run&quot;. You&apos;ll see the</span><br><span class="line">        // application has a blue toolbar. Then, without quitting the app, try</span><br><span class="line">        // changing the primarySwatch below to Colors.green and then invoke</span><br><span class="line">        // &quot;hot reload&quot; (press &quot;r&quot; in the console where you ran &quot;flutter run&quot;,</span><br><span class="line">        // or simply save your changes to &quot;hot reload&quot; in a Flutter IDE).</span><br><span class="line">        // Notice that the counter didn&apos;t reset back to zero; the application</span><br><span class="line">        // is not restarted.</span><br><span class="line">        primarySwatch: Colors.blue,</span><br><span class="line">      ),</span><br><span class="line">      home: MyHomePage(title: &apos;Flutter Demo Home Page&apos;),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MyHomePage extends StatefulWidget &#123;</span><br><span class="line">  MyHomePage(&#123;Key key, this.title&#125;) : super(key: key);</span><br><span class="line"></span><br><span class="line">  // This widget is the home page of your application. It is stateful, meaning</span><br><span class="line">  // that it has a State object (defined below) that contains fields that affect</span><br><span class="line">  // how it looks.</span><br><span class="line"></span><br><span class="line">  // This class is the configuration for the state. It holds the values (in this</span><br><span class="line">  // case the title) provided by the parent (in this case the App widget) and</span><br><span class="line">  // used by the build method of the State. Fields in a Widget subclass are</span><br><span class="line">  // always marked &quot;final&quot;.</span><br><span class="line"></span><br><span class="line">  final String title;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  _MyHomePageState createState() =&gt; _MyHomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class _MyHomePageState extends State&lt;MyHomePage&gt; &#123;</span><br><span class="line">  int _counter = 0;</span><br><span class="line"></span><br><span class="line">  void _incrementCounter() &#123;</span><br><span class="line">    setState(() &#123;</span><br><span class="line">      // This call to setState tells the Flutter framework that something has</span><br><span class="line">      // changed in this State, which causes it to rerun the build method below</span><br><span class="line">      // so that the display can reflect the updated values. If we changed</span><br><span class="line">      // _counter without calling setState(), then the build method would not be</span><br><span class="line">      // called again, and so nothing would appear to happen.</span><br><span class="line">      _counter++;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    // This method is rerun every time setState is called, for instance as done</span><br><span class="line">    // by the _incrementCounter method above.</span><br><span class="line">    //</span><br><span class="line">    // The Flutter framework has been optimized to make rerunning build methods</span><br><span class="line">    // fast, so that you can just rebuild anything that needs updating rather</span><br><span class="line">    // than having to individually change instances of widgets.</span><br><span class="line">    return Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        // Here we take the value from the MyHomePage object that was created by</span><br><span class="line">        // the App.build method, and use it to set our appbar title.</span><br><span class="line">        title: Text(widget.title),</span><br><span class="line">      ),</span><br><span class="line">      body: Center(</span><br><span class="line">        // Center is a layout widget. It takes a single child and positions it</span><br><span class="line">        // in the middle of the parent.</span><br><span class="line">        child: Column(</span><br><span class="line">          // Column is also layout widget. It takes a list of children and</span><br><span class="line">          // arranges them vertically. By default, it sizes itself to fit its</span><br><span class="line">          // children horizontally, and tries to be as tall as its parent.</span><br><span class="line">          //</span><br><span class="line">          // Invoke &quot;debug painting&quot; (press &quot;p&quot; in the console, choose the</span><br><span class="line">          // &quot;Toggle Debug Paint&quot; action from the Flutter Inspector in Android</span><br><span class="line">          // Studio, or the &quot;Toggle Debug Paint&quot; command in Visual Studio Code)</span><br><span class="line">          // to see the wireframe for each widget.</span><br><span class="line">          //</span><br><span class="line">          // Column has various properties to control how it sizes itself and</span><br><span class="line">          // how it positions its children. Here we use mainAxisAlignment to</span><br><span class="line">          // center the children vertically; the main axis here is the vertical</span><br><span class="line">          // axis because Columns are vertical (the cross axis would be</span><br><span class="line">          // horizontal).</span><br><span class="line">          mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Text(</span><br><span class="line">              &apos;你可以点击按钮来修改文字，我是热重载的结果&apos;,</span><br><span class="line">            ),</span><br><span class="line">            Text(</span><br><span class="line">              &apos;$_counter&apos;,</span><br><span class="line">              style: Theme.of(context).textTheme.display1,</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      floatingActionButton: FloatingActionButton(</span><br><span class="line">        onPressed: _incrementCounter,</span><br><span class="line">        tooltip: &apos;Increment&apos;,</span><br><span class="line">        child: Icon(Icons.add),</span><br><span class="line">      ), // This trailing comma makes auto-formatting nicer for build methods.</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/06/18/docs/15608702427054/"/>
      <url>/2019/06/18/docs/15608702427054/</url>
      
        <content type="html"><![CDATA[<p># </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Mac安装VirtualBox连接U盘</title>
      <link href="/2018/02/03/Mac%E5%AE%89%E8%A3%85VirtualBox%E8%BF%9E%E6%8E%A5U%E7%9B%98/"/>
      <url>/2018/02/03/Mac%E5%AE%89%E8%A3%85VirtualBox%E8%BF%9E%E6%8E%A5U%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>最近因为某些原因需要再Mac上安装虚拟机,所以选择了VirtualBox安装了<br>win10系统，但是需要再虚拟机的win10中访问U盘数据，遇到的问题是不能连接并且读取到U盘，错误提示不能分配USB内存。。。</p><p>网上找了好多办法都胡扯，根本没有解决…</p><p>解决方法：<br>1.升级VirtualBox到最新版<br>2.关闭当前的虚拟机中的操作系统<br>3.安装增强工具<br>4.重启VirtualBox，回到Mac桌面推出U盘即可</p><p>最重要的就是在第四步</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Block学习探究</title>
      <link href="/2018/01/19/Block%E5%AD%A6%E4%B9%A0%E6%8E%A2%E7%A9%B6/"/>
      <url>/2018/01/19/Block%E5%AD%A6%E4%B9%A0%E6%8E%A2%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="代码及结果"><a href="#代码及结果" class="headerlink" title="代码及结果"></a>代码及结果</h3><ul><li><p>普通局部变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block1 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用__block修饰变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2 &#123;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block2 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)block3 &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block3 -- numer = %zd&quot;, blockNum);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    blockNum = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态常量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block4 &#123;</span><br><span class="line">    </span><br><span class="line">    static NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block4 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>2018-01-19 00:04:13.759416+0800 CycleRetain[91251:2382380] block1 -- numer = 1002018-01-19 00:04:13.760206+0800 CycleRetain[91251:2382380] block2 -- numer = 2002018-01-19 00:04:13.760473+0800 CycleRetain[91251:2382380] block3 -- numer = 2002018-01-19 00:04:13.760603+0800 CycleRetain[91251:2382380] block4 -- numer = 200</code></pre><h3 id="原理及本质"><a href="#原理及本质" class="headerlink" title="原理及本质"></a>原理及本质</h3><p>block 根据创建位置不同,共有三种:栈block,堆block,全局block</p><p>使用<strong>block本质就是为了保证栈上和堆上block内访问和修改的是同一个变量,具体的实现是将</strong>block 修饰的变动自动封装成一个结构体,让他在堆上创建<br>基于OC 底层的runtime 机制<br>block 在内部会有一个指向结构体的指针,当调用block的时候其实就是让block找出对应的指针所指的函数地址进行调用。并传入了block自己本身</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试中常见问题总结(二)</title>
      <link href="/2018/01/18/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-%E4%BA%8C/"/>
      <url>/2018/01/18/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="非正式协议和正式协议"><a href="#非正式协议和正式协议" class="headerlink" title="非正式协议和正式协议"></a>非正式协议和正式协议</h3><p>非正式协议：凡是给NSObject或者其子类添加的类别都是非正式协议<br>正式协议：使用 @protocol 方式声明的方法列表，有 @require 和 @optional 两种类型</p><h3 id="KVC-键值编码"><a href="#KVC-键值编码" class="headerlink" title="KVC 键值编码"></a>KVC 键值编码</h3><p> 之所以可以使用就是因为给 NObject 增加了 NSKeyValueCoding 非正式协议，NSObject 实现了协议，OC中几乎所有的对象都支持KVC，获取值的方法是不通过属性的setter、getter 方法，而是通过属性名称的key间接访问了实例变量，<strong>可以访问私有变量</strong></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // 官方注释</span><br><span class="line"> /* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:.</span><br><span class="line">*/</span><br><span class="line"> - (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure></code></pre><p>如果为nil, 就会自动过滤掉, 此方法常用在字典中过滤空值</p><p>// forKeyPath: 用于符合属性,能够通过层层访问内部属性，相当于调用属性点语法, 拥有forKey 的所有功能</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></code></pre><ul><li>实现原理<ul><li>利用 setValue: forKeyPath: 赋值</li></ul><ol><li>底层实现还是使用 runtime 给对象发消息，先去查找属性是否有setter方法，存在setter 就会通过 setter 方法复制，</li><li>如果没有setter方法，接着查找下是否划线的成员变量，如果有直接给赋值</li><li>如果没有下划线的成员变量，查找是否存在和key值相同的属性，如果有就直接给属性赋值</li><li>如果没有和key值相同的属性，就会执行 setValue: forUndefinedKey: 抛出一个异常程序奔溃，这也是字典转模型中需要实现这个方法的原因</li></ol></li></ul><h3 id="KVO-键值监听"><a href="#KVO-键值监听" class="headerlink" title="KVO 键值监听"></a>KVO 键值监听</h3><p>利用一个key值来找到某个属性并监听某个属性的值的变化发送给观察者，可以理解为简单的观察者模式</p><ul><li><p>KVO 使用</p><ol><li><p>为目标对象的属性添加观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)testKVO &#123;</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    self.person = p;</span><br><span class="line">    p.name = @&quot;哈哈&quot;;</span><br><span class="line">    </span><br><span class="line">    [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    p.name = @&quot;我不是原来的我!你能监听到我 ？？？&quot;;</span><br><span class="line">    p.name = @&quot;看我七十二变&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><pre><code>2. 实现监听的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - kvo 回调方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;KVO监听到的对象是 = %@, 值 = %@ , change = %@&quot;, [object class], keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3. 移除观察者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">   </span><br><span class="line">   [self removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">   NSLog(@&quot;-----控制器销毁-----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>KVO原理</p><p>   类的属性被添加了观察者后，OC底层就会通过Runtime 动态的创建一个这个类的派生类，当前类内部的isa 指针指向了这个派生类，在派生类中重写基类被观察属性的 setter 方法，调用前后会调用 willChangeValueForKey, setValueForKey, didChangeValue 方法, 从而达到监听属性值的方法</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试中常见问题总结</title>
      <link href="/2018/01/17/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2018/01/17/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="OC-的动态性"><a href="#OC-的动态性" class="headerlink" title="OC 的动态性"></a>OC 的动态性</h3><p>OC是基于C语言的，C语言在编译阶段就会确定了调用具体的那个函数，OC它的底层是通过runtime 运行时机制来调用函数，在OC中成为消息发送，具体来说就是在编译阶段OC可以调用任何函数，即时这个函数是没有实现的，只有在运行的时候才会根据isa指针和已经注册的方法列表中找到 IMP(函数指针)真正要调用的那个函数，我们平时写的OC代码，在运行的时候也都是转换成了runtime 的方式进行的，不管是什么方法本质都是发送一个消息</p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul><li>消息机制原理: 根据方法编号列表 SEL 去映射表中查找对应方法的实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person allo] init];</span><br><span class="line"></span><br><span class="line">// 底层的写法</span><br><span class="line">// alloc</span><br><span class="line">Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;),);</span><br><span class="line"></span><br><span class="line">// init</span><br><span class="line">p = objc_msgSend(p, sel-registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">// 调用对象方法本质就是：让对象发消息</span><br><span class="line">objc_msgSend(p, @selector(eat));</span><br><span class="line"></span><br><span class="line">// 调用类方法本质： 让类发消息</span><br><span class="line">objc_msgSend([Person class], @selector(run:), 20);</span><br><span class="line"></span><br><span class="line">// alloc init 也可以理解为：</span><br><span class="line"></span><br><span class="line">id objc = objc_msgSend([NSObject class], @selector(alloc));</span><br><span class="line"></span><br><span class="line">objc = objc_msgSend(objc, @selector(alloc));</span><br></pre></td></tr></table></figure><ul><li><p>runtime 消息机制调用流程</p><p>  每个对象内部都有一个isa指针，指向他自己真实的类来确定调用的是那个类的方法; 每个方法sel都有一个IMP指针（指向现实函数的指针），不管是对象方法还是类方法,都会有一个方法列表</p><ol><li>发消息时根据对象内部的isa 指针去该类所对应的方法类表中查找方法,如果没有去父类中查找</li><li>注册每个方法编号，为了以后快速查找调用</li><li>根据方法编号查找对应方法</li><li>通过isa指针和IMP指针确定最终调用的函数</li></ol></li><li><p>runtime 常见使用</p><ol><li>运行是动态添加方法</li><li>给分类添加属性，（关联属性）</li><li>字典转模型中从先遍历模型属性再从字典中查找相关值实现模型属性赋值</li><li>NSCoding 自动归档解档时对象属性过多时 <code>encodeWithCoder:</code> 和 <code>initWithCoder</code> 两个方法实现</li></ol></li></ul><h3 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h3><ul><li><p>概念</p><p>NSRunloop 是封装 CFRunloopRef 一套纯<code>C</code>的函数，</p></li><li><p>作用</p><ol><li>保持程序持续运行</li><li>处理App中各种事件，具体的有：toches事件, NSTimer 事件, Selector 事件, PerformSelector 事件，source 源等等</li><li>有事件触发时就运行，没有就休眠</li><li>渲染app 中唯一一个主线程上所有UI界面的更新</li></ol></li><li><p>使用和要点</p><ol><li>Runloop 在程序入口 main 函数中就会开启，并且开启的是主线程不会销毁除非退出程序，保证了程序一直运行并能响应事件和交互</li><li>每一条线程都是唯一对应一个Runloop</li><li>主线程不需要创建，因为在程序启动的时候就已经创建了，而子线程的需要手动创建 直接获取currentRunloop 方式（本质是使用了懒加载）</li><li><p>Runloop 对象是利用字典进行存储，因为一一对应，所有key 和value 就是线程和 他所对应的runloop</p></li><li><p>Runloop 中 NSDefaultRunLoopMode 一般情况下主线程运行的 Mode</p></li><li>UIInitializationRunLoopMode 初始化mode,通常不用</li><li>UITrackingRunLoopMode 界面跟踪, 用于scrollView 追踪触摸滑动，保证界面不受其他mode影响</li><li><p>GSEventReceiveRunLoopMode 用于接收系统事件内部 mode， 通常不用</p></li><li><p>NSRunLoopCommonModes, 并不是某种具体的 mode ，开发中使用最多，他是一个组合 mode，组合了 NSDefaultRunLoopMode和 NSRunLoopCommonModes</p></li></ol></li><li><p>Runloop 相关类</p><ol><li>Source 事件源/输入源可以理解为 激发源</li><li>Timer 基于事件触发，CADisplayLink，NSTimer 都是加到了 Runloop，受 Mode 的影响，GCD 定时器不受Runloop 影响</li><li>Observer 相当于runloop 循环中的监听器，时刻监听当前Runloop的运行状态</li><li>休眠没事情做的时候可以停下来，处于休眠状态</li></ol></li><li><p>使用场景</p><ol><li>创建NSTimer</li><li>PersforSelector方法</li><li>常驻线程：（创建后处于等待状态，有事件时响应事件）<ul><li>实现后台收集用户停留时间或者是某个按钮的点击次数，如果使用主线程会不方便，使用runloop解决</li></ul></li><li>AutoreleasePool 自动释放池</li><li>UI更新    </li></ol></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS即时通讯实现二</title>
      <link href="/2018/01/12/iOS%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%AE%9E%E7%8E%B0%E4%BA%8C/"/>
      <url>/2018/01/12/iOS%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%AE%9E%E7%8E%B0%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="实现IM通信所用协议"><a href="#实现IM通信所用协议" class="headerlink" title="实现IM通信所用协议"></a>实现IM通信所用协议</h2><p>几个协议理解</p><p>xmpp 是基于xml协议主要是易于扩展，早起用于PC时代的产品使用，流量大，耗电大交互复杂其实并不适合移动互联网时代的IM产品</p><p>MQTT 协议 适配多平台，需自己扩展好友，群组等功能</p><p>protobut 协议</p><h2 id="封装socket，自己实现"><a href="#封装socket，自己实现" class="headerlink" title="封装socket，自己实现"></a>封装socket，自己实现</h2><p>所要考虑的问题</p><ul><li><p>传输协议选择 </p><ul><li>TCP ？ 一般公司都选用（技术不是很成熟）</li><li>UDP ？QQ 腾讯增加自己的私有协议，保证数据传递的可靠性，解决了丢包，乱序的问题</li></ul></li><li><p>聊天协议选择及代表框架</p><ul><li>Socket ？ CocoaAsyncSocket </li><li>WebSockt ？是传输通讯协议，基于socket封装的一个协议 SocketRocket</li><li>MQTT ？MQTTKit 聊天协议为上层协议</li><li>protobut 协议 ？</li><li>XMPP ？XMPPFramework  聊天协议为上层协议</li><li>自定义</li></ul></li><li><p>传输数据格式</p><ul><li>Json？</li><li>XML？</li><li>ProtocolBuffer？</li></ul></li><li><p>细节相关</p><ul><li>TCP 长连接如何保持，</li><li>心跳机制</li><li>重连机制</li><li>数据安全机制</li></ul></li></ul><h3 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h3><ul><li>CocoaAsyncSocket 的 delegate 用来设置代理处理各个回调</li><li>delegateQueue </li><li>socketQueue 串行队列，贯穿全类并没有任何加锁，确保了socket 操作中每一步都是线程安全的</li><li><p>创建了两个读写队列（本质是数组）</p><ul><li><code>NSMutableArray *readQueue;</code> </li><li><code>NSMutableArray *writeQueue;</code></li></ul></li><li><p>全局数据缓冲: 当前socket未获取完的数据大小</p><ul><li><code>GCDAsyncSocketPreBuffer *preBuffer;</code></li></ul></li><li><p>交替延时变量: 用于进行另一服务端地址请求的延时 </p><ul><li><code>alternateAddressDelay</code></li></ul></li><li><p>connect</p></li><li><p>disconnect</p></li></ul><h2 id="数据粘包-断包"><a href="#数据粘包-断包" class="headerlink" title="数据粘包,断包"></a>数据粘包,断包</h2><ul><li><p>粘包: 如果客户端同一时间发送几条数据，而服务器只收到一大条数据</p><ul><li>原因：</li><li><p>由于传输的是数据流，经过TCP传输后，TCP使用了优化算法将多次间隔较小且数据量小的数据合并成一个大的数据块，因此三条数据合并成了一条</p><p>  <strong>TCP,UDP都可能造成粘包的原因</strong></p></li><li><p>发送端需要等缓冲区满了才发送出去，做成粘包</p></li><li>接收方不及时接收缓冲区的包，造成多个包接收</li></ul></li><li><p>断包: 因为一次发送很大的数据包，缓冲区有限，会分段发送或读取数据</p></li></ul><h2 id="CocoaAsyncSocket的封包，拆包处理"><a href="#CocoaAsyncSocket的封包，拆包处理" class="headerlink" title="CocoaAsyncSocket的封包，拆包处理"></a>CocoaAsyncSocket的封包，拆包处理</h2><ul><li><p>读取数据方法：</p><pre><code>// 有数据时调用，读取当前消息队列中的未读消息- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag</code></pre></li></ul><pre><code>**每次读取数据，每次都必须手动调用上述 readData 方法超时设置为不超时才能触发消息回调的代理****因此在第一连接时调用，再在接到消息时调用，上述方法就可以达到每次收到消息都会触发读取消息的代理**以上做法存在的问题就是没有考虑数据的拆包会有粘包情况，这时候需要用下面两个`read`方法，1. 读取指定长度、2.读取指定边界    // 读取特定长度数据时调用    - (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag    // 读到特定的 data 边界时调用    - (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag**解决办法及具体思路**- 封包：给每个数据包增加一个长度或者加一个开始结束标记，表明数据的长度和类型（根据自己的项目：文本、图片、语音、红包、视频、话题、提问等等）    - 可以在数据包之后加一个结束标识符，解决了传输过程中丢包，丢失头部信息的错误包读取，读到这样的就丢弃直接读下一个数据包- 拆包：获取每个包的标记，根据标记的数据长度获取数据，最后根据类型处理数据,最后读取数据包头部的边界</code></pre><ul><li><p>利用缓冲区对数据进行读取</p><ul><li>创建读取数据包</li><li>添加到读取的队列中</li><li>从队列中取出读取任务包 </li><li><p>使用偏移量 <code>maxLength</code> 读取数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)readDataWithTimeout:(NSTimeInterval)timeout</span><br><span class="line">                     buffer:(NSMutableData *)buffer</span><br><span class="line">               bufferOffset:(NSUInteger)offset</span><br><span class="line">                  maxLength:(NSUInteger)length</span><br><span class="line">                        tag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">if (offset &gt; [buffer length]) &#123;</span><br><span class="line">LogWarn(@&quot;Cannot read: offset &gt; [buffer length]&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 创建读取数据包</span><br><span class="line">GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer</span><br><span class="line">                                                          startOffset:offset</span><br><span class="line">                                                            maxLength:length</span><br><span class="line">                                                              timeout:timeout</span><br><span class="line">                                                           readLength:0</span><br><span class="line">                                                           terminator:nil</span><br><span class="line">                                                                  tag:tag];</span><br><span class="line"></span><br><span class="line">dispatch_async(socketQueue, ^&#123; @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">LogTrace();</span><br><span class="line"></span><br><span class="line">if ((flags &amp; kSocketStarted) &amp;&amp; !(flags &amp; kForbidReadsWrites))</span><br><span class="line">&#123;</span><br><span class="line">// 2. 向读的队列添加任务包</span><br><span class="line">[readQueue addObject:packet];</span><br><span class="line">// 3. 从队列中取出读取任务包 </span><br><span class="line">[self maybeDequeueRead];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">// Do not rely on the block being run in order to release the packet,</span><br><span class="line">// as the queue might get released without the block completing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>doReadData 方法时读取数据的核心方法</p><ul><li>如果读取对列中没有数据，就去判是否是上次已经读取了数据，但是因为没有目前还没有读取到数据的标记，这是正好设置了 read 方法中的超时时间，所以要断开socket 连接</li></ul><p><img src="https://www.jianshu.com/p/fdd3d429bdb3" alt>                </p><ul><li>接收到数据后在 socket系统进程的数据缓冲区中<ul><li>（基于TLS的分为两种）他们在各自管道中流动，完成数据解密后又流向了全局数据缓冲区<ul><li>CFStreem </li><li>SSLPrebuffer</li></ul></li></ul></li></ul><p>处理数据逻辑： 如果当前读取包长度给明了，则直接流向currentRead，如果数据长度不清楚，那么则去判断这一次读取的长度，和currentRead可用空间长度去对比，如果长度比currentRead可用空间小，则流向currentRead，否则先用prebuffer来缓冲。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul><li>TCP 自带的keep-alive 使用空闲时间来发并且默认超时时间太长是2 小时，</li><li>如果应用使用了socks ，socks proxy会让tcp keep-alive失效，因为socks 协议只管转发TCP层具体的数据包，并不会转发TCP协议内的实现具体细节数据包</li><li><p>TCP 的长连接理论上是一直保持连接的，可以设置 TCP keep-alive的时间 但是实际情况下中，可能出现故障或者是因为防火墙的原因会自动把一定时间段内没有数据交互的连接给断开，心跳机制就可以维持长连接，保持活跃状态</p></li><li><p>iOS 中使用 NSTimer  <code>scheduledTimerWithTimeInterval</code> 需要在调用之前的关键位置设置 fireDate 为未来的某个时间, 然后再需要的时候开启</p></li><li>或者直接使用 <code>timerWithTimeInterval</code> 创建，然后添加到<code>runloop</code>中</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 即使通讯网络知识篇</title>
      <link href="/2018/01/10/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/01/10/%E7%BD%91%E7%BB%9C%E4%B8%83%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>读《图解TCP/IP》第5版以及看过的关于网络文章之后自己的理解</p><p>OSI (Open System Interconnec) 译为 开发式系统互联 七层模型从下到上一次是：物理层 -&gt; 数据链路层 —&gt; 网络层 -&gt; 传输层 -&gt; 会话层 -&gt; 表示层 -》 应用层</p><p>数据每次经过一层之后就会在数据头部增加一个首部信息</p><h5 id="物理层：网卡-网线-集线器-中继器-调制解调器"><a href="#物理层：网卡-网线-集线器-中继器-调制解调器" class="headerlink" title="物理层：网卡,网线,集线器,中继器,调制解调器"></a>物理层：网卡,网线,集线器,中继器,调制解调器</h5><ul><li>定义设备标准，如网线，光纤接口类型，将0和1转化为电信号的强和弱，达到传输<strong>比特流</strong>目的，这层数据叫比特</li></ul><h5 id="数据链路层：网桥-交换机"><a href="#数据链路层：网桥-交换机" class="headerlink" title="数据链路层：网桥,交换机"></a>数据链路层：网桥,交换机</h5><ul><li>传输的地址帧，并且有检测错误功能，保证数据可靠传输， 这层数据叫帧</li></ul><h5 id="网络层：路由器"><a href="#网络层：路由器" class="headerlink" title="网络层：路由器"></a>网络层：路由器</h5><ul><li>两个计算机通信时可能会经过多个数据链路或者通信子网，网络层将数据链路层的帧组成数据包，包中有封装好的包头，其中含有逻辑地址信息（源站点和目的站点），此层为数据包选择合适的路由和交换结点,IP协议产生，这层数据叫着数据包</li></ul><h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><ul><li>解决数据如何在网络中传输，这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等</li></ul><h5 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h5><ul><li>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的</li></ul><h5 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h5><ul><li>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li></ul><h5 id="应用层：HTTP-协议"><a href="#应用层：HTTP-协议" class="headerlink" title="应用层：HTTP 协议"></a>应用层：HTTP 协议</h5><ul><li>如何包装数据</li></ul><p><strong>通常从上到下会分成四层</strong></p><p>TCP/IP 通常是指TCP/IP协议族,是一组不同协议组合在一起构成的协议族</p><ul><li>应用层：FTP 应用层协议</li><li>传输层：TCP,UDP 传输层协议,TCP 提供了一个可靠的服务</li><li>网络层：IP,ICMP 网络层协议，传输时不可靠的</li><li>链路层：以太网协议</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><strong>为了解决不同计算机上进程间通信问题</strong><br>服务器在指定的端口上监听，然后生成一对儿新的socket 进行通讯，一个线程对应一个socket</p><p>英文翻译为“插座”通常称为”套接字”, 本质是对于TCP/IP的封装，有客户端 socket 和 服务端socket </p><ul><li>流式 Socket (STREAM): 是一种面向连接的socket，针对于面向连接的TCP服务应用，因为安全所以效率低</li><li>数据报式Socket (DATAGRAM): 是一种无连接的SOcket，正对于无连接的UDP服务应用，无序，不安全，需要在接收端分析重排或者要求重发，所以效率高</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift加密相关</title>
      <link href="/2018/01/08/Swift%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/01/08/Swift%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>最近公司项目开发中引用了 <code>Swift</code> 与 <code>OC</code> 混编, 涉及到了加密相关, 使用了第三方 <code>CryptoSwift</code>, 以下是使用过程中的简单记录</p><h3 id="CryptoSwift简介"><a href="#CryptoSwift简介" class="headerlink" title="CryptoSwift简介"></a>CryptoSwift简介</h3><ul><li>github: <a href="https://github.com/krzyzanowskim/CryptoSwift">https://github.com/krzyzanowskim/CryptoSwift</a></li><li>使用Swift 编写的加密工具包，支持多种加密算法，如：MD5、SHA1、AES-128, AES-192, AES-256… 等等</li></ul><h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><ul><li><p><code>data</code> 转化为字节数组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bytes = data.bytes</span><br><span class="line">   print(bytes)</span><br></pre></td></tr></table></figure></li><li><p>字节数组转化为 <code>data</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data = Data(bytes: [0x01, 0x02, 0x03])</span><br><span class="line">   print(data)</span><br></pre></td></tr></table></figure></li><li><p>十六进制创建字节</p><pre><code>let bytes_Hex = Array&lt;UInt8&gt;(hex: &quot;0x010203&quot;)print(bytes_Hex)</code></pre></li><li><p>字节转十六进制数</p><pre><code>let hex = bytes_Hex.toHexString()print(hex)       </code></pre></li></ul><ul><li><p>字符串生成字节数组</p><pre><code>let string2bytes = &quot;string&quot;.bytesprint(string2bytes)</code></pre></li></ul><ul><li><p>字节数组 base64</p><pre><code>let bytes1: [UInt8] = [1, 2, 3]let base64Str = bytes1.toBase64()print(base64Str!)</code></pre></li><li><p>字符串base64</p><pre><code>let str0 = &quot;test&quot;let base64Str1 = str0.bytes.toBase64()print(base64Str1!)</code></pre></li></ul><h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><ul><li>MD5（RFC1321）诞生于 1991 年，全称是“Message-Digest Algorithm(信息摘要算法)5”，由 MIT 的计算机安全实验室和 RSA 安全公司共同提出。</li><li><p>之前已经有 MD2、MD3 和 MD4 几种算法。MD5 克服了 MD4 的缺陷，生成 128bit 的摘要信息串，出现之后迅速成为主流算法 </p></li><li><p>字节数组MD5</p><pre><code>let str = &quot;测试test&quot;let bytes = str.bytes// 写法一let digest = bytes.md5().toHexString()print(digest)// 04f47b69e3573867a5b3c1e5edb00789// 写法二let digest1 = Digest.md5(bytes).toHexString()print(digest1)// 04f47b69e3573867a5b3c1e5edb00789</code></pre></li><li><p>Data的MD5值</p><pre><code>/// data MD5let data = Data(str.bytes)let digest3 = data.md5().toHexString()print(digest3)// 04f47b69e3573867a5b3c1e5edb00789</code></pre></li><li><p>字符串MD5</p><pre><code>///写法 一let digest4 = str.md5()print(digest4)// 04f47b69e3573867a5b3c1e5edb00789// 写法二do {    var digest4_2 = MD5()    let _ = try digest4_2.update(withBytes: &quot;测试&quot;.bytes)    let _ = try digest4_2.update(withBytes: &quot;test&quot;.bytes)    let result = try digest4_2.finish()    print(result.toHexString())    //04f47b69e3573867a5b3c1e5edb00789} catch {}    </code></pre></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><p>字节数组SHA值</p><pre><code>let str = &quot;测试test&quot;let bytes = str.bytes//方式一let digest1 = bytes.sha1().toHexString()let digest2 = bytes.sha224().toHexString()let digest3 = bytes.sha256().toHexString()let digest4 = bytes.sha384().toHexString()let digest5 = bytes.sha512().toHexString()print(digest1, digest2, digest3, digest4 ,digest5, separator: &quot;\n&quot;)//方式二let digest6 = Digest.sha1(bytes).toHexString()let digest7 = Digest.sha224(bytes).toHexString()let digest8 = Digest.sha256(bytes).toHexString()let digest9 = Digest.sha384(bytes).toHexString()let digest10 = Digest.sha512(bytes).toHexString()print(digest6, digest7, digest8, digest9 ,digest10, separator: &quot;\n&quot;)</code></pre></li></ul><ul><li><p>Data的SHA值</p><pre><code>let data = Data(bytes: str.bytes)let digest11 = data.sha1().toHexString()let digest12 = data.sha224().toHexString()let digest13 = data.sha256().toHexString()let digest14 = data.sha384().toHexString()let digest15 = data.sha512().toHexString()print(digest11, digest12, digest13, digest14 ,digest15, separator: &quot;\n&quot;)</code></pre></li></ul><ul><li><p>字符串的SHA值</p><pre><code>let digest16 = str.sha1()let digest17 = str.sha224()let digest18 = str.sha256()let digest19 = str.sha384()let digest20 = str.sha512()print(digest16, digest17, digest18, digest19 ,digest20, separator: &quot;\n&quot;)</code></pre></li></ul><pre><code>// 方式一let digest_str = str.sha1()print(digest_str)// 方式二do {    var digest_str = SHA1()    let _ = try digest_str.update(withBytes: Array(&quot;测试&quot;.bytes))    let _ = try digest_str.update(withBytes: Array(&quot;test&quot;.bytes))    let result = try digest_str.finish()    print(result.toHexString())} catch {}</code></pre><h3 id="AES-加密"><a href="#AES-加密" class="headerlink" title="AES 加密"></a>AES 加密</h3><ul><li><p>key：公共密钥</p></li><li><p>IV： 密钥偏移量</p></li><li><p>padding：key 的补码方式</p><pre><code>key 长度不够16 字节时，需要手动填充, zeroPadding 将其补齐至 blockSize 的整数倍zeroPadding 补齐规则:- 将长度补齐至 blockSize 参数的整数倍。比如我们将 blockSize 设置为 AES.blockSize（16）- 如果长度小于 16 字节：则尾部补 0，直到满足 16 字节。- 如果长度大于等于 16 字节，小于 32 字节：则尾部补 0，直到满足 32 字节。- 如果长度大于等于 32 字节，小于 48 字节：则尾部补 0，直到满足 48 字节。 以此类推......</code></pre></li><li><p>补码方式padding, noPadding, zeroPadding, pkcs7, pkcs5, 默认使用 pkcs7,两者写法结果相同</p></li></ul><pre><code>let iv_paddding = &quot;1234567890123456&quot; // 默认是let aes_padding1 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes))let aes_padding2 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes), padding: .pkcs7)            </code></pre><ul><li><p>ECB 模式</p><pre><code>let key = &quot;hangge.com123456&quot;let str = &quot;E蜂通信&quot;print(&quot;加密前 \(str)&quot;)//MARK: 使用ECB 模式， , 使用aes128 加密let aes = try AES(key: key.bytes, blockMode: .ECB)let encrpyted = try aes.encrypt(str.bytes)print(&quot;加密后 \(encrpyted)&quot;, separator: &quot;-----&quot;) /// 解密 let decrypted = try aes.decrypt(encrpyted) print(&quot;解密后 \(decrypted)&quot;) let decryptedString = String(data: Data(decrypted), encoding: .utf8)! print(&quot;解密后字符串 \(decryptedString)&quot;)</code></pre></li></ul><ul><li><p>CBC 模式</p><pre><code>//MARK: 使用CBC 模式, 需要提供一个额外的密钥偏移量 iv    /// 写法 1 --  便捷写法    // 偏移量    let iv = &quot;1234567890123456&quot; // 默认是    // TODO: 随机密钥偏移量    let data = Data(bytes: AES.randomIV(AES.blockSize))    let random_iv = String(data: data, encoding: .utf8)</code></pre></li></ul><pre><code>/// 写法 2 --// 创建密码器let cbc_aes = try AES(key: key.bytes, blockMode: .CBC(iv: iv.bytes))let cbc_aes2 = try AES(key: key, iv: iv)let cbc_aes3 = try AES(key: key, iv: iv)let cbc_encrypted = try cbc_aes.encrypt(str.bytes)let cbc_encrypted2 = try cbc_aes2.encrypt(str.bytes)let cbc_encrypted3 = try cbc_aes3.encrypt(str.bytes)// 便捷写法解密let cbc_decrypted = try cbc_aes.decrypt(cbc_encrypted)let cbc_decryptedData = Data(cbc_decrypted)let cbc_decryptedStr = String(data: cbc_decryptedData, encoding: .utf8)print(cbc_decryptedStr)// 正常写法2 解密let cbc_decrypted2 = try cbc_aes2.decrypt(cbc_encrypted2)let cbc_decryptedStr2 = String(data: Data(cbc_decrypted2), encoding: .utf8)print(cbc_decryptedStr2)// 随机密钥偏移量解密let cbc_decrypted3 = try cbc_aes3.decrypt(cbc_encrypted3)let cbc_decryptedStr3 = String(data: Data(cbc_decrypted3), encoding: .utf8)print(cbc_decryptedStr3)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> AES, Base64, MD5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac 安装MySQL</title>
      <link href="/2017/12/14/Mac-%E5%AE%89%E8%A3%85MySQL/"/>
      <url>/2017/12/14/Mac-%E5%AE%89%E8%A3%85MySQL/</url>
      
        <content type="html"><![CDATA[<p>搭建 <code>XMPP</code> 即使通讯</p><h2 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h2><ul><li><p>安装MySQL 数据库    </p><ul><li><p><a href="https://www.mysql.com/" target="_blank" rel="noopener">官网</a> 下载安装包</p><p><strong>特别强调：不要一直<code>下一步</code>最后的时候会有个弹窗提示你生成root的临时密码，记录一下</strong></p></li></ul></li><li><p>安装数据库管理工具 <code>MySQLWorkbench</code></p><p> 官网安装包下载安装</p></li><li><p>修改数据库 root 密码，</p><p>  打开<code>MySQLWorkbench</code> 随便打开一个SQL 输入安装时记录的密码，确认后提示你修改密码，</p></li><li><p>如果为记住安装时密码，参考下面链接修改</p><p>  <a href="https://www.cnblogs.com/sunny3096/p/7954129.html" target="_blank" rel="noopener"></a> </p></li></ul><h2 id="安装-openfire"><a href="#安装-openfire" class="headerlink" title="安装 openfire"></a>安装 openfire</h2><ul><li><p><a href="https://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="noopener">官网</a> 下载安装包安装</p></li><li><p>安装后需重启系统偏好设置</p></li><li>如果出现右边的管理员配置按钮不能点击，请使用 <code>brew</code> 安装 或者更新 <code>Java</code> 环境，<code>openfire</code> 需要 <code>Java</code> 环境  </li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>本地已有项目添加Pod</title>
      <link href="/2017/12/02/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0Pod/"/>
      <url>/2017/12/02/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0Pod/</url>
      
        <content type="html"><![CDATA[<p>上一篇中主要记录了如何使用 <code>pod</code> 工具自动创建 <code>pod</code> 库并且生成一个测试Demo，这边主要记录给已有的项目添加 <code>pod</code></p><h2 id="创建-podsepc-文件"><a href="#创建-podsepc-文件" class="headerlink" title="创建 .podsepc 文件"></a>创建 .podsepc 文件</h2><ul><li><p><code>cd</code> 到已有项目的根目录执行命令： <code>pod spec create [ProjectName].podspec</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create EmotionKeyboard.podspec</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改编辑-podsepc-文件"><a href="#修改编辑-podsepc-文件" class="headerlink" title="修改编辑 .podsepc 文件"></a>修改编辑 <code>.podsepc</code> 文件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">s.name         = &quot;EmotionKeyboard&quot;</span><br><span class="line">  s.version      = &quot;0.0.1&quot;</span><br><span class="line">  s.summary      = &quot;A  Emotional Keyboard.&quot;</span><br><span class="line">  </span><br><span class="line">  # 此处的格式不能修改</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line"></span><br><span class="line">Swift Emotional Keyboard</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">s.homepage     = &quot;https://github.com/aTreey/EmotionKeyboard&quot;</span><br><span class="line"></span><br><span class="line"># 两种写法，使用下面第二种  </span><br><span class="line"># s.license      = &quot;MIT (example)&quot;</span><br><span class="line">s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line"></span><br><span class="line">s.author             = &#123; &quot;aTree&quot; =&gt; &quot;480814177@qq.com&quot; &#125;</span><br><span class="line"></span><br><span class="line">s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line"></span><br><span class="line">s.source       = &#123; :git =&gt; &quot;https://github.com/aTreey/EmotionKeyboard.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从 .podspec 同级别的目录下起匹配 </span><br><span class="line">s.source_files  = &quot;EmotionKeyboard&quot;, &quot;EmotionKeyboard/Classes/**/*.&#123;h,m&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 设置自己项目中依赖的系统库</span><br><span class="line">s.framework  = &quot;UIKit&quot;</span><br><span class="line">  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 调整文件的目录结构</span><br><span class="line"></span><br><span class="line">- 在项目根目录下新建一个放组件代码的文件夹</span><br><span class="line">- 如果项目中包含 `bundle` 文件, 需要在组件文件夹下新建一个 `Assets` 文件夹，用来存放组件中的资源</span><br><span class="line"></span><br><span class="line">最终结果如下:</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl7ykslj21gc0o80xt.jpg))</span><br><span class="line"></span><br><span class="line">- 创建并添加必要文件</span><br><span class="line"></span><br><span class="line">- `LICENSE` 文件: 开源许可文件, 如果创建项目的时候选择了开源许可就可以自动生成忽略此步骤,如果没有直接拷贝一份其他的工程中的即可</span><br><span class="line">- `README.md` 文件: 主要用来说明你开源库的信息及使用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 验证本地 `.podspec` 文件</span><br><span class="line"></span><br><span class="line">- 错误1: `.podspec `中的文件路径设置错误</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jlboq82j20v807ejug.jpg)</span><br><span class="line"></span><br><span class="line">- 错误2: bundle 文件资源路径错误</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl4shnnj20zq0cwgqf.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 本地验证结果</span><br><span class="line"></span><br><span class="line"> - **EmotionKeyboard passed validation.** 本地验证验证通过</span><br><span class="line"></span><br><span class="line">## 网络验证 `.podspec` 文件 </span><br><span class="line"></span><br><span class="line">- 给 `master` 分支打上 `.podspec` 文件中对应的 `tag` 标签, 提交推送, </span><br><span class="line">- 执行命令</span><br></pre></td></tr></table></figure>pod spec lint<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 网络验证结果</span><br></pre></td></tr></table></figure>EmotionKeyboard.podspec passed validation.```</code></pre><p><strong>本文参考</strong></p><p><a href="http://blog.xianqu.org/2015/08/pod-resources/" target="_blank" rel="noopener">给 Pod 添加资源文件</a></p><p><a href="http://swift.gg/2016/12/15/cocoapods-making-guide/" target="_blank" rel="noopener">基于 Swift 创建 CocoaPods 完全指南</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CocoaPods制作私有pod</title>
      <link href="/2017/11/29/CocoaPods%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89pod/"/>
      <url>/2017/11/29/CocoaPods%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89pod/</url>
      
        <content type="html"><![CDATA[<h2 id="CocoaPods原理"><a href="#CocoaPods原理" class="headerlink" title="CocoaPods原理"></a>CocoaPods原理</h2><p><strong>本文主要记录制作自己的pod库过程</strong></p><p>CocoaPods 是自动化工具，主要用来管理一些开源的第三方框架，或者是制作自己的私有库,开源库,也可以使用它讲自己的项目组件化。</p><p>具体可以参考：</p><ol><li><a href="https://juejin.im/post/58730a25a22b9d0058971144" target="_blank" rel="noopener">细聊 Cocoapods 与 Xcode 工程配置</a></li><li><a href="https://juejin.im/post/59f2c7eaf265da432c2318e5" target="_blank" rel="noopener">你真的会用 CocoaPods 吗?</a></li></ol><h2 id="CocoaPods-安装"><a href="#CocoaPods-安装" class="headerlink" title="CocoaPods 安装"></a>CocoaPods 安装</h2><p><a href="http://www.pluto-y.com/cocoapods-getting-stared/" target="_blank" rel="noopener">安装教程</a></p><h2 id="创建私有索引仓库"><a href="#创建私有索引仓库" class="headerlink" title="创建私有索引仓库"></a>创建私有索引仓库</h2><p>每次使用第三方开源库的时候只需要在 <code>Podfile</code> 文件中指定所用的库然后 <code>Pod install</code> ，这是因为安装pod的时候 <code>pod setup</code> 从<a href="https://github.com/CocoaPods/Specs">远程仓库</a>（索引库） clone到了本地,此仓库中存放了所有支持pod框架的描述信息(包括每个库的各个版本)</p><p>文件目录：</p><pre><code>~/.cocoapods/repos/master</code></pre><ul><li><p>在 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 或者 <a href>coding</a> 上创建一个私有仓库</p></li><li><p>添加私有库到CocoaPods</p><ul><li><p>格式 <code>pod repo add [repoName] (URL)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pod repo add PrivateSpec https://gitee.com/aapenga/PrivateSpec.git </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 创建本地私有库</span><br><span class="line"></span><br><span class="line"> - `cd` 到任意一个文件夹下, 执行 `pod lib create [项目名]`</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> pod lib create PPExcelView</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>将文件放入到生成的 Demo 文件夹 的 <code>Classes</code> 文件目录下</li><li><p><code>cd</code> 到 <code>Example</code> 下(含有 <code>Podfile</code> 文件) 执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>或者</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure></li></ul><p> 此时添加的文件出现在 <code>Dome</code> Pod 的 <code>Development Pods</code> 目录中</p><ul><li><p>从本地验证 pod 是否通过</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure><p>  如果有警告，可以使用 <code>--private</code> 或者 <code>--allow-warnings</code> 忽略</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --private</span><br></pre></td></tr></table></figure><p> <strong>出现     <code>PPExcelView passed validation.</code> 为通过</strong></p></li><li><p>从远程仓库验证 pod </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure><p>  <strong>出现     <code>PPExcelView.podspec passed validation</code> 为通过</strong></p></li></ul><h2 id="推送-podspec-文件到私有仓库"><a href="#推送-podspec-文件到私有仓库" class="headerlink" title="推送 .podspec 文件到私有仓库"></a>推送 <code>.podspec</code> 文件到私有仓库</h2><p><code>cd</code> 到 <code>.podspec</code> 所在的文件下</p><pre><code>pod repo push MyGitSpec PPExcelView.podspec</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Alamofire源码学习总结</title>
      <link href="/2017/04/10/Alamofire%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/04/10/Alamofire%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h4 id="网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"><a href="#网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中" class="headerlink" title="网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"></a>网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中</h4><ul><li><p>如果参数是一个 key-value 形式，Query 格式为：key=value</p></li><li><p>如果参数是一个数组 key = [value1, value2, value3 ….], </p></li><li><p>Query 格式为 key[]=value1&amp;key[]=value2&amp;key[]=value3</p></li><li><p>如果参数是一个字典</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = [“subKey1”:”value1”, “subKey2”:”value2”, “subKey3”:”value3”….],</span><br></pre></td></tr></table></figure><ul><li>Query 的格式为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key[subKey1]=value1&amp;key[subKey2]=value2&amp;key[subKey3]=value3</span><br></pre></td></tr></table></figure><ul><li>Alamfire中的编码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private func query(_ parameters: [String: Any]) -&gt; String &#123;</span><br><span class="line">        var components: [(String, String)] = []</span><br><span class="line">        for key in parameters.keys.sorted(by: &lt;) &#123;</span><br><span class="line">            let value = parameters[key]!</span><br><span class="line">            components += queryComponents(fromKey: key, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        return components.map &#123; &quot;\($0)=\($1)&quot; &#125;.joined(separator: &quot;&amp;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">public func queryComponents(fromKey key: String, value: Any) -&gt; [(String, String)] &#123;</span><br><span class="line">        var components: [(String, String)] = [] // 元祖数组</span><br><span class="line">        if let dictionary = value as? [String: Any] &#123; // value 为字典，key[subKey]=value 形式</span><br><span class="line">            for (nestedKey, value) in dictionary &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[\(nestedKey)]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let array = value as? [Any] &#123; // value为数组， key[]=value 形式 </span><br><span class="line">            for value in array &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let value = value as? NSNumber &#123; // value为 NSNumber</span><br><span class="line">            if value.isBool &#123;</span><br><span class="line">                components.append((escape(key), escape((value.boolValue ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let bool = value as? Bool &#123; // value 为 Bool </span><br><span class="line">            components.append((escape(key), escape((bool ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">        &#125; else &#123; // value 为字符串时 直接转义</span><br><span class="line">            components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">        return components</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>知识点总结</title>
      <link href="/2017/03/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2017/03/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>开发中的知识点总结</p><p>textField</p><p>使用textField自定义搜索框，textField及leftView等属性<br>使用leftView 时需要设置model为始终显示<br>可以设置leftView的frame 调整图片大小<br>IBInsepectable IBDesignable 的使用</p><p>给属性检查器面板中添加属性设置选项<br>IBDesignalbe 实时显示UI控件，需要讲对应的xib和对应类绑定</p><p>增加分类</p><p>新建一个swift 文件，</p><p>使用extension，重写 get set方法<br>使用newValue 时需要判断,注意返回值的类型是否匹配<br>试图切换</p><p>一个控制器中加载不同视图，可以在loadView 方法中自定义根视图</p><p>loadView 使用注意事项<br>如果实现loadView 未调用 super loadView ，sb／xib实效<br>loadView调用时，如果根视图是nil（本质是未调用super loadView），会自动调用loadView 方法初始化根视图，形成递归调用<br>判断当前登陆标识的状态确定是调用 super loadView 还是 把创建自定义的根视图赋值给 view<br>VFL 的使用</p><p>使用之前需要先 关闭frame 的布局才能手动的添加约束 translatesAutoresizingMaskIntoConstraints = false<br>基本动画使用</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Swift3.0学习(三)</title>
      <link href="/2017/03/08/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
      <url>/2017/03/08/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%89)/</url>
      
        <content type="html"><![CDATA[<p>面向对象–必选属性</p><p>构造函数时是分段构造，先构造子类，给’必选属性’设置初始值，然后再构造父类，<br>定义全局变量（属性）时，需要在构造函数中设置初始化变量值<br>super.init()是一个类构造结束<br>重写： override 函数重写（覆盖），如果在重写的方法中 没有super, 父类相关的一些操作就不会被执行<br>重载：函数名相同, 参数的类型 或者参数的个数不同 就形成了函数的重载<br>注意：重载构造函数,并且父类默认的构造函数 init()不重写， 父类默认的构造函数就不能够被访问,不能够确保必选属性设置初始值，只能调用重载的构造函数<br>面向对象–可选属性</p><p>使用KVC给对象设置值<br>注意: 在swift中使用KVC 基本数据类型不能声明为可选项,必须设置为必选项给定初始值</p><p>KVC实现的流程<br>遍历字典的键值 给对象发送 setValue: forKey消息<br>如果key 对象的属性不存在就将消息转发给 setVale: forUndefinedKey:<br>如果存在就直接设置值<br>注意:setVale: forUndefinedKey: 默认抛出异常 不能够super，如果super 相当于没有实现此方法</p><p>面向对象–便利构造函数</p><p>作用：方便快捷的创建对象<br>场景：<br>可检查参数是否正确来实例化<br>实例化控件<br>特点<br>必须以self来调用构造函数<br>指定的构造函数不能被重写，也不能被super调用<br>便利构造函数可被子类继承<br>可以构造失败，返回nil<br>面向对象 – 描述信息</p><p>重写 description 方法，返回值是string类型<br>使用kvc讲对象属性转换为字典<br>将字典转化为string类型</p><pre><code>override var description: String {        let keys = [&quot;name&quot;,&quot;age&quot;,&quot;number&quot;,&quot;sex&quot;]        // 对象转为字典        let dict = self.dictionaryWithValuesForKeys(keys)        // 每个对象都有描述属性        return dict.description    }</code></pre><p>面向对象 – 存储属性</p><p>面向对象 – 计算属性(readOnly)</p><p>只有getter，没有setter<br>只能取值不能赋值<br>每次调用都会被执行，消耗cpu<br>不占内存空间，依赖其他的属性来计算<br>面向对象 – didset 属性设置监察器</p><p>能获取 oldValue 和 newValue 的值<br>通常用来重写setter方法，实现视图绑定模型<br>在一个属性的didset中计算其他属性</p><p>缺点：消耗内存，被计算的属性占内存<br>优点：减少了cpu消耗<br>懒加载</p>]]></content>
      
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift3.0学习(二)</title>
      <link href="/2017/03/05/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <url>/2017/03/05/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/</url>
      
        <content type="html"><![CDATA[<p>字符串</p><p>字符串遍历<br>字符串字节长度<br>字符串长度</p><p>let string = “我是switf,语言”</p><p>   // 字符串遍历<br>   for s in string.characters {<br>       print(s)<br>   }</p><p>   // 字符串的长度<br>   let length = string.characters.count;<br>   print(length)</p><p>   // 字符串字节长度 汉字对应3个字节，英文是1个字节<br>   let characterLength = string.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)<br>   print(characterLength)</p><p>字符串拼接</p><pre><code>let str1 = &quot;你好&quot;   let str2 = &quot;不好&quot;   let a = 20   // 第一种拼接   print(&quot;\(str1)\(str2)\(a)&quot;)   // 第二种拼接   let str = str1 + str2   let strA = str1 + String(a)   print(str)   print(strA)</code></pre><p>截取子串 as 的使用</p><pre><code>let subString = str1.substringToIndex(&quot;小程生生世世&quot;.endIndex);   print(subString)   let subStr = str1.substringFromIndex(&quot;听说&quot;.startIndex)   print(subStr)   let range = str1.rangeOfString(&quot;小程序&quot;)   let subStr1 = str1.substringWithRange(range!)   print(subStr1)   // 截取到某一个位置   let subStr2 = str1.substringFromIndex(str1.endIndex.advancedBy(-2))   print(subStr2)   // 限制截取几个字符   let subStr3 = str1.substringToIndex(str1.startIndex.advancedBy(5, limit: str1.characters.endIndex))   print(subStr3)String 和 NSString 之间的 使用 as 无缝转换let helloString = &quot;我们一起飞&quot;(helloString as NSString).substringWithRange(NSMakeRange(2, 3))数组</code></pre><p>可以放不同类型的元素<br>let不可变数组,var可变数组</p><pre><code>// 初始化一个空数组 [String]声明是一个装有字符串的数组类型   var emptyArray: [String] = [String]()// 可变数组   var array = [&quot;哈哈&quot;,&quot;呵呵&quot;,&quot;嘿嘿&quot;]   array.append(&quot;咯咯&quot;)   print(&quot;array = \(array)&quot;)   // 不可变数组   let array2 = [&quot;可可&quot;,&quot;噗噗&quot;]   // 数组拼接   let arr = array + array2   print(&quot;arr = \(arr)&quot;)   array += array2   print(&quot;array = \(array)&quot;)</code></pre><p>数组遍历</p><pre><code>// 1.    for i in 0 ..&lt; tempArray.count {       print(tempArray[i])   }   // 2.    for obj in tempArray {       print(&quot;第二种方法:\(obj)&quot;)   }   // 3. 快速便利   for (index,value) in tempArray.enumerate() {       print(&quot;index = \(index), value = \(value)&quot;)   }</code></pre><p>字典和OC类似</p><p>函数调用</p><p>必须在函数声明的下面调用内部函数</p><p>可以定义函数的外部参数和内部参数</p><p>可以在参数前面加上 ‘# ’ 表明函数的外部参数和内部参数名称一样 swift3.0 以后废弃</p><p>无参无返回值<br>三种写法</p><pre><code>func demo9() -&gt; Void {       print(&quot;无参无返回值第一种写法&quot;)   }   func demo_9() -&gt; () {       print(&quot;无参无返回值第二种写法&quot;)   }   func demo_99() {       print(&quot;无参无返回值第三种写法&quot;)   }</code></pre><p>有参有返回值</p><pre><code>func demo10(width a: Int, height b: Int) -&gt; Int {   return a * b</code></pre><p>   }</p><p>闭包</p><p>和OC中block类似，<br>和在函数中调用一个内部函数原理相同<br>可当作参数传递<br>在需要时执行闭包实现回调</p><pre><code>// 定义闭包let closure = {() -&gt; () in       print(&quot;闭包实现&quot;)   }   // 执行闭包   closure()</code></pre><p>注意循环引用</p><p>只有两个对象相互强引用或者三个对象相互强引用形成闭环时才会形成循环引用</p><p>weak 和 unsafe_unretained的区别</p><p>__weak iOS5.0 推出，当对象被系统回收时，对象的地址会自动指向nil</p><p>____unsafe_unretained iOS4.0 推出，当对象被系统回收时，对象的地址不会自动指向nil,会造成野指针访问<br>解决办法：(官方推荐)weak - strong -dance 解决循环引用，AFNetworking中</p><p>尾随闭包</p><p>函数的最后一个参数时闭包的时候，函数的参数 ‘()’可以提前关闭，闭包写在 ‘（）’后面，当作尾随闭包来使用</p><p>swift 和 OC 区别</p><p>swift 和 OC语法的快速的对比</p><p>XXX.init(xxx) ==&gt; XXX.(xxx)<br>selector 类型 ==&gt; ‘函数名’<br>对象方法的调用 是 ‘.’ self是可以省略的<br>枚举 枚举名 + 枚举值的名 =&gt; .枚举值的名<br>常量 和变量</p><p>let 声明常量 var 声明变量<br>变量/常量的类型是自动推到的<br>不同类型之间不能够直接运算 需要手动转换数据类型<br>可选项<br>‘?’ 表示表示可选项 可能有值 可能为 nil<br>可选项会自动带上 Optional 字样<br>可选项不能够直接参与运算 需要强制解包<br>‘!’ 表示强制解包 获取可选项中具体的值<br>‘??’ 快速判断可选项是否为nil 如果为 nil 就去取 ‘??’后面的默认值<br>控制流<br>if 没有非零即真的概念 必须制定明确的条件<br>if let 快速赋值 并且判断赋值对象是否为 nil 如果不为nil 就进入分之执行相关逻辑代码<br>guard let 作用和 if let 相反 好处: 可以减少一层分支嵌套<br>where 多重判断 注意 和 &amp;&amp; || 不一样的<br>循环</p><p>for in<br>0..&lt;10<br>0…10<br>字符串</p><p>更加轻量级 更加高效 是 结构体<br>支持快速遍历<br>长度<br>拼接<br>截取 as<br>集合 let 声明不可变的集合 var 声明可变的集合</p><p>声明 []<br>声明一个 空的集合<br>增删改查<br>合并<br>遍历<br>函数</p><p>func 函数名称(外部参数1 内部参数1: 类型, 外部参数2 内部参数2: 类型) -&gt; Int {执行的代码}<br>函数没有返回值的三种方式<br>函数内部函数<br>闭包 () -&gt; () 没有参数没有返回值的闭包类型</p><p>提前准备好的一段可以执行代码块<br>可以当做参数传递<br>在需要的时候执行闭包产生回调的效果<br>在闭包中使用self 需要考虑循环引用<br>函数是一种特殊的闭包</p><p>block 的循环引用的解除<br><strong>weak 和 weak关键字作用类似 当属性对象被回收是 会自动指向nil<br>_</strong>unsafeunretained 和 assgin关键字作用类似 当属性对象被回收是 不会自动指向nil, 会造成野指针访问 weak -strong - dance</p>]]></content>
      
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Swift 3.0 学习</title>
      <link href="/2017/03/01/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <url>/2017/03/01/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%80)/</url>
      
        <content type="html"><![CDATA[<h2 id="和OC区别"><a href="#和OC区别" class="headerlink" title="和OC区别"></a>和OC区别</h2><ul><li>没有了.h 和 .m 文件，没有main.m 文件</li><li>程序入口发生变化 在appdelegate中的 @UIApplicationMain</li><li>每行代码可以不写 ‘;’</li><li>self可以不写，建议不写self，因为闭包中必须要写</li><li>真假表示只有 true／ false，没有非0即真的概念</li><li>类型自动推到</li></ul><h2 id="类型自动推到"><a href="#类型自动推到" class="headerlink" title="类型自动推到"></a>类型自动推到</h2><h2 id="提前指定类型"><a href="#提前指定类型" class="headerlink" title="提前指定类型"></a>提前指定类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let float :Double = 9.6 </span><br><span class="line">print(float)</span><br></pre></td></tr></table></figure><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><ul><li>let 声明常量，有且只有一次赋值机会</li><li>var 声明变量</li><li>尽量选择使用let如需修改值再使用var 系统会报警告</li></ul><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><ul><li>Optional: 表示一个常量或者是变量可能有值可能为nil，在打印的时候会带有Optional字样</li><li>? 表示是一个可选项</li><li>可选项不能参与运算</li><li><p>! 表示可选项中一定要有值，可以强制解包,解包时如果没有值会boom</p></li><li><p>?? 合并空选项 快速判断可选项是否为nil, 如果为nil取后面的默认值，在基本数据类型和字符串使用较多</p></li></ul><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><ul><li>if let</li></ul><p>快速赋值，判断赋值对象是否为nil，如果不为nil，就赋值进入分支<br>生成request是url是一个可选项，需要强制解包或者合并空选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let urlString = &quot;http://www.baidu.com&quot;</span><br><span class="line">let url = NSURL(string: urlString)</span><br><span class="line">let request = NSURLRequest(URL: url!)</span><br><span class="line">print(request)</span><br></pre></td></tr></table></figure><ul><li>以上代码使用if let实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = NSURL(string: urlString) &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>where条件语句配合多重判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if url != nil  &#123;</span><br><span class="line">    if url?.host == &quot;www.baidu.com&quot; &#123;</span><br><span class="line">        let request = NSURLRequest(URL: url!)</span><br><span class="line">        print(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用if let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = url where u.host == &quot;www.baidu.com&quot; &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多重判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = url, s = string &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>guard let 和 if let 相反如果为nil，可以直接返回</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let urlString  = &quot;http://www.baidi.com&quot;</span><br><span class="line">let url = NSURL(string: urlString)</span><br><span class="line">guard let u = url else &#123; return &#125;</span><br><span class="line">    </span><br><span class="line">//程序走到这个地方就表示 u 一定有值</span><br><span class="line">let request = NSURLRequest(URL: u)</span><br><span class="line">print(request)</span><br></pre></td></tr></table></figure><ul><li><p>swith语句</p><ul><li>swift语句中可以case任意类型，</li><li>在OC中只能case整数</li><li>不需要写break,会自动跳出，</li><li>如果需要实现case穿透，需要加入fallthrough语句</li><li>case语句中临时变量不需要写‘{ }’</li><li>可同时case多个值    </li><li>每句case语句中至少要有一行可执行的代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let string = &quot;string1&quot;</span><br><span class="line">       switch string &#123;</span><br><span class="line">       case &quot;string&quot;, &quot;string1&quot;:</span><br><span class="line">           let str = &quot;stringOne&quot;</span><br><span class="line">           print(str)</span><br><span class="line">           </span><br><span class="line">       case &quot;string2&quot;:</span><br><span class="line">           let str = &quot;stringTWO&quot;</span><br><span class="line">           print(str)</span><br><span class="line">           </span><br><span class="line">       case &quot;string3&quot;:</span><br><span class="line">           print(string)</span><br><span class="line">           </span><br><span class="line">       case &quot;string4&quot;:</span><br><span class="line">           print(string)</span><br><span class="line">       default:</span><br><span class="line">           print(&quot;empty&quot;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>switch 中同样能够赋值和使用 where 子句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let point = CGPoint(x: 10, y: 10)</span><br><span class="line">switch point &#123;</span><br><span class="line">case let p where p.x == 0 &amp;&amp; p.y == 0:</span><br><span class="line">    print(&quot;中心点&quot;)</span><br><span class="line">case let p where p.x == 0:</span><br><span class="line">    print(&quot;Y轴&quot;)</span><br><span class="line">case let p where p.y == 0:</span><br><span class="line">    print(&quot;X轴&quot;)</span><br><span class="line">case let p where abs(p.x) == abs(p.y):</span><br><span class="line">    print(&quot;对角线&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ..&lt; 10 &#123; // 不包含10  循环范围中两边的值格式必须一直（空格问题）</span><br><span class="line">       print(i)</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">for _ in 0...5 &#123;// 包含5  _ 表示忽略，不关心，只占位</span><br><span class="line">    print(&quot;循环语句&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC和JS交互</title>
      <link href="/2017/02/20/OC%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/02/20/OC%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="WebView相关属性"><a href="#WebView相关属性" class="headerlink" title="WebView相关属性"></a>WebView相关属性</h3><p>autoResizingMask 是UIView的属性,作用是实现子控件相对于父控件的自动布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">autoResizingMask 是UIViewAutoresizing 默认是 UIViewAutoresizingNone</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingNone = 0,</span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,</span><br><span class="line">UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,</span><br><span class="line">UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,</span><br><span class="line">UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,</span><br><span class="line">UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,</span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br></pre></td></tr></table></figure><p>各属性解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">UIViewAutoresizingNone</span><br><span class="line">不会随父视图的改变而改变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin</span><br><span class="line"></span><br><span class="line">自动调整view与父视图左边距，以保证右边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleWidth</span><br><span class="line">自动调整view的宽度，保证左边距和右边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleRightMargin</span><br><span class="line">自动调整view与父视图右边距，以保证左边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleTopMargin</span><br><span class="line">自动调整view与父视图上边距，以保证下边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleHeight</span><br><span class="line">自动调整view的高度，以保证上边距和下边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin</span><br><span class="line">自动调整view与父视图的下边距，以保证上边距不变</span><br></pre></td></tr></table></figure><h3 id="OC-调用js"><a href="#OC-调用js" class="headerlink" title="OC 调用js"></a>OC 调用js</h3><p><code>webViewDidFinishLoad:(UIWebView *)webView</code>方法中</p><ul><li>删除增加结点</li><li>添加点击事件</li></ul><h3 id="js调用OC"><a href="#js调用OC" class="headerlink" title="js调用OC"></a>js调用OC</h3><p><code>webView:(UIWebview )webView shouldStartLoadWithRequest:(NSURLRequest )request</code>方法中</p><p>调用js页面点击按钮后保存图片到相册,必须调用系统提供的方法，不能自己自定义方法</p>]]></content>
      
      
      
        <tags>
            
            <tag> OC, JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDWebImage的用法及原理</title>
      <link href="/2017/02/08/SDWebImage%E5%AD%A6%E4%B9%A0/"/>
      <url>/2017/02/08/SDWebImage%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="SDWebImage-介绍"><a href="#SDWebImage-介绍" class="headerlink" title="SDWebImage 介绍"></a>SDWebImage 介绍</h3><p>SDWebImage 是用于网络中下载且缓存图片，并设置图片到对应的控件或上</p><p>Demo: <a href="https://github.com/aTreey/DownImage.git">https://github.com/aTreey/DownImage.git</a></p><ul><li>提供了UIImageView的category用来加载网络图片并且下载的图片的缓存进行管理</li><li>采用异步方式来下载，确保不会阻塞主线程，memory＋disk来缓存网络图片，自动管理缓存</li><li>支持GIF动画，[self.imageView setImageWithURL:[[NSBundle mainBundle] URLForResource:@”xx.gif” withExtension:nil];</li><li>支持WebP格式</li><li>同一个URL的网络图片不会被重复下载</li><li>失效的URL不会被无限重试</li></ul><h3 id="SDWebImage-的使用"><a href="#SDWebImage-的使用" class="headerlink" title="SDWebImage 的使用"></a>SDWebImage 的使用</h3><p>克隆</p><p>git clone <a href="https://github.com/rs/SDWebImage.git">https://github.com/rs/SDWebImage.git</a><br>使用以上命令克隆会报错，框架中Vendors文件夹中的文件未能全部下载导致报错</p><p>解决办法：<a href="https://github.com/rs/SDWebImage/blob/master/Docs/ManualInstallation.md">https://github.com/rs/SDWebImage/blob/master/Docs/ManualInstallation.md</a></p><p>git clone –recursive <a href="https://github.com/rs/SDWebImage.git">https://github.com/rs/SDWebImage.git</a></p><p>文件全部下载</p><p>自定义operation 加入NSOperationQueue中</p><ul><li>自定义NSOperation,<br>重写main方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)main &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_urlStr];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line"></span><br><span class="line">    if (_finishBlock) &#123;</span><br><span class="line">        _finishBlock(image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个NSOperation对象可以通过调用start方法来执行任务，默认是同步执行的。也可以将NSOperation添加到一个NSOperationQueue(操作队列)中去执行，而且是异步执行的<br>创建队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperationQueue *)downLoadQueue &#123;</span><br><span class="line">    if (!_downLoadQueue) _downLoadQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    return _downLoadQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加一个任务到队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[_downLoadQueue addOperation:operation];</span><br><span class="line">添加一组operation, 是否阻塞当前线程</span><br><span class="line"></span><br><span class="line">[_downLoadQueue addOperations:@[operation] waitUntilFinished:NO];</span><br><span class="line">添加一个block 形式的operation</span><br><span class="line"></span><br><span class="line">[_downLoadQueue addOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;执行一个新的线程&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>NSOperation 添加到 queue之后，通常短时间内就会执行，但是如果存在依赖，或者整个queue被暂停等原因，也可能会需要等待</p></li><li><p>NSOperation添加到queue之后，绝不要修改NSOperation对象的状态，因为NSOperation对象可能会在任何时候运行，因此改变NSOperation对象的依赖或者数据会产生不利的影响，只能查看NSOperation 对象的状态，比如是否正在运行、等待运行、已经完成等</p></li></ol><ul><li>NSOperation 添加依赖，<br>依赖关系不局限于相同的queue 中的NSOperation对象，可以夸队列进行依赖，但是不能循环依赖，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// NSOperation 添加依赖</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *testQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operation1 NSThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operation2 NSThead = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 添加依赖，1 依赖于 2，只有2 执行完之后才执行1</span><br><span class="line">    [operation1 addDependency:operation2];</span><br><span class="line">    // 加入到队列</span><br><span class="line">    [testQueue addOperation:operation1];</span><br><span class="line">    [testQueue addOperation:operation2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>修改Operation的执行顺序<br>对于添加到queue中的operation执行顺序有一下2点决定<br>operation 是否已经准备好，是否添加了依赖<br>根据多有operations的相对优先性来决定，优先等级是operation对象本身的一个属性，默认都是“普通”优先级，可以通过setQueuePriority方法提高和降低优先级，优先级只能用于相同 queue 中的 operation，多个queue中operation的优先级相互独立，因此不同queue中的低优先级的operation可能比高优先级的operation更早执行<br>注意优先级和依赖不能相互替代，优先级只是对已经准备好的operation确定执行顺序，先满足依赖，然后再看已经准备好的operation中的优先级</p></li><li><p>设置 queue 的最大并发数，队列中最多同时运行几条线程<br>虽然NSOperationQueue类设计用于并发执行Operations,你也可以强制单个queue一次只能执行一个Operation。setMaxConcurrentOperationCount:方法可以配置queue的最大并发操作数量。设为1就表示queue每次只能执行一个操作。不过operation执行的顺序仍然依赖于其它因素,比如operation是否准备好和operation的优先级等。因此串行化的operation queue并不等同于GCD中的串行dispatch queue</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 每次只能执行一个操作  </span><br><span class="line">queue.maxConcurrentOperationCount = 1;  </span><br><span class="line">// 或者这样写  </span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure><ul><li>取消 operations<br>一旦添加到operation queue,queue就拥有了这个Operation对象并且不能被删除,只能取消。调用Operation对象的cancel方法取消单个操作,也可以调用operation queue的cancelAllOperations方法取消当前queue中的所有操作, 使用cancel属性来判断是否已经取消了</li></ul><p>[operation cacel] 只是打了一个死亡标记, 并没有正真意义上的取消,称为 “自杀“,需要在被取消的任务中时时判断是否取消(在程序的关键处), 如果取消,结束任务, 具体是指在自定义的 operation 的main方法中结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[queue cancelAllOperations] 由队列来取消，称为 “他杀”</span><br><span class="line"></span><br><span class="line">// 取消单个操作  </span><br><span class="line">[operation cancel];</span><br><span class="line">// 取消queue中所有的操作  </span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure><ul><li>等待operation 完成</li></ul><p>为了最佳的性能,你应该设计你的应用尽可能地异步操作,让应用在Operation正在执行时可以去处理其它事情。如果需要在当前线程中处理operation完成后的结果,可以使用NSOperation的waitUntilFinished方法阻塞当前线程，等待operation完成。通常我们应该避免编写这样的代码,阻塞当前线程可能是一种简便的解决方案,但是它引入了更多的串行代码,限制了整个应用的并发性,同时也降低了用户体验。绝对不要在应用主线程中等待一个Operation,只能在第二或次要线程中等待。阻塞主线程将导致应用无法响应用户事件,应用也将表现为无响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 会阻塞当前线程，等到某个operation执行完毕  </span><br><span class="line">[operation waitUntilFinished];</span><br></pre></td></tr></table></figure></p><p>除了等待单个Operation完成,你也可以同时等待一个queue中的所有操作,使用NSOperationQueue的waitUntilAllOperationsAreFinished方法。注意：在等待一个 queue时,应用的其它线程仍然可以往queue中添加Operation,因此可能会加长线程的等待时间。</p><p>// 阻塞当前线程，等待queue的所有操作执行完毕<br>[queue waitUntilAllOperationsAreFinished];<br>暂停和继续operation<br>如果你想临时暂停Operations的执行,可以使用queue的setSuspended:方法暂停queue。不过暂停一个queue不会导致正在执行的operation在任务中途暂停,只是简单地阻止调度新Operation执行。你可以在响应用户请求时,暂停一个queue来暂停等待中的任务。稍后根据用户的请求,可以再次调用setSuspended:方法继续queue中operation的执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 暂停queue  </span><br><span class="line">[queue setSuspended:YES];  </span><br><span class="line"></span><br><span class="line">// 继续queue  </span><br><span class="line">[queue setSuspended:NO];</span><br></pre></td></tr></table></figure></p><h3 id="增加Manager管理类，"><a href="#增加Manager管理类，" class="headerlink" title="增加Manager管理类，"></a>增加Manager管理类，</h3><p>作用：</p><ul><li>下载队列</li><li>图像缓存</li><li>操作缓存（内存缓存）</li><li>沙盒缓存</li><li>防止错乱,取消老的未开始下载的操作</li><li>图片显示逻辑：内存缓存 – 沙盒缓存 – 网络下载</li><li>图片缓存逻辑：下载完成 – 缓存沙盒 – 加载到内存</li></ul><p>注意：缓存到本地时只能保存property列表里的对象（NSData, NSDate, NSNumber, NSString, NSArray, NSDictory）, 图片需要转化为二进制数据</p><h3 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h3><ul><li>SDWebImageDownloader 下完图片后都需要手动设置给UIImageView</li><li>SDWebImageManager 下完图片后都需要手动设置给UIImageView</li><li>下载后要显示可以使用 sd_setImageWithURL 方法</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SDWebImage </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2017/02/02/iOS%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <url>/2017/02/02/iOS%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h3 id="iOS中静态库动态库介绍及编译"><a href="#iOS中静态库动态库介绍及编译" class="headerlink" title="iOS中静态库动态库介绍及编译"></a>iOS中静态库动态库介绍及编译</h3><ul><li>静态库</li></ul><p>iOS中根据源码的公开情况可分为2种</p><ul><li>开源库<br>源代码公开，能够看到具体的代码实现</li></ul><p>比如 SDWebImage AFNetworking。。。</p><ul><li><p>闭源库<br>不公开源代码， 是经过编译后的二进制文件， 看不到具体实现<br>主要分为：静态库、动态库</p></li><li><p>存在形式</p></li></ul><p>静态库： .a 和 .framework<br>动态库：.tbd 和 .framework (iOS 9 之前是 .dylib, iOS 9 之后取消了 .dylib 而使用 .tbd 来代替 .dylib )</p><p>.framework 的库可以是静态库也可以是静态库， 凡是系统的 .framework 都是动态库，第三方的基本上全是静态中</p><ul><li>两者区别</li></ul><p>静态库：链接时会被完整的复制到可执行文件中，每次被使用都会被复制<br>动态库：链接时不复制，程序运行时由系统动态加载到内存中，供程序调用，系统只加载一次，多个程序可以公用，节省内存</p><h3 id="静态库编译"><a href="#静态库编译" class="headerlink" title="静态库编译"></a>静态库编译</h3><p>编译时如果使用的是模拟器，生成的 .a 只能模拟器用，真机不可用，生成的 .a 文件在 Debug-iphonesimulator 文件夹下</p><p>编译时如果使用 generic iOS Device，生成的 .a 只能真机而模拟器不可用，生成的 .a 文件在 Debug-iphoneos 文件夹下</p><p>编译静态库时，自己手动创建的类的头文件不会被导出，只是默认导出创建工程时类的头文件</p><p>导出手动添加类的头文件，点击工程名称 –&gt; build Phases –&gt; Copy Files 添加头文件，然后编译</p><ul><li>架构种类</li></ul><p>模拟器：i386 32位架构 (4s~5) ／ x86_64 64位架构 (5s以后机型)<br>真机：armv7 32位架构 (4~4s) ／ armv7s 特殊架构 (5~5C) ／ arm64 64位架构 (5s 以后机型)</p><ul><li><p>架构查看<br>lipo -info xxxx.a<br>默认生成模拟器只生成一种架构 i386 x86_64；真机默认导出两种架构 armv7 ／ arm64</p></li><li><p>合并多个架构</p></li></ul><p>将模拟器的多个架构合并，项目名称–&gt;Build Settings –&gt; Achitectures –&gt; Build Active Architecture Only –&gt; Debug设置为NO<br>合并真机多个架构 按照以上方法运行真机即可<br>合并真机和模拟器架构 cd products lipo -create Debug-iphoneos/xxx.a Debug-iphonessimulator/xxx.a -output xx.a<br>合成 5 个架构 在Build Setting –&gt; Architectures 中手动添加三种架构,再编译合并</p><ul><li>静态库报错</li></ul><p>Undefined symbols for architecture （arm64 ／ armv7 ／ armv7s ／ i386 ／ x86_64），架构包导入出错，静态库有真机与模拟器</p>]]></content>
      
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步下载图片</title>
      <link href="/2017/01/18/%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
      <url>/2017/01/18/%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h3 id="异步下载"><a href="#异步下载" class="headerlink" title="异步下载"></a>异步下载</h3><p>同步发送网络请求会卡UI线程，采用异步来下载图片。</p><p><strong>异步下载存在的问题</strong></p><ul><li><p>错行问题</p><ul><li>解决：使用MVC模式，使数据一对一可解决，</li><li>在MVC中增加image属性后，会导致单个模式的体积增大</li><li>内存占用</li><li>当接收到内存警告时清空图片时需要遍历模型中将image置为nil</li><li>将图片用字典缓存起来达到一对一, 清空内存中的图片时只需要remove字典就ok</li><li>创建下载任务的字典，在开始下载时将正在下载的URL写入到字典中下载完成后将字典中对应的值移除，写入防止来回滑动时重复发送网络请求，下载完后移除是为了防止如果接受到内存警告后下载的图片都已清除，但是下载任务的字典的值为移除就不会再一次去下载图片</li><li><p>缓存下载的图片到沙盒中</p></li><li><p>获取图片下载路径最后一个分隔符后面的字符串作为图片名保存</p></li></ul></li></ul><p><code>stringByAppendingPathComponent</code> 和 <code>stringByAppendingString</code> 两个方法有区别</p><p><strong>stringByAppendingString 方法是获取caches文件名，在文件夹名后面拼接字符串，在caches上一级目录下创建文件，和caches文件夹属于同一个级别</strong></p><pre><code>// 获取caches文件路径NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);NSString *URL = @&quot;http://wwww.baidu.com/image/123456.png&quot;;NSString *imageName = [URL lastPathComponent];// 拼接路径// 此方法生成的路径在caches文件下目录下NSString *filePath = [cachesPath stringByAppendingPathComponent];// 读取图片if (内存中没有) {    // 沙盒读取    UIImage *sandBoxImage = [UIImage imageWithContetsOfFile:filePath];    **加入到内存中，方便下次加载**} if (sandBoxImage == nil) {    // 下载图片}// 写入到沙盒if (imageData != nil) {    [imageData writeToFile: filePath atomically:NO];}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz 2D绘制形状(二)</title>
      <link href="/2016/12/10/Quartz2D%E7%BB%98%E5%88%B6%E5%BD%A2%E7%8A%B6/"/>
      <url>/2016/12/10/Quartz2D%E7%BB%98%E5%88%B6%E5%BD%A2%E7%8A%B6/</url>
      
        <content type="html"><![CDATA[<p>使用Quartz 2D绘制圆弧，扇形，下载进度以及绘制的图形的填充和描边属性的设置.<br>将贝塞尔路径添加到图形上下文中<br>图形上下文中的状态保存和恢复<br>对图形上下文进行矩阵操作（平移，缩放，选转），实现一些特殊效果</p><h3 id="使用贝塞尔曲线绘制矩形"><a href="#使用贝塞尔曲线绘制矩形" class="headerlink" title="使用贝塞尔曲线绘制矩形"></a>使用贝塞尔曲线绘制矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 20, 30)];</span><br><span class="line">    [[UIColor magentaColor] setStroke];</span><br><span class="line">    [[UIColor brownColor] setFill];</span><br><span class="line">    [path fill]; // 填充</span><br><span class="line">    [path stroke]; // 描边</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 绘制圆角矩形</span><br><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(35, 10, 50, 70) cornerRadius:5.0];</span><br><span class="line">    [[UIColor magentaColor] setStroke];</span><br><span class="line">    [[UIColor cyanColor] setFill];</span><br><span class="line">    [path fill];</span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 画圆</span><br><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(90, 5, 40, 40) cornerRadius:20.0];</span><br><span class="line">    [[UIColor purpleColor] setStroke];</span><br><span class="line">    [[UIColor magentaColor] setFill];</span><br><span class="line">    [path fill];</span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制扇形"><a href="#绘制扇形" class="headerlink" title="绘制扇形"></a>绘制扇形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGPoint center = CGPointMake(200, 50);</span><br><span class="line">UIBezierPath *sectorPath = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_4 clockwise:YES];</span><br><span class="line">[sectorPath addLineToPoint:center];</span><br><span class="line">[[UIColor brownColor] setStroke];</span><br><span class="line">[sectorPath fill];</span><br><span class="line">[sectorPath stroke];</span><br></pre></td></tr></table></figure><h3 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 绘制圆弧</span><br><span class="line">* 参数1: 圆心坐标</span><br><span class="line">* 参数2: 半径</span><br><span class="line">* 参数3: 开始角度</span><br><span class="line">* 参数4: 结束角度 使用弧度制表示</span><br><span class="line">* 参数5: clockwis顺时针方法的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">UIBezierPath *circuLarArcPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 60) radius:50.0 startAngle:0 endAngle:M_PI_2 clockwise:YES];</span><br><span class="line"></span><br><span class="line">[circuLarArcPath moveToPoint:CGPointMake(100, 60)];</span><br><span class="line"></span><br><span class="line">[[UIColor magentaColor] setStroke];</span><br><span class="line">[[UIColor brownColor] setFill];</span><br><span class="line">[circuLarArcPath stroke];</span><br><span class="line">[circuLarArcPath fill];</span><br></pre></td></tr></table></figure><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制文字</span><br><span class="line"> * drawAtPoint 不能换行，当文字过多过长时不会有效果</span><br><span class="line"> * 使用 drawInRect 可以实现换行</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *text = @&quot;我是绘制文字价格就看过几个框架刚开始大家高考的感觉是快乐的关键时刻大家赶快来时的结果看了风水格局来看就哭了感觉树大根深来对抗肌肤抵抗力&quot;;</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *attributeDict  = [NSMutableDictionary dictionary];</span><br><span class="line">attributeDict[NSFontAttributeName] = [UIFont systemFontOfSize:18];</span><br><span class="line"></span><br><span class="line">// 字体颜色</span><br><span class="line">attributeDict[NSForegroundColorAttributeName] = [UIColor greenColor];</span><br><span class="line">// 描边颜色</span><br><span class="line">attributeDict[NSStrokeColorAttributeName] = [UIColor yellowColor];</span><br><span class="line">// 描边宽度</span><br><span class="line">attributeDict[NSStrokeWidthAttributeName] = @1;</span><br><span class="line">//  阴影</span><br><span class="line">NSShadow *shadow = [[NSShadow alloc] init];</span><br><span class="line">shadow.shadowColor = [UIColor redColor];</span><br><span class="line">shadow.shadowOffset = CGSizeMake(1.0, 1.0);</span><br><span class="line"></span><br><span class="line">attributeDict[NSShadowAttributeName] = shadow;</span><br><span class="line"></span><br><span class="line">// 可以换行</span><br><span class="line">[text drawInRect:self.bounds withAttributes:attributeDict];</span><br><span class="line"></span><br><span class="line">// 不换行</span><br><span class="line">[text drawAtPoint:CGPointZero withAttributes:attributeDict];</span><br></pre></td></tr></table></figure><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制图片</span><br><span class="line"> * drawAtPoint 默认绘制的内容尺寸和图片的尺寸一样大</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)drawImage &#123;</span><br><span class="line"></span><br><span class="line">    UIImage *image = [UIImage imageNamed:@&quot;wc_dk&quot;];</span><br><span class="line">    UIImage *image1 = [UIImage imageNamed:@&quot;wc_hq&quot;];</span><br><span class="line"></span><br><span class="line">    [image drawAtPoint:CGPointMake(10, 90)];</span><br><span class="line">    [image1 drawAtPoint:CGPointMake(70, 80)];</span><br><span class="line"></span><br><span class="line">    // 绘制在控件内部，和控件大小一致</span><br><span class="line">    [image1 drawInRect:self.bounds];</span><br><span class="line"></span><br><span class="line">    // 以平铺的方式绘制在控件的内部</span><br><span class="line">    [image1 drawAsPatternInRect:self.bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆形下载进度的绘制"><a href="#圆形下载进度的绘制" class="headerlink" title="圆形下载进度的绘制"></a>圆形下载进度的绘制</h3><p>drawRect 方法不能手动调用，因为图形上下文不能手动创建<br>需要调用setNeedsDisplay方法来重绘，系统会创建图形上下文<br>绘制时用到的定时器，一般不使用NSTimer定时器，因为调度优先级比较低，不会被准时带,界面会出现卡顿的现象<br>CADisplayLink 每次刷新屏幕的时候就会调用，1s刷新 60 次<br>setNeedsDisplay调用此方法时并不是立即调用drawRect方法，只是给给当前控件添加刷新标记，直到下一次屏幕刷新的时候才调用drawRect 方法，正好与CADisplayLink 方法一致，所以界面流畅不会卡顿<br>图形上下文状态栈</p><p>UIBezierPath图形上下文和CGContextRef的图形上下文不是同一个图形上下文</p><p>可以将贝塞尔路径添加到图形上下文中</p><p>也可以保存当前的图形上下文，CGContextSaveGState(ctx);<br>在下一次使用时可以恢复，CGContextRestoreGState(ctx);<br>画两种不同状态的线条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 图形上下文栈的理解</span><br><span class="line">* 画两条状态不同的线段</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 获取上下文</span><br><span class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">// 第一条</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(10, 60)];</span><br><span class="line">[path addLineToPoint:CGPointMake(240, 60)];</span><br><span class="line"></span><br><span class="line">// 把路径添加到上下文</span><br><span class="line">CGContextAddPath(ctx, path.CGPath);</span><br><span class="line"></span><br><span class="line">// 保存上下的状态</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line"></span><br><span class="line">// 设置当前状态</span><br><span class="line">[[UIColor greenColor] setStroke];</span><br><span class="line">//此时设置path 的状态无效，需要设置当前上下文的状态</span><br><span class="line">path.lineWidth = 5.0;</span><br><span class="line">CGContextSetLineWidth(ctx, 5.0);</span><br><span class="line"></span><br><span class="line">// 渲染上下文</span><br><span class="line">CGContextStrokePath(ctx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第二根</span><br><span class="line"></span><br><span class="line">// 可使用第一根的路径，因为每次绘制完成之后都会清除</span><br><span class="line">path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(60, 10)];</span><br><span class="line">[path addLineToPoint:CGPointMake(60, 240)];</span><br><span class="line"></span><br><span class="line">// 添加路径到上下文 需要转换为CGPath</span><br><span class="line">CGContextAddPath(ctx, path.CGPath);</span><br><span class="line"></span><br><span class="line">// 还原之前保存的上下文状态</span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">CGContextStrokePath(ctx);</span><br><span class="line">图形上下文矩阵</span><br><span class="line"></span><br><span class="line">// 使用矩阵</span><br><span class="line"></span><br><span class="line">    // 获取上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">    // 使用贝塞尔路径</span><br><span class="line">    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(-150, -100, 300, 200)];</span><br><span class="line">    [[UIColor cyanColor] setFill];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 以上绘制的图形有一部分看不到，通过对上下文矩阵操作来实现，平移上下文</span><br><span class="line">    // 操作矩阵必须在添加路径之前</span><br><span class="line"></span><br><span class="line">    // 平移</span><br><span class="line">    CGContextTranslateCTM(ctx, 150, 100);</span><br><span class="line"></span><br><span class="line">    // 缩放</span><br><span class="line">    CGContextScaleCTM(ctx, 0.5, 0.5);</span><br><span class="line"></span><br><span class="line">    // 旋转</span><br><span class="line">    // 可以实现点无法计算时的效果</span><br><span class="line">    CGContextRotateCTM(ctx, M_PI_4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 添加路径到上下文</span><br><span class="line">    CGContextAddPath(ctx, ovalPath.CGPath);</span><br><span class="line"></span><br><span class="line">    // 操作矩阵放在添加路径之后无效果</span><br><span class="line">//  CGContextTranslateCTM(ctx, 150, 100);</span><br><span class="line"></span><br><span class="line">    CGContextFillPath(ctx);</span><br><span class="line"></span><br><span class="line">    // 正常的绘制椭圆</span><br><span class="line">//    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 20, 200, 100)];</span><br><span class="line">//    ovalPath.lineWidth = 4.0;</span><br><span class="line">//    [[UIColor magentaColor] setFill];</span><br><span class="line">//    [[UIColor yellowColor] setStroke];</span><br><span class="line">//    [ovalPath stroke];</span><br><span class="line">//    [ovalPath fill];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Quartz 2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCD实现按钮定时亮起</title>
      <link href="/2016/12/05/GCD%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E5%AE%9A%E6%97%B6%E4%BA%AE%E8%B5%B7/"/>
      <url>/2016/12/05/GCD%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E5%AE%9A%E6%97%B6%E4%BA%AE%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p><strong>某些时候需要按钮不能连续点击，需要在一定的时间之后才可以允许交互，或者是实现类似发送验证码的按钮效果，具体做法是采用定时器</strong></p><h2 id="使用GCD定时器"><a href="#使用GCD定时器" class="headerlink" title="使用GCD定时器"></a>使用GCD定时器</h2><h3 id="创建定时器对象"><a href="#创建定时器对象" class="headerlink" title="创建定时器对象"></a>创建定时器对象</h3><pre><code>__block NSInteger time = 30; // 需要强应用</code></pre><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</code></pre><h3 id="创建dispatch源-定时器"><a href="#创建dispatch源-定时器" class="headerlink" title="创建dispatch源(定时器)"></a>创建dispatch源(定时器)</h3><pre><code>(dispatach_source…timer..)</code></pre><ul><li><p>01参数:要创建的source 是什么类型的， </p><p>  <code>(DISPATCH_SOURCE_TYPE_TIMER)定时器</code></p></li><li><p>04参数:队列 —-线程 决定block 在哪个线程中调用</p></li></ul><p>代码</p><pre><code>dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</code></pre><h3 id="设置定时器"><a href="#设置定时器" class="headerlink" title="设置定时器"></a>设置定时器</h3><ul><li><p>01参数:定时器对象</p></li><li><p>02参数:开始时间 (DISPATCH_TIME_NOW) 什么时候开始执行第一次任务</p></li><li><p>03参数:间隔时间 GCD时间单位:纳秒</p></li><li><p>04参数:leewayInSeconds精准度:允许的误差: 0 表示绝对精准</p></li></ul><p>code:</p><pre><code>dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</code></pre><h3 id="定时器每隔一段时间就要执行任务-block回调"><a href="#定时器每隔一段时间就要执行任务-block回调" class="headerlink" title="定时器每隔一段时间就要执行任务(block回调)"></a>定时器每隔一段时间就要执行任务(block回调)</h3><pre><code>dispatch_source_set_event_handler(_timer, ^{    if (time &lt;= 0) {        dispatch_source_cancel(_timer);        dispatch_async(dispatch_get_main_queue(), ^{            // 设置按钮的样式            [self.button setTitle:@&quot;重新获取验证码&quot; forState:UIControlStateNormal];            [self.button setTitleColor:[UIColor redColor] forState:UIControlStateNormal];            [self.button setUserInteractionEnabled:YES];        });    } else {        NSInteger seconds = time;        dispatch_async(dispatch_get_main_queue(), ^{            [self.button setTitle:[NSString stringWithFormat:@&quot;重新发送(%.2ld)&quot;, seconds] forState:UIControlStateNormal];            [self.button setTitleColor:[UIColor lightGrayColor] forState:UIControlStateNormal];            [self.button setUserInteractionEnabled:NO];        });        time--;    }});</code></pre><h3 id="启动定时器-默认是停止的"><a href="#启动定时器-默认是停止的" class="headerlink" title="启动定时器(默认是停止的)"></a>启动定时器(默认是停止的)</h3><pre><code>dispatch_resume(timer);</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz2D绘制曲线</title>
      <link href="/2016/12/04/Quartz2D%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF/"/>
      <url>/2016/12/04/Quartz2D%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<p>使用函数绘制曲线</p><p>Quartz 2D提供了CGContextAddCurveToPoint() 函数和CGContextAddQuadCurveToPoint()两个函数来向当前上下文添加曲线，前者用于添加贝塞尔曲线，后者用于添加二次曲线。<br>确定一条贝塞尔曲线需要4个点：开始点、第一个控制点、第二个控制点和结束点。</p><p>确定一条二次曲线需要三个点：开始点、控制点和结束点。</p><p>添加贝塞尔曲线</p><pre><code>CGContextAddCurveToPoint()CGContextRef ctx = UIGraphicsGetCurrentContext();// 添加曲线路径// 设置起点CGContextMoveToPoint(ctx, 0, 0);</code></pre><ul><li>参数1: 上下文对象</li><li>参数2: 控制点1X坐标</li><li>参数3: 控制点1Y坐标</li><li>参数4: 控制点2X坐标</li><li>参数5: 控制点2Y坐标</li><li>参数6: 终点x坐标</li><li>参数7: 终点Y坐标</li></ul><p>code:</p><pre><code>CGContextAddCurveToPoint(ctx, 30, 200, 300, 20, 300, 300);// 设置颜色[[UIColor magentaColor] setStroke];// 渲染CGContextStrokePath(ctx);// 关闭图形上下文CGContextClosePath(ctx);添加二次曲线CGContextAddQuadCurveToPoint()// 获取图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 起始点CGContextMoveToPoint(ctx, 20, 10);</code></pre><ul><li>参数: 图形上下文</li><li>参数: 控制点坐标</li><li>参数: 结束点坐标</li></ul><p>添加二次曲线</p><pre><code>CGContextAddQuadCurveToPoint(ctx, 30, 200, 200, 40);[[UIColor cyanColor] setStroke];CGContextStrokePath(ctx);// 关闭图形上下文CGContextClosePath(ctx);</code></pre><p>绘制形状</p><p>使用绘制二次曲线的函数绘制花瓣</p><p>程序中CGContextAddFlower代码分别添加5瓣花朵路径、6瓣花朵路径、7瓣花朵路径，然后使用不同的颜色来填充这些路径。注意到上面的程序并未在每次添加花朵路径后立即关闭，这也是允许的，而且每次填充路径时并不会再次填充前一次已经填充过的路径。这是因为只用程序绘制了CGContextRef当前所包含的路径，系统会自动清除已经绘制的路径。</p><p><strong>注意：每次绘制完成后，CGContextRef会自动清除已经绘制完成的路径</strong></p><p> 该方法负责绘制花朵。<br> n：该参数控制花朵的花瓣数；dx、dy：控制花朵的位置；size：控制花朵的大小；<br> length：控制花瓣的长度</p><pre><code>void CGContextAddFlower(CGContextRef c , NSInteger n                        , CGFloat dx , CGFloat dy , CGFloat size , CGFloat length){    CGContextMoveToPoint(c , dx , dy + size);  // 移动到指定点    CGFloat dig = 2 * M_PI / n;    // 采用循环添加n段二次曲线路径    for(int i = 1; i &lt; n + 1 ; i++)    {        // 计算控制点坐标        CGFloat ctrlX = sin((i - 0.5) * dig) * length + dx;        CGFloat ctrlY= cos((i - 0.5 ) * dig) * length + dy;        // 计算结束点的坐标        CGFloat x = sin(i * dig) * size + dx;        CGFloat y =cos(i * dig) * size + dy;        // 添加二次曲线路径        CGContextAddQuadCurveToPoint(c, ctrlX , ctrlY , x , y);    }}</code></pre><p>绘制花瓣</p><pre><code>- (void)drawStar{    CGContextRef ctx = UIGraphicsGetCurrentContext();  // 获取绘图的CGContextRef    CGContextBeginPath(ctx);  // 开始添加路径    CGContextAddFlower(ctx , 5 , 50 , 100 , 30 , 80);  // 添加5瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 0, 0, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextAddFlower(ctx , 6 , 160 , 100 , 30 , 80);  // 添加6瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 1, 0, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextAddFlower(ctx , 7 , 270 , 100 , 30 , 80);  // 添加7瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 0, 1, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextClosePath(ctx);  // 关闭路径}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Quartz2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz2D 初识</title>
      <link href="/2016/12/04/Quartz2D%E5%88%9D%E8%AF%86/"/>
      <url>/2016/12/04/Quartz2D%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>Quartz2D 二维绘图引擎，支持iOS和Mac系统么，可以实现的功能有</strong></p><ul><li>绘制图形: 线条，三角形，矩形，圆，弧等</li><li>绘制文字</li><li>绘制图像或者图片</li><li>读取生成PDF</li><li>截图/裁剪图片</li><li>自定义UI控件</li><li>手势解锁</li><li>图形上下文</li></ul><h2 id="保存绘图信息和状态"><a href="#保存绘图信息和状态" class="headerlink" title="保存绘图信息和状态"></a>保存绘图信息和状态</h2><p>确定输出目标(PDF,Bitmap或者显示器)</p><pre><code>Bitmap Graphics ContextPDF Granhics ContextWindow Graphics ContextLayer Graphics Context</code></pre><p>绘制线段</p><pre><code>- (void)drawLine {    // 获取图形上下文    // 所用的是UIGraphics上下文    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 创建描述路径    CGMutablePathRef path = CGPathCreateMutable();    // 设置起点    // path : 表示给那个路径设置起点    CGPathMoveToPoint(path, NULL, 10, 10);    CGPathAddLineToPoint(path, NULL, 80, 80);    // 添加路径到上下文    CGContextAddPath(ctx, path);    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>系统底层自动将路径添加到图形上下文</p><pre><code>- (void)drawLine2 {    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 描述路径    // 此方法底层会自动将路径添加到图形上下文    CGContextMoveToPoint(ctx, 50, 50);    CGContextAddLineToPoint(ctx, 100, 100);    CGContextSetLineWidth(ctx, 5);    [[UIColor redColor] set];    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>使用C语言函数的封装</p><pre><code>- (void)drawLine3 {    // 使用UIKit 已经封装的功能,面向对象    // 贝塞尔路径    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(10, 10)];    [path addLineToPoint:CGPointMake(50, 50)];    // 绘制路径    [path stroke];}</code></pre><p>绘制多条线段</p><ul><li>绘制多条线,状态不好管理</li><li>默认下一条线的起点是上一条线的终点</li><li>绘制多天不连接的线时需要重新设置起点</li><li>为了方便管理，应该让每一条线对应一条路径</li><li>使用UIBeizerPath</li></ul><p>code:</p><pre><code>- (void)drawMoreLine {    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 描述路径    CGContextMoveToPoint(ctx, 20, 20);    CGContextAddLineToPoint(ctx, 100, 100);    // 设置第二条线的起点    CGContextMoveToPoint(ctx, 20, 30);    CGContextAddLineToPoint(ctx, 150, 100);    // 设置绘图状态要在渲染之前,都是给上下文设置    // 描边颜色    [[UIColor greenColor] setStroke];    // 线宽    CGContextSetLineWidth(ctx, 10);    // 连接样式    // kCGLineJoinMiter,    斜接    // kCGLineJoinRound,    圆角    // kCGLineJoinBevel     平切    CGContextSetLineJoin(ctx, kCGLineJoinBevel);    // 顶角样式,线的顶端效果    CGContextSetLineCap(ctx, kCGLineCapRound);    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>使用UIBezierPath 绘制多条直线并设置不同状态</p><pre><code>- (void)drawUIBezierPahtState {    // 第一条线    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(10, 10)];    [path addLineToPoint:CGPointMake(80, 80)];    path.lineWidth = 20;    path.lineJoinStyle = kCGLineJoinRound;    path.lineCapStyle = kCGLineCapRound;    [[UIColor redColor] setStroke];    [path stroke];    // 第二条线    {        UIBezierPath *path = [UIBezierPath bezierPath];        [path moveToPoint:CGPointMake(40, 70)];        [path addLineToPoint:CGPointMake(150, 40)];        path.lineWidth = 20;        path.lineJoinStyle = kCGLineJoinRound;        path.lineCapStyle = kCGLineCapRound;        [[UIColor greenColor] setStroke];        [path stroke];    }}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Quartz2D </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OC中运行时</title>
      <link href="/2016/11/22/OC%20RunTime%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/11/22/OC%20RunTime%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>RunTime<br>对于C语言，函数的调用在编译的时候会决定调用哪个函数，而对于面向对象的语言对于[调用某个对象的方法或函数]就叫「消息传递」。所以在 Java，C++ 这些语言里[调用某个对象的方法或函数]和 Objective-C 里[向某个对象发送消息]在概念上就是一样的事情,</p><h3 id="RunTime-简介"><a href="#RunTime-简介" class="headerlink" title="RunTime 简介"></a>RunTime 简介</h3><ul><li>RunTime 简称运行时，OC中通常叫运行时机制，主要的是消息机制</li><li>消息机制：在OC中，属于动态调用，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用</li></ul><h3 id="RunTime-作用"><a href="#RunTime-作用" class="headerlink" title="RunTime 作用"></a>RunTime 作用</h3><ul><li>发送消息：让对象发送消息</li><li>交换方法</li><li>动态添加方法</li><li>动态获取属性和方法</li><li>字典转模型</li><li>给分类添加属性</li></ul><p>原理：给分类添加一个属性,重写了setter、getter方法，但是没有生成 _成员变量，需要通过运行时关联到分类中， 其本质上就是给这个类添加关联,存值和取值<br>code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.oldurlPath = urlPath;</span><br><span class="line"></span><br><span class="line">- (void)setOldurlPath:(NSString *)oldurlPath &#123;</span><br><span class="line"></span><br><span class="line">// RunTime 关联</span><br><span class="line">// 第一个参数：给哪个对象添加关联</span><br><span class="line">// 第二个参数：关联的key，通过这个key获取</span><br><span class="line">// 第三个参数：关联的value</span><br><span class="line">// 第四个参数:关联的策略</span><br><span class="line">objc_setAssociatedObject(self, key, oldurlPath, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)oldurlPath &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> RunTime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Quartz2D%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1/"/>
      <url>/2016/11/22/Quartz2D%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1/</url>
      
        <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
      <url>/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%94)/</url>
      
        <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
      <url>/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/</url>
      
        <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/WKWebiView%E4%BD%BF%E7%94%A8/"/>
      <url>/2016/11/22/WKWebiView%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 使用</title>
      <link href="/2016/11/20/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2016/11/20/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="使用-git-提交代码"><a href="#使用-git-提交代码" class="headerlink" title="使用 git 提交代码"></a>使用 git 提交代码</h2><ul><li><p>初始化工作目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱（当前仓库）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;aTreey&quot;</span><br><span class="line">git config user.email &quot;480814177@qq.com&quot;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置全局的用户名和密码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;aTreey&quot;</span><br><span class="line">git config --global user.email &quot;480814177@qq.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch main.m</span><br></pre></td></tr></table></figure></li><li><p>添加文件到暂缓区</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add main.m</span><br></pre></td></tr></table></figure></li><li><p>查看文件状态</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>新添加的文件或者新修改的文件在工作区中，没有添加到暂缓区中</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Untracked files: （红色）</span><br></pre></td></tr></table></figure></code></pre><ul><li>需要添加到暂缓区中</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add main.m</span><br></pre></td></tr></table></figure></code></pre><ul><li>出现一下提示方可提交</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed: （绿色）</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>给git起别名</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config alias.st &quot;status&quot;</span><br><span class="line">git config alias.ci &quot;commit -m&quot;</span><br></pre></td></tr></table></figure></li><li><p>查看所有版本库日志（只能查看当前版本的以前日志）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>查看指定文件的版本库日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 文件名</span><br></pre></td></tr></table></figure></li><li><p>查看所有的操作的日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li></ul><h2 id="版本会退"><a href="#版本会退" class="headerlink" title="版本会退"></a>版本会退</h2><ul><li><p>强制回退到当前版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的上一个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的上上个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的前100个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD～100</span><br></pre></td></tr></table></figure></li><li><p>强制回退指定版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD 版本号前七位</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TableView 使用</title>
      <link href="/2016/11/05/TableView%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2016/11/05/TableView%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="tableView-使用总结"><a href="#tableView-使用总结" class="headerlink" title="tableView 使用总结"></a>tableView 使用总结</h2><ul><li><p>字典的 key enumerator 的使用</p></li><li><p>tableViewCell 的 selected 方法可以监听cell 的选中, 使用selected 参数</p></li><li><p>网络慢时点击左边cell右边数据不能及时刷新， 用户看到的还是上一个cell显示的数据</p><ul><li>解决办法: 在网络加载之前就reload数据，让显示空白</li></ul></li><li><p>点击左边的cell时 上拉加载更多控件的显示和隐藏逻辑</p><ul><li>解决办法: 在每次刷新右边数据时，控制footer的显示</li></ul></li></ul><ul><li><p>在numberOfRowsInSection方法中控制</p></li><li><p>每次点击cell之前要结束上一个没有刷新完的，防止奔溃</p></li><li><p>加载更多时</p><p>  在加载第一页时设置currentPage为1，在加载更多的逻辑中 ++currentPage<br>  点击cell加载时上一个加载更多的网络数据还没有回来，在当前请求之前结束掉所有的网络请求<br>  停止之后的刷新控件状态会有错误，没有更多还是还可以加载状态不确定<br>  在点击左边cell后刷新右边的之前需要检查右边tableView 的footer的状态<br>  下拉刷新</p></li><li><p>第一次下拉刷新之后，第二次下拉刷新，将数据添加到数组中会导致两次数据重复</p><ul><li>解决办法：清除以前的所有数据</li></ul></li><li><p>下拉刷新完毕后结束刷新后需要检查footer的状态</p></li><li><p>网络慢时连续点击cell，连发多个请求成功回调时数据显示错乱，或者是数据已经回来了但是还是显示上一个请求正在请求。。。</p><ul><li>解决办法：点击左边某个类别时，结束所有的刷新（上拉和下拉）</li></ul></li><li><p>连续点击发送请求</p><ul><li>解决办法：保存请求参数， 比较上一次参数和当前参数， 如果 ！= 直接return，不让进入成功回调解析数据， 失败的时候也是同样 return，不提示用户</li></ul></li><li><p>控制器正在请求数据时控制器销毁， 导致奔溃</p><ul><li>解决办法：在dealloc 中停止所有的操作</li></ul></li></ul><h2 id="cell-的frame-设置"><a href="#cell-的frame-设置" class="headerlink" title="cell 的frame 设置"></a>cell 的frame 设置</h2><ul><li><p>cell 之间的间隙以及cell的边距 重写frame 在super 之前设置</p><ul><li>设置frame 的x ，width， height 等属性</li></ul></li><li><p>分页的2种做法</p><ul><li><p>下拉刷新</p><p>  page 加载最新的 加载第一页 浪费用户的流量<br>  加载比当前更新的数据， 需要服务器支持，将当前最新的数据id发送给服务器，服务器加载比当前id还大的数据插入到最前面</p></li><li><p>上拉加载</p><p>  将页码发给服务器</p><p>  将最后面的数据的id发给服务器，</p><p>  加载比当前id更小的数据</p></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> TableView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2016/11/05/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2016/11/05/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><ul><li><p>参考官网教程  <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">http://brew.sh/index_zh-cn.html</a></p></li><li><p>在终端中输入,如果失败需要用sudo</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot; (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brew install git</span><br></pre></td></tr></table></figure><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><ul><li>[下载安装] (<a href="https://nodejs.org/en/download" target="_blank" rel="noopener">https://nodejs.org/en/download</a>) </li></ul><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul><li>需要输入密码： sudo 管理员权限 -g 全局安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化-执行-hexo-init-命令"><a href="#初始化-执行-hexo-init-命令" class="headerlink" title="初始化 执行 hexo init 命令"></a>初始化 执行 hexo init 命令</h2><ul><li>指定安装文件 blog</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><ul><li>cd 到 文件夹 blog 下，安装 npm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li>开启服务 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>复制终端中的 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 到浏览器中打开</li></ul><h2 id="关联-github"><a href="#关联-github" class="headerlink" title="关联 github"></a>关联 github</h2><ul><li><p>添加 ssh key 到github</p></li><li><p>设置 Mac 显示隐藏文件</p><ul><li><p>在终端执行一下命令后，重启Finder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检查 SSH keys 是否存在 github</p><ul><li><p>打开 Finder 前往（command + shit + G）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果有文件说明存在 SSH key， 打开 id_rsa.pub 文件，复制里面的信息</p></li><li>进入 Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key<br>任意添加一个title 粘贴内容到key 里，点击Add key 绿色按钮即可。</li></ul><h2 id="创建名字为-用户名-github-io-的仓库"><a href="#创建名字为-用户名-github-io-的仓库" class="headerlink" title="创建名字为 用户名.github.io 的仓库"></a>创建名字为 用户名.github.io 的仓库</h2><p>自行百度。。。。</p><h2 id="配置-hexo"><a href="#配置-hexo" class="headerlink" title="配置 hexo"></a>配置 hexo</h2><ul><li>vim 打开 _config.yml修改 deploy 模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https://github.com/用户名/用户.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p><strong>冒号后需要加空格</strong></p><h2 id="生成-hexo-的静态页面"><a href="#生成-hexo-的静态页面" class="headerlink" title="生成 hexo 的静态页面"></a>生成 hexo 的静态页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate 后者 hexo g</span><br></pre></td></tr></table></figure><ul><li>报以下错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure><ul><li>执行下面代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><h2 id="部署-hexo"><a href="#部署-hexo" class="headerlink" title="部署 hexo"></a>部署 hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 或者 hexo d</span><br></pre></td></tr></table></figure><ul><li>报以下错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li>配置 Deloyment 前，需要配置自己的身份信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p><strong>如果执行完以上命令还是不行，删除blog文件下的 .deploy_git 文件重新 hexo deploy</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS 弹框视图</title>
      <link href="/2016/10/27/iOS%E5%BC%B9%E6%A1%86%E5%BC%8F%E5%9B%BE/"/>
      <url>/2016/10/27/iOS%E5%BC%B9%E6%A1%86%E5%BC%8F%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p><strong><code>UIActionSheet</code> <code>UIAlertView</code> <code>UIAlertViewController</code> 的区别</strong></p><h2 id="UIActionSheet"><a href="#UIActionSheet" class="headerlink" title="UIActionSheet"></a>UIActionSheet</h2><ul><li>iOS 8.3 之后过期</li><li>模态弹出，显示在试图的底部 类似菜单提供选择</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:@&quot;title&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:nil otherButtonTitles:@&quot;按钮1&quot;, @&quot;按钮2&quot;, nil];</span><br><span class="line">[actionSheet showInView:self.view];</span><br></pre></td></tr></table></figure><h2 id="UIAlertView"><a href="#UIAlertView" class="headerlink" title="UIAlertView"></a>UIAlertView</h2><ul><li>iOS 9.0 之后过期</li><li>模态弹出，显示在试图的中间位置 类似一个对话框提供选择</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;考勤方式&quot; message:nil delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:faceBtn, fingerPrintBtn, nil];</span><br><span class="line">[alertView show];</span><br></pre></td></tr></table></figure><h2 id="UIAlertViewController"><a href="#UIAlertViewController" class="headerlink" title="UIAlertViewController"></a>UIAlertViewController</h2><ul><li>iOS 8.0 起可以使用</li><li><code>style</code> : 默认样式, 类似 <code>UIActionSheet</code> 列表形式 </li><li><code>style</code> 为：<code>UIAlertControllerStyleAlert</code> 对话框形式</li><li>设置按钮的样式</li></ul><p>如果修改 UIAlertAction 中stye 为：</p><p>UIAlertActionStyleCancel<br>取消按钮会和其他按钮分开</p><p>如果修改 UIAlertAction 中stye 为：</p><p>UIAlertActionStyleDestructive<br>取消按钮会以红色警告的方式显示， 但是按钮之间不会分开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;考勤方式&quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];</span><br><span class="line">UIAlertAction *faceBtn = [UIAlertAction actionWithTitle:@&quot;人脸识别&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;&#125;];</span><br><span class="line"></span><br><span class="line">UIAlertAction *fingerPrintBtn = [UIAlertAction actionWithTitle:@&quot;指纹认证&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">UIAlertAction *cancelBtn = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[alert addAction:faceBtn];</span><br><span class="line">[alert addAction:fingerPrintBtn];</span><br><span class="line">[alert addAction:cancelBtn];</span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> AlertView </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地缓存</title>
      <link href="/2016/10/20/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
      <url>/2016/10/20/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h2 id="保存图片到沙盒"><a href="#保存图片到沙盒" class="headerlink" title="保存图片到沙盒"></a>保存图片到沙盒</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveImage:(UIImage *)image InSanBoxWithIndexPath:(NSInteger)indexPath &#123;</span><br><span class="line"></span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, indexPath]];   // 保存文件的名称</span><br><span class="line">[UIImagePNGRepresentation(image)writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取沙盒中的图片"><a href="#获取沙盒中的图片" class="headerlink" title="获取沙盒中的图片"></a>获取沙盒中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)fetchImageFromSanBoxWithIndexPath:(NSInteger)indexPath</span><br><span class="line">&#123;</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, indexPath]];   // 保存文件的名称</span><br><span class="line">UIImage *img = [UIImage imageWithContentsOfFile:filePath];</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除沙盒中的图片"><a href="#删除沙盒中的图片" class="headerlink" title="删除沙盒中的图片"></a>删除沙盒中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)deleteImageAtIndexPath:(NSInteger)index;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, index]];</span><br><span class="line"></span><br><span class="line">if([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">return  [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改图片"><a href="#修改图片" class="headerlink" title="修改图片"></a>修改图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)fixOrientation:(UIImage *)aImage &#123;</span><br><span class="line"></span><br><span class="line">// No-op if the orientation is already correct</span><br><span class="line">if (aImage.imageOrientation == UIImageOrientationUp)</span><br><span class="line">return aImage;</span><br><span class="line"></span><br><span class="line">// We need to calculate the proper transformation to make the image upright.</span><br><span class="line">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line"></span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationDown:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, aImage.size.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, 0);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI_2);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, 0, aImage.size.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, -M_PI_2);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationUpMirrored:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.height, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Now we draw the underlying CGImage into a new context, applying the transform</span><br><span class="line">// calculated above.</span><br><span class="line">CGContextRef ctx = CGBitmapContextCreate(NULL, aImage.size.width, aImage.size.height,</span><br><span class="line">CGImageGetBitsPerComponent(aImage.CGImage), 0,</span><br><span class="line">CGImageGetColorSpace(aImage.CGImage),</span><br><span class="line">CGImageGetBitmapInfo(aImage.CGImage));</span><br><span class="line">CGContextConcatCTM(ctx, transform);</span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">// Grr...</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,aImage.size.height,aImage.size.width), aImage.CGImage);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,aImage.size.width,aImage.size.height), aImage.CGImage);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">CGImageRef cgimg = CGBitmapContextCreateImage(ctx);</span><br><span class="line">UIImage *img = [UIImage imageWithCGImage:cgimg];</span><br><span class="line">CGContextRelease(ctx);</span><br><span class="line">CGImageRelease(cgimg);</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 本地缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 使用</title>
      <link href="/2016/10/13/SQlite%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/10/13/SQlite%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="常用SQL-语句"><a href="#常用SQL-语句" class="headerlink" title="常用SQL 语句"></a>常用SQL 语句</h2><p>创建一张表</p><pre><code>create table if not exists t_product(productId integer, productName text, productPrice real);</code></pre><p>删除一张表</p><pre><code>drop table if exists t_product;</code></pre><p>插入一条记录</p><p>如果不写某个字段和对应值就会为NUll</p><pre><code>insert into t_product(productId, productName, productPrice) values (0001, &apos;iPhone7&apos;, 6100.8);</code></pre><p>修改记录</p><pre><code>update t_product set productId = 20002 where productName = &apos;iPhone5s&apos;;</code></pre><p>删除</p><pre><code>delete from t_product where productName = &apos;iphone5s&apos;;</code></pre><p><strong>注意：条件语句不能单独存在，只能在修改／删除／查询之后</strong></p><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p>准备数据生成sql语句文件</p><pre><code>NSMutableString *mutableString = [NSMutableString string];int productIdValue = arc4random_uniform(1000);NSString *productNameValue = [NSString stringWithFormat:@&quot;iPhone_%d&quot;,1 + arc4random_uniform(8)];CGFloat productPriceValue = 3000 + arc4random_uniform(1000);for (NSInteger i = 0; i &lt; 1000; i++) {    [mutableString appendFormat:@&quot;insert into t_product(productId, productName, productPrice) values (%d, %@, %f); \r\n&quot;, productIdValue, productNameValue, productPriceValue];}// 写入文件[mutableString writeToFile:@&quot;/Users/Apeng/work/Demo/Sqlite/products.sql&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</code></pre><p>生成的sql语句文件</p><p><img src="http://i1.piimg.com/567571/588e899a67c1cce6.png" alt></p><p>SQL 查询语句</p><pre><code>select *（表示字段）from t_product（表名）where(条件语句) productId &gt; 100 (字段满足的条件) ;select * from t_product where productPrice &lt; 5000; </code></pre><p><img src="http://p1.bpimg.com/567571/54d2c6ade469b653.png" alt><br>or: 或</p><p><img src="http://p1.bqimg.com/567571/c8cd40b4271ec880.png" alt></p><p>and: 且</p><p><img src="http://i1.piimg.com/567571/a6b404e93f8bc0eb.png" alt></p><p>分页查询</p><p>limit 0,5 （ limit 索引，每页取得数据条数 ）</p><p>第一页 limit 0,5;</p><p>第二页 limit 5,5;</p><p>第三页 limit 10,5;</p><p>第四页 limit 15,5;</p><p>第N页 limit （N - 1）* 5</p><pre><code>select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice limit 5,5;</code></pre><p><img src="http://i1.piimg.com/567571/29e2799f64db4884.png" alt></p><p>排序查询</p><p>order by 默认是从小到大，一般是在某一个结果之后</p><p>默认升序</p><pre><code>// 默认升序select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice;// 降序select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice desc;</code></pre><p><img src="http://p1.bqimg.com/567571/c69e4c2790b900b6.png" alt></p><p>模糊查询</p><p>关键字搜索 ，% 是指通配符</p><p>SQL 顺序</p><pre><code>select * from 表名 条件语句（模糊匹配）排序语句 分页语句select * from t_product where productName like &apos;%_4&apos; order by productPrice limit 0,5;</code></pre><p><img src="http://i1.piimg.com/567571/4727877c1b85cb0e.png" alt></p><p>主键</p><p>数据库的约定俗称,自增长,建议创建表时增加主键，也可以之后再设计表</p><pre><code>CREATE TABLE IF NOT EXISTS t_class (id integer PRIMARY KEY, className text, classNO integer); </code></pre><p>外键约束</p><p>当两张表有关联时，需要使用外键约束，一张表中的字段名所对应的值只能来自于另一张表中</p><p><img src="http://p1.bqimg.com/567571/6b8c31aca88003d0.png" alt></p><p>添加外键约束之后的变化</p><p><img src="http://p1.bpimg.com/567571/4e0c9af7ec980748.png" alt></p><p>多表查询</p><p>有 <code>t_department</code>（部门表）和 <code>t_employee</code>(员工表)两张表</p><p>需求：在 <code>t_employee</code> 表中查出部门研发部的人员</p><p>1 嵌套查询：</p><p>先查根据部门名称查出部ID，</p><p><img src="http://p1.bqimg.com/567571/29459ada951407a8.png" alt></p><p>然后再用部门ID查出员工表中的员工<br><img src="http://i1.piimg.com/567571/0636fdca9e552d99.png" alt></p><p>以上两步的代码可合并</p><p>根据部门名称查出部门ID</p><pre><code>SELECT id from t_department WHERE departmentName = &apos;研发部&apos;;</code></pre><p>根据部门id查出这个部门的人员</p><pre><code>SELECT * from t_employee WHERE departmentID = 1;</code></pre><p>合并后为</p><pre><code>select * from t_employee where departmentID = (SELECT id from t_department WHERE departmentName = &apos;研发部&apos;); </code></pre><p>结果为：</p><p><img src="http://i1.piimg.com/567571/fd184b9d631bb19f.png" alt></p><ol start="2"><li>链接查询</li></ol><p>给表起别名，给字段起别名</p><pre><code>select employee.*, depart.departmentName deptN from t_department depart, t_employee employee;</code></pre><p>/*<em>多表查询之链接查询</em>/</p><pre><code>select t_employee.*, t_department.departmentName FROM t_department, t_employee;</code></pre><p><img src="http://i1.piimg.com/567571/d5bd63824decf7f6.png" alt></p><p>消除笛卡尔积</p><pre><code>select employee.*, depart.departmentName deptN from t_department depart, t_employee employee where employee.departmentID = depart.id and employee.departmentID = 1;</code></pre><p><img src="http://i1.piimg.com/567571/b326df9d3150885d.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

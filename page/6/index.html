<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>aTreey&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="aTreey&#39;s Blog">
<meta property="og:url" content="https://github.com/aTreey/page/6/index.html">
<meta property="og:site_name" content="aTreey&#39;s Blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aTreey&#39;s Blog">
  
    <link rel="alternate" href="/atom.xml" title="aTreey&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">aTreey&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/aTreey"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS即时通讯实现二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/iOS即时通讯实现二/" class="article-date">
  <time datetime="2018-01-12T13:54:26.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/iOS即时通讯实现二/">iOS即时通讯实现二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实现IM通信所用协议"><a href="#实现IM通信所用协议" class="headerlink" title="实现IM通信所用协议"></a>实现IM通信所用协议</h2><p>几个协议理解</p>
<p>xmpp 是基于xml协议主要是易于扩展，早起用于PC时代的产品使用，流量大，耗电大交互复杂其实并不适合移动互联网时代的IM产品</p>
<p>MQTT 协议 适配多平台，需自己扩展好友，群组等功能</p>
<p>protobut 协议</p>
<h2 id="封装socket，自己实现"><a href="#封装socket，自己实现" class="headerlink" title="封装socket，自己实现"></a>封装socket，自己实现</h2><p>所要考虑的问题</p>
<ul>
<li><p>传输协议选择 </p>
<ul>
<li>TCP ？ 一般公司都选用（技术不是很成熟）</li>
<li>UDP ？QQ 腾讯增加自己的私有协议，保证数据传递的可靠性，解决了丢包，乱序的问题</li>
</ul>
</li>
<li><p>聊天协议选择及代表框架</p>
<ul>
<li>Socket ？ CocoaAsyncSocket </li>
<li>WebSockt ？是传输通讯协议，基于socket封装的一个协议 SocketRocket</li>
<li>MQTT ？MQTTKit 聊天协议为上层协议</li>
<li>protobut 协议 ？</li>
<li>XMPP ？XMPPFramework  聊天协议为上层协议</li>
<li>自定义</li>
</ul>
</li>
<li><p>传输数据格式</p>
<ul>
<li>Json？</li>
<li>XML？</li>
<li>ProtocolBuffer？</li>
</ul>
</li>
<li><p>细节相关</p>
<ul>
<li>TCP 长连接如何保持，</li>
<li>心跳机制</li>
<li>重连机制</li>
<li>数据安全机制</li>
</ul>
</li>
</ul>
<h3 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h3><ul>
<li>CocoaAsyncSocket 的 delegate 用来设置代理处理各个回调</li>
<li>delegateQueue </li>
<li>socketQueue 串行队列，贯穿全类并没有任何加锁，确保了socket 操作中每一步都是线程安全的</li>
<li><p>创建了两个读写队列（本质是数组）</p>
<ul>
<li><code>NSMutableArray *readQueue;</code> </li>
<li><code>NSMutableArray *writeQueue;</code></li>
</ul>
</li>
<li><p>全局数据缓冲: 当前socket未获取完的数据大小</p>
<ul>
<li><code>GCDAsyncSocketPreBuffer *preBuffer;</code></li>
</ul>
</li>
<li><p>交替延时变量: 用于进行另一服务端地址请求的延时 </p>
<ul>
<li><code>alternateAddressDelay</code></li>
</ul>
</li>
<li><p>connect</p>
</li>
<li><p>disconnect</p>
</li>
</ul>
<h2 id="数据粘包-断包"><a href="#数据粘包-断包" class="headerlink" title="数据粘包,断包"></a>数据粘包,断包</h2><ul>
<li><p>粘包: 如果客户端同一时间发送几条数据，而服务器只收到一大条数据</p>
<ul>
<li>原因：</li>
<li><p>由于传输的是数据流，经过TCP传输后，TCP使用了优化算法将多次间隔较小且数据量小的数据合并成一个大的数据块，因此三条数据合并成了一条</p>
<p>  <strong>TCP,UDP都可能造成粘包的原因</strong></p>
</li>
<li><p>发送端需要等缓冲区满了才发送出去，做成粘包</p>
</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
</li>
<li><p>断包: 因为一次发送很大的数据包，缓冲区有限，会分段发送或读取数据</p>
</li>
</ul>
<h2 id="CocoaAsyncSocket的封包，拆包处理"><a href="#CocoaAsyncSocket的封包，拆包处理" class="headerlink" title="CocoaAsyncSocket的封包，拆包处理"></a>CocoaAsyncSocket的封包，拆包处理</h2><ul>
<li><p>读取数据方法：</p>
<pre><code>// 有数据时调用，读取当前消息队列中的未读消息
- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag
</code></pre></li>
</ul>
<pre><code>**每次读取数据，每次都必须手动调用上述 readData 方法超时设置为不超时才能触发消息回调的代理**

**因此在第一连接时调用，再在接到消息时调用，上述方法就可以达到每次收到消息都会触发读取消息的代理**

以上做法存在的问题就是没有考虑数据的拆包会有粘包情况，这时候需要用下面两个`read`方法，1. 读取指定长度、2.读取指定边界

    // 读取特定长度数据时调用
    - (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag

    // 读到特定的 data 边界时调用
    - (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag


**解决办法及具体思路**

- 封包：给每个数据包增加一个长度或者加一个开始结束标记，表明数据的长度和类型（根据自己的项目：文本、图片、语音、红包、视频、话题、提问等等）
    - 可以在数据包之后加一个结束标识符，解决了传输过程中丢包，丢失头部信息的错误包读取，读到这样的就丢弃直接读下一个数据包

- 拆包：获取每个包的标记，根据标记的数据长度获取数据，最后根据类型处理数据,最后读取数据包头部的边界
</code></pre><ul>
<li><p>利用缓冲区对数据进行读取</p>
<ul>
<li>创建读取数据包</li>
<li>添加到读取的队列中</li>
<li>从队列中取出读取任务包 </li>
<li><p>使用偏移量 <code>maxLength</code> 读取数据 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">		- (void)readDataWithTimeout:(NSTimeInterval)timeout</span><br><span class="line">                     buffer:(NSMutableData *)buffer</span><br><span class="line">               bufferOffset:(NSUInteger)offset</span><br><span class="line">                  maxLength:(NSUInteger)length</span><br><span class="line">                        tag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">	if (offset &gt; [buffer length]) &#123;</span><br><span class="line">		LogWarn(@&quot;Cannot read: offset &gt; [buffer length]&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 1. 创建读取数据包</span><br><span class="line">	GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer</span><br><span class="line">	                                                          startOffset:offset</span><br><span class="line">	                                                            maxLength:length</span><br><span class="line">	                                                              timeout:timeout</span><br><span class="line">	                                                           readLength:0</span><br><span class="line">	                                                           terminator:nil</span><br><span class="line">	                                                                  tag:tag];</span><br><span class="line">	</span><br><span class="line">	dispatch_async(socketQueue, ^&#123; @autoreleasepool &#123;</span><br><span class="line">		</span><br><span class="line">		LogTrace();</span><br><span class="line">		</span><br><span class="line">		if ((flags &amp; kSocketStarted) &amp;&amp; !(flags &amp; kForbidReadsWrites))</span><br><span class="line">		&#123;</span><br><span class="line">			// 2. 向读的队列添加任务包</span><br><span class="line">			[readQueue addObject:packet];</span><br><span class="line">			// 3. 从队列中取出读取任务包 </span><br><span class="line">			[self maybeDequeueRead];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#125;);</span><br><span class="line">	</span><br><span class="line">	// Do not rely on the block being run in order to release the packet,</span><br><span class="line">	// as the queue might get released without the block completing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>doReadData 方法时读取数据的核心方法</p>
<ul>
<li>如果读取对列中没有数据，就去判是否是上次已经读取了数据，但是因为没有目前还没有读取到数据的标记，这是正好设置了 read 方法中的超时时间，所以要断开socket 连接</li>
</ul>
<p><img src="https://www.jianshu.com/p/fdd3d429bdb3" alt>                </p>
<ul>
<li>接收到数据后在 socket系统进程的数据缓冲区中<ul>
<li>（基于TLS的分为两种）他们在各自管道中流动，完成数据解密后又流向了全局数据缓冲区<ul>
<li>CFStreem </li>
<li>SSLPrebuffer</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>处理数据逻辑： 如果当前读取包长度给明了，则直接流向currentRead，如果数据长度不清楚，那么则去判断这一次读取的长度，和currentRead可用空间长度去对比，如果长度比currentRead可用空间小，则流向currentRead，否则先用prebuffer来缓冲。</p>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul>
<li>TCP 自带的keep-alive 使用空闲时间来发并且默认超时时间太长是2 小时，</li>
<li>如果应用使用了socks ，socks proxy会让tcp keep-alive失效，因为socks 协议只管转发TCP层具体的数据包，并不会转发TCP协议内的实现具体细节数据包</li>
<li><p>TCP 的长连接理论上是一直保持连接的，可以设置 TCP keep-alive的时间 但是实际情况下中，可能出现故障或者是因为防火墙的原因会自动把一定时间段内没有数据交互的连接给断开，心跳机制就可以维持长连接，保持活跃状态</p>
</li>
<li><p>iOS 中使用 NSTimer  <code>scheduledTimerWithTimeInterval</code> 需要在调用之前的关键位置设置 fireDate 为未来的某个时间, 然后再需要的时候开启</p>
</li>
<li>或者直接使用 <code>timerWithTimeInterval</code> 创建，然后添加到<code>runloop</code>中</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/12/iOS即时通讯实现二/" data-id="cjx3gd6o7002cobfyhtz3tymr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-网络七层协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/10/网络七层协议/" class="article-date">
  <time datetime="2018-01-10T15:26:18.000Z" itemprop="datePublished">2018-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/10/网络七层协议/">iOS 即使通讯网络知识篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>读《图解TCP/IP》第5版以及看过的关于网络文章之后自己的理解</p>
<p>OSI (Open System Interconnec) 译为 开发式系统互联 七层模型从下到上一次是：物理层 -&gt; 数据链路层 —&gt; 网络层 -&gt; 传输层 -&gt; 会话层 -&gt; 表示层 -》 应用层</p>
<p>数据每次经过一层之后就会在数据头部增加一个首部信息</p>
<h5 id="物理层：网卡-网线-集线器-中继器-调制解调器"><a href="#物理层：网卡-网线-集线器-中继器-调制解调器" class="headerlink" title="物理层：网卡,网线,集线器,中继器,调制解调器"></a>物理层：网卡,网线,集线器,中继器,调制解调器</h5><ul>
<li>定义设备标准，如网线，光纤接口类型，将0和1转化为电信号的强和弱，达到传输<strong>比特流</strong>目的，这层数据叫比特</li>
</ul>
<h5 id="数据链路层：网桥-交换机"><a href="#数据链路层：网桥-交换机" class="headerlink" title="数据链路层：网桥,交换机"></a>数据链路层：网桥,交换机</h5><ul>
<li>传输的地址帧，并且有检测错误功能，保证数据可靠传输， 这层数据叫帧</li>
</ul>
<h5 id="网络层：路由器"><a href="#网络层：路由器" class="headerlink" title="网络层：路由器"></a>网络层：路由器</h5><ul>
<li>两个计算机通信时可能会经过多个数据链路或者通信子网，网络层将数据链路层的帧组成数据包，包中有封装好的包头，其中含有逻辑地址信息（源站点和目的站点），此层为数据包选择合适的路由和交换结点,IP协议产生，这层数据叫着数据包</li>
</ul>
<h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><ul>
<li>解决数据如何在网络中传输，这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等</li>
</ul>
<h5 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h5><ul>
<li>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的</li>
</ul>
<h5 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h5><ul>
<li>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li>
</ul>
<h5 id="应用层：HTTP-协议"><a href="#应用层：HTTP-协议" class="headerlink" title="应用层：HTTP 协议"></a>应用层：HTTP 协议</h5><ul>
<li>如何包装数据</li>
</ul>
<p><strong>通常从上到下会分成四层</strong></p>
<p>TCP/IP 通常是指TCP/IP协议族,是一组不同协议组合在一起构成的协议族</p>
<ul>
<li>应用层：FTP 应用层协议</li>
<li>传输层：TCP,UDP 传输层协议,TCP 提供了一个可靠的服务</li>
<li>网络层：IP,ICMP 网络层协议，传输时不可靠的</li>
<li>链路层：以太网协议</li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><strong>为了解决不同计算机上进程间通信问题</strong><br>服务器在指定的端口上监听，然后生成一对儿新的socket 进行通讯，一个线程对应一个socket</p>
<p>英文翻译为“插座”通常称为”套接字”, 本质是对于TCP/IP的封装，有客户端 socket 和 服务端socket </p>
<ul>
<li>流式 Socket (STREAM): 是一种面向连接的socket，针对于面向连接的TCP服务应用，因为安全所以效率低</li>
<li>数据报式Socket (DATAGRAM): 是一种无连接的SOcket，正对于无连接的UDP服务应用，无序，不安全，需要在接收端分析重排或者要求重发，所以效率高</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/10/网络七层协议/" data-id="cjx3gd6p0003hobfyqvdsoue9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift加密相关" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/08/Swift加密相关/" class="article-date">
  <time datetime="2018-01-08T13:33:01.000Z" itemprop="datePublished">2018-01-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/08/Swift加密相关/">Swift加密相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近公司项目开发中引用了 <code>Swift</code> 与 <code>OC</code> 混编, 涉及到了加密相关, 使用了第三方 <code>CryptoSwift</code>, 以下是使用过程中的简单记录</p>
<h3 id="CryptoSwift简介"><a href="#CryptoSwift简介" class="headerlink" title="CryptoSwift简介"></a>CryptoSwift简介</h3><ul>
<li>github: <a href="https://github.com/krzyzanowskim/CryptoSwift">https://github.com/krzyzanowskim/CryptoSwift</a></li>
<li>使用Swift 编写的加密工具包，支持多种加密算法，如：MD5、SHA1、AES-128, AES-192, AES-256… 等等</li>
</ul>
<h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><ul>
<li><p><code>data</code> 转化为字节数组</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bytes = data.bytes</span><br><span class="line">   print(bytes)</span><br></pre></td></tr></table></figure>
</li>
<li><p>字节数组转化为 <code>data</code></p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data = Data(bytes: [0x01, 0x02, 0x03])</span><br><span class="line">   print(data)</span><br></pre></td></tr></table></figure>
</li>
<li><p>十六进制创建字节</p>
<pre><code>let bytes_Hex = Array&lt;UInt8&gt;(hex: &quot;0x010203&quot;)
print(bytes_Hex)
</code></pre></li>
<li><p>字节转十六进制数</p>
<pre><code>let hex = bytes_Hex.toHexString()
print(hex)       
</code></pre></li>
</ul>
<ul>
<li><p>字符串生成字节数组</p>
<pre><code>let string2bytes = &quot;string&quot;.bytes
print(string2bytes)
</code></pre></li>
</ul>
<ul>
<li><p>字节数组 base64</p>
<pre><code>let bytes1: [UInt8] = [1, 2, 3]
let base64Str = bytes1.toBase64()
print(base64Str!)
</code></pre></li>
<li><p>字符串base64</p>
<pre><code>let str0 = &quot;test&quot;
let base64Str1 = str0.bytes.toBase64()
print(base64Str1!)
</code></pre></li>
</ul>
<h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><ul>
<li>MD5（RFC1321）诞生于 1991 年，全称是“Message-Digest Algorithm(信息摘要算法)5”，由 MIT 的计算机安全实验室和 RSA 安全公司共同提出。</li>
<li><p>之前已经有 MD2、MD3 和 MD4 几种算法。MD5 克服了 MD4 的缺陷，生成 128bit 的摘要信息串，出现之后迅速成为主流算法 </p>
</li>
<li><p>字节数组MD5</p>
<pre><code>let str = &quot;测试test&quot;
let bytes = str.bytes

// 写法一
let digest = bytes.md5().toHexString()
print(digest)
// 04f47b69e3573867a5b3c1e5edb00789

// 写法二
let digest1 = Digest.md5(bytes).toHexString()
print(digest1)
// 04f47b69e3573867a5b3c1e5edb00789
</code></pre></li>
<li><p>Data的MD5值</p>
<pre><code>/// data MD5
let data = Data(str.bytes)
let digest3 = data.md5().toHexString()
print(digest3)
// 04f47b69e3573867a5b3c1e5edb00789
</code></pre></li>
<li><p>字符串MD5</p>
<pre><code>///写法 一
let digest4 = str.md5()
print(digest4)
// 04f47b69e3573867a5b3c1e5edb00789

// 写法二
do {
    var digest4_2 = MD5()

    let _ = try digest4_2.update(withBytes: &quot;测试&quot;.bytes)
    let _ = try digest4_2.update(withBytes: &quot;test&quot;.bytes)
    let result = try digest4_2.finish()
    print(result.toHexString())
    //04f47b69e3573867a5b3c1e5edb00789
} catch {

}    
</code></pre></li>
</ul>
<h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul>
<li><p>字节数组SHA值</p>
<pre><code>let str = &quot;测试test&quot;
let bytes = str.bytes

//方式一
let digest1 = bytes.sha1().toHexString()
let digest2 = bytes.sha224().toHexString()
let digest3 = bytes.sha256().toHexString()
let digest4 = bytes.sha384().toHexString()
let digest5 = bytes.sha512().toHexString()
print(digest1, digest2, digest3, digest4 ,digest5, separator: &quot;\n&quot;)

//方式二
let digest6 = Digest.sha1(bytes).toHexString()
let digest7 = Digest.sha224(bytes).toHexString()
let digest8 = Digest.sha256(bytes).toHexString()
let digest9 = Digest.sha384(bytes).toHexString()
let digest10 = Digest.sha512(bytes).toHexString()
print(digest6, digest7, digest8, digest9 ,digest10, separator: &quot;\n&quot;)
</code></pre></li>
</ul>
<ul>
<li><p>Data的SHA值</p>
<pre><code>let data = Data(bytes: str.bytes)
let digest11 = data.sha1().toHexString()
let digest12 = data.sha224().toHexString()
let digest13 = data.sha256().toHexString()
let digest14 = data.sha384().toHexString()
let digest15 = data.sha512().toHexString()
print(digest11, digest12, digest13, digest14 ,digest15, separator: &quot;\n&quot;)
</code></pre></li>
</ul>
<ul>
<li><p>字符串的SHA值</p>
<pre><code>let digest16 = str.sha1()
let digest17 = str.sha224()
let digest18 = str.sha256()
let digest19 = str.sha384()
let digest20 = str.sha512()
print(digest16, digest17, digest18, digest19 ,digest20, separator: &quot;\n&quot;)
</code></pre></li>
</ul>
<pre><code>// 方式一
let digest_str = str.sha1()
print(digest_str)

// 方式二
do {
    var digest_str = SHA1()
    let _ = try digest_str.update(withBytes: Array(&quot;测试&quot;.bytes))
    let _ = try digest_str.update(withBytes: Array(&quot;test&quot;.bytes))
    let result = try digest_str.finish()
    print(result.toHexString())
} catch {

}
</code></pre><h3 id="AES-加密"><a href="#AES-加密" class="headerlink" title="AES 加密"></a>AES 加密</h3><ul>
<li><p>key：公共密钥</p>
</li>
<li><p>IV： 密钥偏移量</p>
</li>
<li><p>padding：key 的补码方式</p>
<pre><code>key 长度不够16 字节时，需要手动填充, zeroPadding 将其补齐至 blockSize 的整数倍
zeroPadding 补齐规则:
- 将长度补齐至 blockSize 参数的整数倍。比如我们将 blockSize 设置为 AES.blockSize（16）
- 如果长度小于 16 字节：则尾部补 0，直到满足 16 字节。
- 如果长度大于等于 16 字节，小于 32 字节：则尾部补 0，直到满足 32 字节。
- 如果长度大于等于 32 字节，小于 48 字节：则尾部补 0，直到满足 48 字节。 以此类推......
</code></pre></li>
<li><p>补码方式padding, noPadding, zeroPadding, pkcs7, pkcs5, 默认使用 pkcs7,两者写法结果相同</p>
</li>
</ul>
<pre><code>let iv_paddding = &quot;1234567890123456&quot; // 默认是
let aes_padding1 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes))
let aes_padding2 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes), padding: .pkcs7)            
</code></pre><ul>
<li><p>ECB 模式</p>
<pre><code>let key = &quot;hangge.com123456&quot;
let str = &quot;E蜂通信&quot;
print(&quot;加密前 \(str)&quot;)

//MARK: 使用ECB 模式， , 使用aes128 加密
let aes = try AES(key: key.bytes, blockMode: .ECB)
let encrpyted = try aes.encrypt(str.bytes)
print(&quot;加密后 \(encrpyted)&quot;, separator: &quot;-----&quot;)

 /// 解密
 let decrypted = try aes.decrypt(encrpyted)
 print(&quot;解密后 \(decrypted)&quot;)
 let decryptedString = String(data: Data(decrypted), encoding: .utf8)!
 print(&quot;解密后字符串 \(decryptedString)&quot;)
</code></pre></li>
</ul>
<ul>
<li><p>CBC 模式</p>
<pre><code>//MARK: 使用CBC 模式, 需要提供一个额外的密钥偏移量 iv

    /// 写法 1 --  便捷写法
    // 偏移量
    let iv = &quot;1234567890123456&quot; // 默认是

    // TODO: 随机密钥偏移量
    let data = Data(bytes: AES.randomIV(AES.blockSize))
    let random_iv = String(data: data, encoding: .utf8)
</code></pre></li>
</ul>
<pre><code>/// 写法 2 --
// 创建密码器
let cbc_aes = try AES(key: key.bytes, blockMode: .CBC(iv: iv.bytes))

let cbc_aes2 = try AES(key: key, iv: iv)


let cbc_aes3 = try AES(key: key, iv: iv)

let cbc_encrypted = try cbc_aes.encrypt(str.bytes)

let cbc_encrypted2 = try cbc_aes2.encrypt(str.bytes)

let cbc_encrypted3 = try cbc_aes3.encrypt(str.bytes)


// 便捷写法解密
let cbc_decrypted = try cbc_aes.decrypt(cbc_encrypted)
let cbc_decryptedData = Data(cbc_decrypted)
let cbc_decryptedStr = String(data: cbc_decryptedData, encoding: .utf8)
print(cbc_decryptedStr)

// 正常写法2 解密
let cbc_decrypted2 = try cbc_aes2.decrypt(cbc_encrypted2)
let cbc_decryptedStr2 = String(data: Data(cbc_decrypted2), encoding: .utf8)
print(cbc_decryptedStr2)


// 随机密钥偏移量解密
let cbc_decrypted3 = try cbc_aes3.decrypt(cbc_encrypted3)
let cbc_decryptedStr3 = String(data: Data(cbc_decrypted3), encoding: .utf8)
print(cbc_decryptedStr3)
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/08/Swift加密相关/" data-id="cjx3gd6ny001tobfylye9wrag" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/AES-Base64-MD5/">AES, Base64, MD5</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Mac-安装MySQL" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/14/Mac-安装MySQL/" class="article-date">
  <time datetime="2017-12-14T14:52:19.000Z" itemprop="datePublished">2017-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/14/Mac-安装MySQL/">Mac 安装MySQL</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>搭建 <code>XMPP</code> 即使通讯</p>
<h2 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h2><ul>
<li><p>安装MySQL 数据库    </p>
<ul>
<li><p><a href="https://www.mysql.com/" target="_blank" rel="noopener">官网</a> 下载安装包</p>
<p><strong>特别强调：不要一直<code>下一步</code>最后的时候会有个弹窗提示你生成root的临时密码，记录一下</strong></p>
</li>
</ul>
</li>
<li><p>安装数据库管理工具 <code>MySQLWorkbench</code></p>
<p> 官网安装包下载安装</p>
</li>
<li><p>修改数据库 root 密码，</p>
<p>  打开<code>MySQLWorkbench</code> 随便打开一个SQL 输入安装时记录的密码，确认后提示你修改密码，</p>
</li>
<li><p>如果为记住安装时密码，参考下面链接修改</p>
<p>  <a href="https://www.cnblogs.com/sunny3096/p/7954129.html" target="_blank" rel="noopener"></a> </p>
</li>
</ul>
<h2 id="安装-openfire"><a href="#安装-openfire" class="headerlink" title="安装 openfire"></a>安装 openfire</h2><ul>
<li><p><a href="https://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="noopener">官网</a> 下载安装包安装</p>
</li>
<li><p>安装后需重启系统偏好设置</p>
</li>
<li>如果出现右边的管理员配置按钮不能点击，请使用 <code>brew</code> 安装 或者更新 <code>Java</code> 环境，<code>openfire</code> 需要 <code>Java</code> 环境  </li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/12/14/Mac-安装MySQL/" data-id="cjx3gd6nb000kobfypnk9z97x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-本地已有项目添加Pod" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/02/本地已有项目添加Pod/" class="article-date">
  <time datetime="2017-12-01T16:38:18.000Z" itemprop="datePublished">2017-12-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/02/本地已有项目添加Pod/">本地已有项目添加Pod</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇中主要记录了如何使用 <code>pod</code> 工具自动创建 <code>pod</code> 库并且生成一个测试Demo，这边主要记录给已有的项目添加 <code>pod</code></p>
<h2 id="创建-podsepc-文件"><a href="#创建-podsepc-文件" class="headerlink" title="创建 .podsepc 文件"></a>创建 .podsepc 文件</h2><ul>
<li><p><code>cd</code> 到已有项目的根目录执行命令： <code>pod spec create [ProjectName].podspec</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create EmotionKeyboard.podspec</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="修改编辑-podsepc-文件"><a href="#修改编辑-podsepc-文件" class="headerlink" title="修改编辑 .podsepc 文件"></a>修改编辑 <code>.podsepc</code> 文件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">	s.name         = &quot;EmotionKeyboard&quot;</span><br><span class="line">  	s.version      = &quot;0.0.1&quot;</span><br><span class="line">  	s.summary      = &quot;A  Emotional Keyboard.&quot;</span><br><span class="line">  	</span><br><span class="line">  	# 此处的格式不能修改</span><br><span class="line">  	s.description  = &lt;&lt;-DESC</span><br><span class="line"></span><br><span class="line">	Swift Emotional Keyboard</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">	s.homepage     = &quot;https://github.com/aTreey/EmotionKeyboard&quot;</span><br><span class="line">	</span><br><span class="line">	# 两种写法，使用下面第二种  </span><br><span class="line">	# s.license      = &quot;MIT (example)&quot;</span><br><span class="line">	s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line">	</span><br><span class="line">	s.author             = &#123; &quot;aTree&quot; =&gt; &quot;480814177@qq.com&quot; &#125;</span><br><span class="line">	</span><br><span class="line">	s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line">	</span><br><span class="line">	s.source       = &#123; :git =&gt; &quot;https://github.com/aTreey/EmotionKeyboard.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	# 从 .podspec 同级别的目录下起匹配 </span><br><span class="line">	s.source_files  = &quot;EmotionKeyboard&quot;, &quot;EmotionKeyboard/Classes/**/*.&#123;h,m&#125;&quot;</span><br><span class="line">	</span><br><span class="line">	# 设置自己项目中依赖的系统库</span><br><span class="line">	s.framework  = &quot;UIKit&quot;</span><br><span class="line">  	</span><br><span class="line">	``` </span><br><span class="line">	</span><br><span class="line">## 调整文件的目录结构</span><br><span class="line">	</span><br><span class="line">- 在项目根目录下新建一个放组件代码的文件夹</span><br><span class="line">- 如果项目中包含 `bundle` 文件, 需要在组件文件夹下新建一个 `Assets` 文件夹，用来存放组件中的资源</span><br><span class="line"></span><br><span class="line">	最终结果如下:</span><br><span class="line">	</span><br><span class="line">	![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl7ykslj21gc0o80xt.jpg))</span><br><span class="line"></span><br><span class="line">- 创建并添加必要文件</span><br><span class="line">	</span><br><span class="line">	- `LICENSE` 文件: 开源许可文件, 如果创建项目的时候选择了开源许可就可以自动生成忽略此步骤,如果没有直接拷贝一份其他的工程中的即可</span><br><span class="line">	- `README.md` 文件: 主要用来说明你开源库的信息及使用方法</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">## 验证本地 `.podspec` 文件</span><br><span class="line"></span><br><span class="line">- 错误1: `.podspec `中的文件路径设置错误</span><br><span class="line">	</span><br><span class="line">	![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jlboq82j20v807ejug.jpg)</span><br><span class="line">	</span><br><span class="line">- 错误2: bundle 文件资源路径错误</span><br><span class="line"></span><br><span class="line">	![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl4shnnj20zq0cwgqf.jpg)</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">- 本地验证结果</span><br><span class="line"></span><br><span class="line"> - **EmotionKeyboard passed validation.** 本地验证验证通过</span><br><span class="line"></span><br><span class="line">## 网络验证 `.podspec` 文件 </span><br><span class="line">	</span><br><span class="line">- 给 `master` 分支打上 `.podspec` 文件中对应的 `tag` 标签, 提交推送, </span><br><span class="line">- 执行命令</span><br></pre></td></tr></table></figure>

pod spec lint
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 网络验证结果</span><br></pre></td></tr></table></figure>

EmotionKeyboard.podspec passed validation.
```
</code></pre><p><strong>本文参考</strong></p>
<p><a href="http://blog.xianqu.org/2015/08/pod-resources/" target="_blank" rel="noopener">给 Pod 添加资源文件</a></p>
<p><a href="http://swift.gg/2016/12/15/cocoapods-making-guide/" target="_blank" rel="noopener">基于 Swift 创建 CocoaPods 完全指南</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/12/02/本地已有项目添加Pod/" data-id="cjx3gd6ok002yobfyj30hy18j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-CocoaPods制作私有pod" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/11/29/CocoaPods制作私有pod/" class="article-date">
  <time datetime="2017-11-29T12:57:56.000Z" itemprop="datePublished">2017-11-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/29/CocoaPods制作私有pod/">CocoaPods制作私有pod</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="CocoaPods原理"><a href="#CocoaPods原理" class="headerlink" title="CocoaPods原理"></a>CocoaPods原理</h2><p><strong>本文主要记录制作自己的pod库过程</strong></p>
<p>CocoaPods 是自动化工具，主要用来管理一些开源的第三方框架，或者是制作自己的私有库,开源库,也可以使用它讲自己的项目组件化。</p>
<p>具体可以参考：</p>
<ol>
<li><a href="https://juejin.im/post/58730a25a22b9d0058971144" target="_blank" rel="noopener">细聊 Cocoapods 与 Xcode 工程配置</a></li>
<li><a href="https://juejin.im/post/59f2c7eaf265da432c2318e5" target="_blank" rel="noopener">你真的会用 CocoaPods 吗?</a></li>
</ol>
<h2 id="CocoaPods-安装"><a href="#CocoaPods-安装" class="headerlink" title="CocoaPods 安装"></a>CocoaPods 安装</h2><p><a href="http://www.pluto-y.com/cocoapods-getting-stared/" target="_blank" rel="noopener">安装教程</a></p>
<h2 id="创建私有索引仓库"><a href="#创建私有索引仓库" class="headerlink" title="创建私有索引仓库"></a>创建私有索引仓库</h2><p>每次使用第三方开源库的时候只需要在 <code>Podfile</code> 文件中指定所用的库然后 <code>Pod install</code> ，这是因为安装pod的时候 <code>pod setup</code> 从<a href="https://github.com/CocoaPods/Specs">远程仓库</a>（索引库） clone到了本地,此仓库中存放了所有支持pod框架的描述信息(包括每个库的各个版本)</p>
<p>文件目录：</p>
<pre><code>~/.cocoapods/repos/master
</code></pre><ul>
<li><p>在 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 或者 <a href>coding</a> 上创建一个私有仓库</p>
</li>
<li><p>添加私有库到CocoaPods</p>
<ul>
<li><p>格式 <code>pod repo add [repoName] (URL)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">	pod repo add PrivateSpec https://gitee.com/aapenga/PrivateSpec.git </span><br><span class="line">	```	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 创建本地私有库</span><br><span class="line"></span><br><span class="line"> - `cd` 到任意一个文件夹下, 执行 `pod lib create [项目名]`</span><br><span class="line">	</span><br><span class="line">	``` </span><br><span class="line"> 	pod lib create PPExcelView</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>将文件放入到生成的 Demo 文件夹 的 <code>Classes</code> 文件目录下</li>
<li><p><code>cd</code> 到 <code>Example</code> 下(含有 <code>Podfile</code> 文件) 执行</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure>
<p>或者</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 此时添加的文件出现在 <code>Dome</code> Pod 的 <code>Development Pods</code> 目录中</p>
<ul>
<li><p>从本地验证 pod 是否通过</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure>
<p>  如果有警告，可以使用 <code>--private</code> 或者 <code>--allow-warnings</code> 忽略</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --private</span><br></pre></td></tr></table></figure>
<p> <strong>出现     <code>PPExcelView passed validation.</code> 为通过</strong></p>
</li>
<li><p>从远程仓库验证 pod </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure>
<p>  <strong>出现     <code>PPExcelView.podspec passed validation</code> 为通过</strong></p>
</li>
</ul>
<h2 id="推送-podspec-文件到私有仓库"><a href="#推送-podspec-文件到私有仓库" class="headerlink" title="推送 .podspec 文件到私有仓库"></a>推送 <code>.podspec</code> 文件到私有仓库</h2><p><code>cd</code> 到 <code>.podspec</code> 所在的文件下</p>
<pre><code>pod repo push MyGitSpec PPExcelView.podspec
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/11/29/CocoaPods制作私有pod/" data-id="cjx3gd6mr0001obfy24xh2i3z" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Alamofire源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/10/Alamofire源码学习/" class="article-date">
  <time datetime="2017-04-10T07:10:31.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/10/Alamofire源码学习/">Alamofire源码学习总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"><a href="#网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中" class="headerlink" title="网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"></a>网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中</h4><ul>
<li><p>如果参数是一个 key-value 形式，Query 格式为：key=value</p>
</li>
<li><p>如果参数是一个数组 key = [value1, value2, value3 ….], </p>
</li>
<li><p>Query 格式为 key[]=value1&amp;key[]=value2&amp;key[]=value3</p>
</li>
<li><p>如果参数是一个字典</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = [“subKey1”:”value1”, “subKey2”:”value2”, “subKey3”:”value3”….],</span><br></pre></td></tr></table></figure>
<ul>
<li>Query 的格式为 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key[subKey1]=value1&amp;key[subKey2]=value2&amp;key[subKey3]=value3</span><br></pre></td></tr></table></figure>
<ul>
<li>Alamfire中的编码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private func query(_ parameters: [String: Any]) -&gt; String &#123;</span><br><span class="line">        var components: [(String, String)] = []</span><br><span class="line">        for key in parameters.keys.sorted(by: &lt;) &#123;</span><br><span class="line">            let value = parameters[key]!</span><br><span class="line">            components += queryComponents(fromKey: key, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        return components.map &#123; &quot;\($0)=\($1)&quot; &#125;.joined(separator: &quot;&amp;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">public func queryComponents(fromKey key: String, value: Any) -&gt; [(String, String)] &#123;</span><br><span class="line">        var components: [(String, String)] = [] // 元祖数组</span><br><span class="line">        if let dictionary = value as? [String: Any] &#123; // value 为字典，key[subKey]=value 形式</span><br><span class="line">            for (nestedKey, value) in dictionary &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[\(nestedKey)]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let array = value as? [Any] &#123; // value为数组， key[]=value 形式 </span><br><span class="line">            for value in array &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let value = value as? NSNumber &#123; // value为 NSNumber</span><br><span class="line">            if value.isBool &#123;</span><br><span class="line">                components.append((escape(key), escape((value.boolValue ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let bool = value as? Bool &#123; // value 为 Bool </span><br><span class="line">            components.append((escape(key), escape((bool ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">        &#125; else &#123; // value 为字符串时 直接转义</span><br><span class="line">            components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">        return components</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/04/10/Alamofire源码学习/" data-id="cjx3gd6ms0002obfy59r90ye3" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Alamofire/">Alamofire</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-知识点总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/25/知识点总结/" class="article-date">
  <time datetime="2017-03-25T05:41:28.000Z" itemprop="datePublished">2017-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/25/知识点总结/">知识点总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>开发中的知识点总结</p>
<p>textField</p>
<p>使用textField自定义搜索框，textField及leftView等属性<br>使用leftView 时需要设置model为始终显示<br>可以设置leftView的frame 调整图片大小<br>IBInsepectable IBDesignable 的使用</p>
<p>给属性检查器面板中添加属性设置选项<br>IBDesignalbe 实时显示UI控件，需要讲对应的xib和对应类绑定</p>
<p>增加分类</p>
<p>新建一个swift 文件，</p>
<p>使用extension，重写 get set方法<br>使用newValue 时需要判断,注意返回值的类型是否匹配<br>试图切换</p>
<p>一个控制器中加载不同视图，可以在loadView 方法中自定义根视图</p>
<p>loadView 使用注意事项<br>如果实现loadView 未调用 super loadView ，sb／xib实效<br>loadView调用时，如果根视图是nil（本质是未调用super loadView），会自动调用loadView 方法初始化根视图，形成递归调用<br>判断当前登陆标识的状态确定是调用 super loadView 还是 把创建自定义的根视图赋值给 view<br>VFL 的使用</p>
<p>使用之前需要先 关闭frame 的布局才能手动的添加约束 translatesAutoresizingMaskIntoConstraints = false<br>基本动画使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/03/25/知识点总结/" data-id="cjx3gd6ol0031obfyx79eh1ce" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift3.0学习(三)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/08/Swift3.0学习(三)/" class="article-date">
  <time datetime="2017-03-08T15:29:43.000Z" itemprop="datePublished">2017-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/08/Swift3.0学习(三)/">Swift3.0学习(三)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>面向对象–必选属性</p>
<p>构造函数时是分段构造，先构造子类，给’必选属性’设置初始值，然后再构造父类，<br>定义全局变量（属性）时，需要在构造函数中设置初始化变量值<br>super.init()是一个类构造结束<br>重写： override 函数重写（覆盖），如果在重写的方法中 没有super, 父类相关的一些操作就不会被执行<br>重载：函数名相同, 参数的类型 或者参数的个数不同 就形成了函数的重载<br>注意：重载构造函数,并且父类默认的构造函数 init()不重写， 父类默认的构造函数就不能够被访问,不能够确保必选属性设置初始值，只能调用重载的构造函数<br>面向对象–可选属性</p>
<p>使用KVC给对象设置值<br>注意: 在swift中使用KVC 基本数据类型不能声明为可选项,必须设置为必选项给定初始值</p>
<p>KVC实现的流程<br>遍历字典的键值 给对象发送 setValue: forKey消息<br>如果key 对象的属性不存在就将消息转发给 setVale: forUndefinedKey:<br>如果存在就直接设置值<br>注意:setVale: forUndefinedKey: 默认抛出异常 不能够super，如果super 相当于没有实现此方法</p>
<p>面向对象–便利构造函数</p>
<p>作用：方便快捷的创建对象<br>场景：<br>可检查参数是否正确来实例化<br>实例化控件<br>特点<br>必须以self来调用构造函数<br>指定的构造函数不能被重写，也不能被super调用<br>便利构造函数可被子类继承<br>可以构造失败，返回nil<br>面向对象 – 描述信息</p>
<p>重写 description 方法，返回值是string类型<br>使用kvc讲对象属性转换为字典<br>将字典转化为string类型</p>
<pre><code>override var description: String {
        let keys = [&quot;name&quot;,&quot;age&quot;,&quot;number&quot;,&quot;sex&quot;]

        // 对象转为字典
        let dict = self.dictionaryWithValuesForKeys(keys)

        // 每个对象都有描述属性
        return dict.description
    }
</code></pre><p>面向对象 – 存储属性</p>
<p>面向对象 – 计算属性(readOnly)</p>
<p>只有getter，没有setter<br>只能取值不能赋值<br>每次调用都会被执行，消耗cpu<br>不占内存空间，依赖其他的属性来计算<br>面向对象 – didset 属性设置监察器</p>
<p>能获取 oldValue 和 newValue 的值<br>通常用来重写setter方法，实现视图绑定模型<br>在一个属性的didset中计算其他属性</p>
<p>缺点：消耗内存，被计算的属性占内存<br>优点：减少了cpu消耗<br>懒加载</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/03/08/Swift3.0学习(三)/" data-id="cjx3gd6nt001gobfyyox7belm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift/">swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Swift3.0学习(二)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/05/Swift3.0学习(二)/" class="article-date">
  <time datetime="2017-03-05T15:36:21.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/05/Swift3.0学习(二)/">Swift3.0学习(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>字符串</p>
<p>字符串遍历<br>字符串字节长度<br>字符串长度</p>
<p>let string = “我是switf,语言”</p>
<p>   // 字符串遍历<br>   for s in string.characters {<br>       print(s)<br>   }</p>
<p>   // 字符串的长度<br>   let length = string.characters.count;<br>   print(length)</p>
<p>   // 字符串字节长度 汉字对应3个字节，英文是1个字节<br>   let characterLength = string.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)<br>   print(characterLength)</p>
<p>字符串拼接</p>
<pre><code>let str1 = &quot;你好&quot;
   let str2 = &quot;不好&quot;
   let a = 20

   // 第一种拼接
   print(&quot;\(str1)\(str2)\(a)&quot;)

   // 第二种拼接
   let str = str1 + str2
   let strA = str1 + String(a)
   print(str)
   print(strA)
</code></pre><p>截取子串 as 的使用</p>
<pre><code>let subString = str1.substringToIndex(&quot;小程生生世世&quot;.endIndex);
   print(subString)

   let subStr = str1.substringFromIndex(&quot;听说&quot;.startIndex)
   print(subStr)

   let range = str1.rangeOfString(&quot;小程序&quot;)
   let subStr1 = str1.substringWithRange(range!)

   print(subStr1)

   // 截取到某一个位置
   let subStr2 = str1.substringFromIndex(str1.endIndex.advancedBy(-2))
   print(subStr2)

   // 限制截取几个字符
   let subStr3 = str1.substringToIndex(str1.startIndex.advancedBy(5, limit: str1.characters.endIndex))
   print(subStr3)
String 和 NSString 之间的 使用 as 无缝转换
let helloString = &quot;我们一起飞&quot;
(helloString as NSString).substringWithRange(NSMakeRange(2, 3))
数组
</code></pre><p>可以放不同类型的元素<br>let不可变数组,var可变数组</p>
<pre><code>// 初始化一个空数组 [String]声明是一个装有字符串的数组类型
   var emptyArray: [String] = [String]()

// 可变数组
   var array = [&quot;哈哈&quot;,&quot;呵呵&quot;,&quot;嘿嘿&quot;]
   array.append(&quot;咯咯&quot;)
   print(&quot;array = \(array)&quot;)

   // 不可变数组
   let array2 = [&quot;可可&quot;,&quot;噗噗&quot;]

   // 数组拼接
   let arr = array + array2
   print(&quot;arr = \(arr)&quot;)

   array += array2
   print(&quot;array = \(array)&quot;)
</code></pre><p>数组遍历</p>
<pre><code>// 1. 
   for i in 0 ..&lt; tempArray.count {
       print(tempArray[i])
   }


   // 2. 
   for obj in tempArray {
       print(&quot;第二种方法:\(obj)&quot;)
   }


   // 3. 快速便利
   for (index,value) in tempArray.enumerate() {
       print(&quot;index = \(index), value = \(value)&quot;)
   }
</code></pre><p>字典和OC类似</p>
<p>函数调用</p>
<p>必须在函数声明的下面调用内部函数</p>
<p>可以定义函数的外部参数和内部参数</p>
<p>可以在参数前面加上 ‘# ’ 表明函数的外部参数和内部参数名称一样 swift3.0 以后废弃</p>
<p>无参无返回值<br>三种写法</p>
<pre><code>func demo9() -&gt; Void {
       print(&quot;无参无返回值第一种写法&quot;)
   }


   func demo_9() -&gt; () {
       print(&quot;无参无返回值第二种写法&quot;)
   }

   func demo_99() {
       print(&quot;无参无返回值第三种写法&quot;)
   }
</code></pre><p>有参有返回值</p>
<pre><code>func demo10(width a: Int, height b: Int) -&gt; Int {
   return a * b
</code></pre><p>   }</p>
<p>闭包</p>
<p>和OC中block类似，<br>和在函数中调用一个内部函数原理相同<br>可当作参数传递<br>在需要时执行闭包实现回调</p>
<pre><code>// 定义闭包
let closure = {() -&gt; () in
       print(&quot;闭包实现&quot;)
   }

   // 执行闭包
   closure()
</code></pre><p>注意循环引用</p>
<p>只有两个对象相互强引用或者三个对象相互强引用形成闭环时才会形成循环引用</p>
<p>weak 和 unsafe_unretained的区别</p>
<p>__weak iOS5.0 推出，当对象被系统回收时，对象的地址会自动指向nil</p>
<p>____unsafe_unretained iOS4.0 推出，当对象被系统回收时，对象的地址不会自动指向nil,会造成野指针访问<br>解决办法：(官方推荐)weak - strong -dance 解决循环引用，AFNetworking中</p>
<p>尾随闭包</p>
<p>函数的最后一个参数时闭包的时候，函数的参数 ‘()’可以提前关闭，闭包写在 ‘（）’后面，当作尾随闭包来使用</p>
<p>swift 和 OC 区别</p>
<p>swift 和 OC语法的快速的对比</p>
<p>XXX.init(xxx) ==&gt; XXX.(xxx)<br>selector 类型 ==&gt; ‘函数名’<br>对象方法的调用 是 ‘.’ self是可以省略的<br>枚举 枚举名 + 枚举值的名 =&gt; .枚举值的名<br>常量 和变量</p>
<p>let 声明常量 var 声明变量<br>变量/常量的类型是自动推到的<br>不同类型之间不能够直接运算 需要手动转换数据类型<br>可选项<br>‘?’ 表示表示可选项 可能有值 可能为 nil<br>可选项会自动带上 Optional 字样<br>可选项不能够直接参与运算 需要强制解包<br>‘!’ 表示强制解包 获取可选项中具体的值<br>‘??’ 快速判断可选项是否为nil 如果为 nil 就去取 ‘??’后面的默认值<br>控制流<br>if 没有非零即真的概念 必须制定明确的条件<br>if let 快速赋值 并且判断赋值对象是否为 nil 如果不为nil 就进入分之执行相关逻辑代码<br>guard let 作用和 if let 相反 好处: 可以减少一层分支嵌套<br>where 多重判断 注意 和 &amp;&amp; || 不一样的<br>循环</p>
<p>for in<br>0..&lt;10<br>0…10<br>字符串</p>
<p>更加轻量级 更加高效 是 结构体<br>支持快速遍历<br>长度<br>拼接<br>截取 as<br>集合 let 声明不可变的集合 var 声明可变的集合</p>
<p>声明 []<br>声明一个 空的集合<br>增删改查<br>合并<br>遍历<br>函数</p>
<p>func 函数名称(外部参数1 内部参数1: 类型, 外部参数2 内部参数2: 类型) -&gt; Int {执行的代码}<br>函数没有返回值的三种方式<br>函数内部函数<br>闭包 () -&gt; () 没有参数没有返回值的闭包类型</p>
<p>提前准备好的一段可以执行代码块<br>可以当做参数传递<br>在需要的时候执行闭包产生回调的效果<br>在闭包中使用self 需要考虑循环引用<br>函数是一种特殊的闭包</p>
<p>block 的循环引用的解除<br><strong>weak 和 weak关键字作用类似 当属性对象被回收是 会自动指向nil<br>_</strong>unsafeunretained 和 assgin关键字作用类似 当属性对象被回收是 不会自动指向nil, 会造成野指针访问 weak -strong - dance</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2017/03/05/Swift3.0学习(二)/" data-id="cjx3gd6nu001iobfy5qdem6l8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/swift/">swift</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/5/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/7/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AES-Base64-MD5/">AES, Base64, MD5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Alamofire/">Alamofire</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AlertView/">AlertView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter/">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flutter-GridView/">Flutter GridView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GCD/">GCD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OC-JS/">OC, JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quartz-2D/">Quartz 2D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quartz2D/">Quartz2D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RunTime/">RunTime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDWebImage/">SDWebImage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TableView/">TableView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WKWebView/">WKWebView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步/">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/本地缓存/">本地缓存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AES-Base64-MD5/" style="font-size: 10px;">AES, Base64, MD5</a> <a href="/tags/Alamofire/" style="font-size: 10px;">Alamofire</a> <a href="/tags/AlertView/" style="font-size: 10px;">AlertView</a> <a href="/tags/Flutter/" style="font-size: 10px;">Flutter</a> <a href="/tags/Flutter-GridView/" style="font-size: 10px;">Flutter GridView</a> <a href="/tags/GCD/" style="font-size: 10px;">GCD</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/OC-JS/" style="font-size: 10px;">OC, JS</a> <a href="/tags/Quartz-2D/" style="font-size: 10px;">Quartz 2D</a> <a href="/tags/Quartz2D/" style="font-size: 15px;">Quartz2D</a> <a href="/tags/RunTime/" style="font-size: 10px;">RunTime</a> <a href="/tags/SDWebImage/" style="font-size: 10px;">SDWebImage</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/TableView/" style="font-size: 10px;">TableView</a> <a href="/tags/WKWebView/" style="font-size: 20px;">WKWebView</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/本地缓存/" style="font-size: 10px;">本地缓存</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/19/Flutter中布局/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/18/Flutter中GridView组件/">GridView组件使用.md</a>
          </li>
        
          <li>
            <a href="/2019/06/18/第十四章第三方库面试/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/18/第十章网络相关/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/06/18/第四章OC语言特性面试/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 aTreey<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>